%module pySU2

%{
#define SWIG_FILE_WITH_INIT
#include "../../Common/include/config_structure.hpp"
#include "../../Common/include/config_structure.inl"
#include "../../Common/include/option_structure.hpp"
    
#include "../../SU2_CFD/include/transport_model.hpp"
#include "../../SU2_CFD/include/transport_model.inl"
    
#include "../../SU2_CFD/include/fluid_model.hpp"
#include "../../SU2_CFD/include/fluid_model.inl"
    
#include "../../Common/include/vector_structure.hpp"
#include "../../Common/include/vector_structure.inl"
    
#include "../../Common/include/dual_grid_structure.hpp"
#include "../../Common/include/dual_grid_structure.inl"
    
#include "../../Common/include/primal_grid_structure.hpp"
#include "../../Common/include/primal_grid_structure.inl"
    
#include "../../Common/include/geometry_structure.hpp"
#include "../../Common/include/geometry_structure.inl"
    
#include "../../Common/include/matrix_structure.hpp"
#include "../../Common/include/matrix_structure.inl"
    
#include "../../Common/include/linear_solvers_structure.hpp"
#include "../../Common/include/linear_solvers_structure.inl"
    
#include "../../Common/include/grid_adaptation_structure.hpp"
#include "../../Common/include/grid_adaptation_structure.inl"
    
#include "../../Common/include/grid_movement_structure.hpp"
#include "../../Common/include/grid_movement_structure.inl"
    
#include "../../SU2_CFD/include/variable_structure.hpp"
#include "../../SU2_CFD/include/variable_structure.inl"
    
#include "../../SU2_CFD/include/numerics_machine_learning_turbulent.hpp"
    
#include "../../SU2_CFD/include/numerics_machine_learning.hpp"
#include "../../SU2_CFD/include/numerics_machine_learning.inl"
    
#include "../../SU2_CFD/include/numerics_structure.hpp"
#include "../../SU2_CFD/include/numerics_structure.inl"
    
#include "../../SU2_CFD/include/solver_structure.hpp"
#include "../../SU2_CFD/include/solver_structure.inl"
    
#include "../../SU2_CFD/include/integration_structure.hpp"
#include "../../SU2_CFD/include/integration_structure.inl"
    
#include "../../SU2_CFD/include/output_structure.hpp"
    
#include "../../SU2_CFD/include/iteration_structure.hpp"
    
#include "../../SU2_CFD/include/definition_structure.hpp"
    
#include "../include/SU2_interface.hpp"
    
#include <stdlib.h>
#include <cmath>
#include <iostream>
#include <cstdlib>
#include <vector>

%}

%include "../../Common/include/config_structure.hpp"
%include "../../Common/include/config_structure.inl"

%include "../../SU2_CFD/include/transport_model.hpp"
%include "../../SU2_CFD/include/transport_model.inl"

%include "../../SU2_CFD/include/fluid_model.hpp"
%include "../../SU2_CFD/include/fluid_model.inl"

%include "../../Common/include/vector_structure.hpp"
%include "../../Common/include/vector_structure.inl"

%include "../../Common/include/dual_grid_structure.hpp"
%include "../../Common/include/dual_grid_structure.inl"

%include "../../Common/include/primal_grid_structure.hpp"
%include "../../Common/include/primal_grid_structure.inl"

%include "../../Common/include/geometry_structure.hpp"
%include "../../Common/include/geometry_structure.inl"

%include "../../Common/include/matrix_structure.hpp"
%include "../../Common/include/matrix_structure.inl"

%include "../../Common/include/linear_solvers_structure.hpp"
%include "../../Common/include/linear_solvers_structure.inl"

%include "../../Common/include/grid_adaptation_structure.hpp"
%include "../../Common/include/grid_adaptation_structure.hpp"

%include "../../Common/include/grid_movement_structure.hpp"
%include "../../Common/include/grid_movement_structure.inl"

%include "../../SU2_CFD/include/variable_structure.hpp"
%include "../../SU2_CFD/include/variable_structure.inl"

%include "../../SU2_CFD/include/numerics_machine_learning_turbulent.hpp"

%include "../../SU2_CFD/include/numerics_machine_learning.hpp"
%include "../../SU2_CFD/include/numerics_machine_learning.inl"

%include "../../SU2_CFD/include/numerics_structure.hpp"
%include "../../SU2_CFD/include/numerics_structure.inl"

%include "../../SU2_CFD/include/solver_structure.hpp"
%include "../../SU2_CFD/include/solver_structure.inl"

%include "../../SU2_CFD/include/integration_structure.hpp"
%include "../../SU2_CFD/include/integration_structure.inl"

%include "../../SU2_CFD/include/output_structure.hpp"

%include "../../SU2_CFD/include/iteration_structure.hpp"

%include "../../SU2_CFD/include/definition_structure.hpp"

%include "../include/SU2_interface.hpp"

%include "std_string.i"
%include "std_map.i"
%include "std_vector.i"

namespace std
{
    %template(IntVector) vector<int>;
    %template(VecIntVector) vector< vector<int> >;
    %template(VecDouble) vector<double>;
    %template(VecVecdouble) vector< vector<double> >;
    %template(StringVector) vector<string>;
}


/* Config structure.hpp------------------------------------------------------------
*
*
*
*/

/*!
 * \class CConfig
 * \brief Main class for defining the problem; basically this class reads the configuration file, and
 *        stores all the information.
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */

class CConfig {
private:
    unsigned short Kind_SU2; /*!< \brief Kind of SU2 software component.*/
    unsigned short Ref_NonDim; /*!< \brief Kind of of non dimensionalization.*/
    unsigned short iZone, nZone; /*!< \brief Number of zones in the mesh. */
    double OrderMagResidual; /*!< \brief Order of magnitude reduction. */
    double MinLogResidual; /*!< \brief Minimum value of the log residual. */
    double EA_ScaleFactor; /*!< \brief Equivalent Area scaling factor */
    double* EA_IntLimit; /*!< \brief Integration limits of the Equivalent Area computation */
    double AdjointLimit; /*!< \brief Adjoint variable limit */
    bool MG_AdjointFlow; /*!< \brief MG with the adjoint flow problem */
    double* Subsonic_Engine_Box; /*!< \brief Coordinates of the box subsonic region */
    double* Hold_GridFixed_Coord; /*!< \brief Coordinates of the box to hold fixed the nbumerical grid */
    unsigned short ConvCriteria;	/*!< \brief Kind of convergence criteria. */
    unsigned short nFFD_Iter; 	/*!< \brief Iteration for the point inversion problem. */
    double FFD_Tol;  	/*!< \brief Tolerance in the point inversion problem. */
    bool Viscous_Limiter_Flow, Viscous_Limiter_Turb;			/*!< \brief Viscous limiters. */
    bool Adjoint,			/*!< \brief Flag to know if the code is solving an adjoint problem. */
    Viscous,                /*!< \brief Flag to know if the code is solving a viscous problem. */
    EquivArea,				/*!< \brief Flag to know if the code is going to compute and plot the equivalent area. */
    InvDesign_Cp,				/*!< \brief Flag to know if the code is going to compute and plot the inverse design. */
    InvDesign_HeatFlux,				/*!< \brief Flag to know if the code is going to compute and plot the inverse design. */
    Linearized,				/*!< \brief Flag to know if the code is solving a linearized problem. */
    Grid_Movement,			/*!< \brief Flag to know if there is grid movement. */
    Wind_Gust,              /*!< \brief Flag to know if there is a wind gust. */
    Aeroelastic_Simulation, /*!< \brief Flag to know if there is an aeroelastic simulation. */
    Rotating_Frame,			/*!< \brief Flag to know if there is a rotating frame. */
    PoissonSolver,			/*!< \brief Flag to know if we are solving  poisson forces  in plasma solver. */
    Low_Mach_Precon,		/*!< \brief Flag to know if we are using a low Mach number preconditioner. */
    GravityForce,			/*!< \brief Flag to know if the gravity force is incuded in the formulation. */
    SmoothNumGrid,			/*!< \brief Smooth the numerical grid. */
    AdaptBoundary,			/*!< \brief Adapt the elements on the boundary. */
    Engine_Intake,			/*!< \brief Engine intake subsonic region. */
    Frozen_Visc,			/*!< \brief Flag for adjoint problem with/without frozen viscosity. */
    Sens_Remove_Sharp,			/*!< \brief Flag for removing or not the sharp edges from the sensitivity computation. */
    Hold_GridFixed,	/*!< \brief Flag hold fixed some part of the mesh during the deformation. */
    Axisymmetric, /*!< \brief Flag for axisymmetric calculations */
    DebugMode, /*!< \brief Flag for debug mode */
    ionization;  /*!< \brief Flag for determining if free electron gas is in the mixture */
    double Damp_Engine_Inflow;	/*!< \brief Damping factor for the engine inlet. */
    double Damp_Engine_Bleed;	/*!< \brief Damping factor for the engine bleed. */
    double Damp_Engine_Exhaust;	/*!< \brief Damping factor for the engine exhaust. */
    double Damp_Res_Restric,	/*!< \brief Damping factor for the residual restriction. */
    Damp_Correc_Prolong; /*!< \brief Damping factor for the correction prolongation. */
    double Position_Plane; /*!< \brief Position of the Near-Field (y coordinate 2D, and z coordinate 3D). */
    double WeightCd; /*!< \brief Weight of the drag coefficient. */
    unsigned short Unsteady_Simulation;	/*!< \brief Steady or unsteady (time stepping or dual time stepping) computation. */
    unsigned short nStartUpIter;	/*!< \brief Start up iterations using the fine grid. */
    double FixAzimuthalLine; /*!< \brief Fix an azimuthal line due to misalignments of the nearfield. */
    double *DV_Value;		/*!< \brief Previous value of the design variable. */
    double LimiterCoeff;				/*!< \brief Limiter coefficient */
    unsigned long LimiterIter;	/*!< \brief Freeze the value of the limiter after a number of iterations */
    double SharpEdgesCoeff;				/*!< \brief Coefficient to identify the limit of a sharp edge. */
    unsigned short SystemMeasurements; /*!< \brief System of measurements. */
    unsigned short Kind_Regime;  /*!< \brief Kind of adjoint function. */
    unsigned short Kind_ObjFunc;  /*!< \brief Kind of objective function. */
    unsigned short Kind_SensSmooth; /*!< \brief Kind of sensitivity smoothing technique. */
    unsigned short Continuous_Eqns; /*!< \brief Which equations to treat continuously (Hybrid adjoint)*/
    unsigned short Discrete_Eqns; /*!< \brief Which equations to treat discretely (Hybrid adjoint). */
    unsigned short *Design_Variable; /*!< \brief Kind of design variable. */
    double RatioDensity,				/*!< \brief Ratio of density for a free surface problem. */
    RatioViscosity,				/*!< \brief Ratio of viscosity for a free surface problem. */
    FreeSurface_Thickness,  /*!< \brief Thickness of the interfase for a free surface problem. */
    FreeSurface_Outlet,  /*!< \brief Outlet of the interfase for a free surface problem. */
    FreeSurface_Damping_Coeff,  /*!< \brief Damping coefficient of the free surface for a free surface problem. */
    FreeSurface_Damping_Length;  /*!< \brief Damping length of the free surface for a free surface problem. */
    unsigned short Kind_Adaptation;	/*!< \brief Kind of numerical grid adaptation. */
    unsigned short nTimeInstances;  /*!< \brief Number of periodic time instances for Time Spectral integration. */
    double TimeSpectral_Period;		/*!< \brief Period of oscillation to be used with time-spectral computations. */
    double New_Elem_Adapt;			/*!< \brief Elements to adapt in the numerical grid adaptation process. */
    double Delta_UnstTime,			/*!< \brief Time step for unsteady computations. */
    Delta_UnstTimeND;						/*!< \brief Time step for unsteady computations (non dimensional). */
    double Total_UnstTime,						/*!< \brief Total time for unsteady computations. */
    Total_UnstTimeND;								/*!< \brief Total time for unsteady computations (non dimensional). */
    double Current_UnstTime,									/*!< \brief Global time of the unsteady simulation. */
    Current_UnstTimeND;									/*!< \brief Global time of the unsteady simulation. */
    unsigned short nMarker_Euler,	/*!< \brief Number of Euler wall markers. */
    nMarker_FarField,				/*!< \brief Number of far-field markers. */
    nMarker_Custom,
    nMarker_SymWall,				/*!< \brief Number of symmetry wall markers. */
    nMarker_Pressure,				/*!< \brief Number of pressure wall markers. */
    nMarker_PerBound,				/*!< \brief Number of periodic boundary markers. */
    nMarker_NearFieldBound,				/*!< \brief Number of near field boundary markers. */
    nMarker_ActDisk_Inlet, nMarker_ActDisk_Outlet,
    nMarker_InterfaceBound,				/*!< \brief Number of interface boundary markers. */
    nMarker_Dirichlet,				/*!< \brief Number of interface boundary markers. */
    nMarker_Dirichlet_Elec,				/*!< \brief Number of interface boundary markers. */
    nMarker_Inlet,					/*!< \brief Number of inlet flow markers. */
    nMarker_Riemann,					/*!< \brief Number of Riemann flow markers. */
    nMarker_Supersonic_Inlet,					/*!< \brief Number of supersonic inlet flow markers. */
    nMarker_Supersonic_Outlet,					/*!< \brief Number of supersonic outlet flow markers. */
    nMarker_Outlet,					/*!< \brief Number of outlet flow markers. */
    nMarker_Out_1D,         /*!< \brief Number of outlet flow markers over which to calculate 1D outputs */
    nMarker_Isothermal,     /*!< \brief Number of isothermal wall boundaries. */
    nMarker_IsothermalNonCatalytic, /*!< \brief Number of constant temperature wall boundaries. */
    nMarker_IsothermalCatalytic, /*!< \brief Number of constant temperature wall boundaries. */
    nMarker_HeatFlux,       /*!< \brief Number of constant heat flux wall boundaries. */
    nMarker_HeatFluxNonCatalytic, /*!< \brief Number of constant heat flux wall boundaries. */
    nMarker_HeatFluxCatalytic, /*!< \brief Number of constant heat flux wall boundaries. */
    nMarker_EngineExhaust,					/*!< \brief Number of nacelle exhaust flow markers. */
    nMarker_EngineInflow,					/*!< \brief Number of nacelle inflow flow markers. */
    nMarker_EngineBleed,					/*!< \brief Number of nacelle inflow flow markers. */
    nMarker_Displacement,					/*!< \brief Number of displacement surface markers. */
    nMarker_Load,					/*!< \brief Number of load surface markers. */
    nMarker_FlowLoad,					/*!< \brief Number of load surface markers. */
    nMarker_Neumann,				/*!< \brief Number of Neumann flow markers. */
    nMarker_Neumann_Elec,				/*!< \brief Number of Neumann flow markers. */
    nMarker_All,					/*!< \brief Total number of markers using the grid information. */
    nMarker_Max,					/*!< \brief Max number of number of markers using the grid information. */
    nMarker_Config;					/*!< \brief Total number of markers using the config file
                                     (note that using parallel computation this number can be different
                                     from nMarker_All). */
    string *Marker_Euler,			/*!< \brief Euler wall markers. */
    *Marker_FarField,				/*!< \brief Far field markers. */
    *Marker_Custom,
    *Marker_SymWall,				/*!< \brief Symmetry wall markers. */
    *Marker_Pressure,				/*!< \brief Pressure boundary markers. */
    *Marker_PerBound,				/*!< \brief Periodic boundary markers. */
    *Marker_PerDonor,				/*!< \brief Rotationally periodic boundary donor markers. */
    *Marker_NearFieldBound,				/*!< \brief Near Field boundaries markers. */
    *Marker_InterfaceBound,				/*!< \brief Interface boundaries markers. */
    *Marker_ActDisk_Inlet,
    *Marker_ActDisk_Outlet,
    *Marker_Dirichlet,				/*!< \brief Interface boundaries markers. */
    *Marker_Dirichlet_Elec,				/*!< \brief Interface boundaries markers. */
    *Marker_Inlet,					/*!< \brief Inlet flow markers. */
    *Marker_Riemann,					/*!< \brief Riemann markers. */
    *Marker_Supersonic_Inlet,					/*!< \brief Supersonic inlet flow markers. */
    *Marker_Supersonic_Outlet,					/*!< \brief Supersonic outlet flow markers. */
    *Marker_Outlet,					/*!< \brief Outlet flow markers. */
    *Marker_Out_1D,         /*!< \brief Outlet flow markers over which to calculate 1D output. */
    *Marker_Isothermal,     /*!< \brief Isothermal wall markers. */
    *Marker_IsothermalNonCatalytic,     /*!< \brief Isothermal wall markers. */
    *Marker_IsothermalCatalytic,     /*!< \brief Isothermal wall markers. */
    *Marker_HeatFlux,       /*!< \brief Constant heat flux wall markers. */
    *Marker_HeatFluxNonCatalytic,       /*!< \brief Constant heat flux wall markers. */
    *Marker_HeatFluxCatalytic,       /*!< \brief Constant heat flux wall markers. */
    *Marker_EngineInflow,					/*!< \brief Engine Inflow flow markers. */
    *Marker_EngineBleed,					/*!< \brief Engine Inflow flow markers. */
    *Marker_EngineExhaust,					/*!< \brief Engine Exhaust flow markers. */
    *Marker_Displacement,					/*!< \brief Displacement markers. */
    *Marker_Load,					/*!< \brief Load markers. */
    *Marker_FlowLoad,					/*!< \brief Flow Load markers. */
    *Marker_Neumann,					/*!< \brief Neumann flow markers. */
    *Marker_Neumann_Elec,					/*!< \brief Neumann flow markers. */
    *Marker_All_TagBound;				/*!< \brief Global index for markers using grid information. */
    double *Dirichlet_Value;    /*!< \brief Specified Dirichlet value at the boundaries. */
    double *Exhaust_Temperature_Target;    /*!< \brief Specified total temperatures for nacelle boundaries. */
    double *Exhaust_Pressure_Target;    /*!< \brief Specified total pressures for nacelle boundaries. */
    double *Inlet_Ttotal;    /*!< \brief Specified total temperatures for inlet boundaries. */
    double *Riemann_Var1, *Riemann_Var2;    /*!< \brief Specified values for Riemann boundary. */
    double **Riemann_FlowDir;  /*!< \brief Specified flow direction vector (unit vector) for Riemann boundaries. */
    double *Inlet_Ptotal;    /*!< \brief Specified total pressures for inlet boundaries. */
    double **Inlet_FlowDir;  /*!< \brief Specified flow direction vector (unit vector) for inlet boundaries. */
    double *Inlet_Temperature;    /*!< \brief Specified temperatures for a supersonic inlet boundaries. */
    double *Inlet_Pressure;    /*!< \brief Specified static pressures for supersonic inlet boundaries. */
    double **Inlet_Velocity;  /*!< \brief Specified flow velocity vectors for supersonic inlet boundaries. */
    double *Inflow_Mach_Target;    /*!< \brief Specified fan face mach for nacelle boundaries. */
    double *Inflow_Mach;    /*!< \brief Specified fan face mach for nacelle boundaries. */
    double *Inflow_Pressure;    /*!< \brief Specified fan face mach for nacelle boundaries. */
    double *Bleed_MassFlow_Target;    /*!< \brief Specified fan face mach for nacelle boundaries. */
    double *Bleed_MassFlow;    /*!< \brief Specified fan face mach for nacelle boundaries. */
    double *Bleed_Temperature_Target;    /*!< \brief Specified fan face mach for nacelle boundaries. */
    double *Bleed_Temperature;    /*!< \brief Specified fan face mach for nacelle boundaries. */
    double *Bleed_Pressure;    /*!< \brief Specified fan face mach for nacelle boundaries. */
    double *Exhaust_Pressure;    /*!< \brief Specified fan face mach for nacelle boundaries. */
    double *Exhaust_Temperature;    /*!< \brief Specified fan face mach for nacelle boundaries. */
    double *Outlet_Pressure;    /*!< \brief Specified back pressures (static) for outlet boundaries. */
    double *Isothermal_Temperature; /*!< \brief Specified isothermal wall temperatures (static). */
    double *Wall_Catalycity; /*!< \brief Specified wall species mass-fractions for catalytic boundaries. */
    double *Heat_Flux;  /*!< \brief Specified wall heat fluxes. */
    double *Heat_FluxNonCatalytic;  /*!< \brief Specified wall heat fluxes. */
    double *Heat_FluxCatalytic;  /*!< \brief Specified wall heat fluxes. */
    double *Displ_Value;    /*!< \brief Specified displacement for displacement boundaries. */
    double *Load_Value;    /*!< \brief Specified force for load boundaries. */
    double *FlowLoad_Value;    /*!< \brief Specified force for flow load boundaries. */
    double **ActDisk_Origin;
    double *ActDisk_RootRadius;
    double *ActDisk_TipRadius;
    double *ActDisk_PressJump;
    double *ActDisk_TempJump;
    double *ActDisk_Omega;
    unsigned short *ActDisk_Distribution;
    double **Periodic_RotCenter;  /*!< \brief Rotational center for each periodic boundary. */
    double **Periodic_RotAngles;      /*!< \brief Rotation angles for each periodic boundary. */
    double **Periodic_Translation;      /*!< \brief Translation vector for each periodic boundary. */
    unsigned short nPeriodic_Index;     /*!< \brief Number of SEND_RECEIVE periodic transformations. */
    double **Periodic_Center;         /*!< \brief Rotational center for each SEND_RECEIVE boundary. */
    double **Periodic_Rotation;      /*!< \brief Rotation angles for each SEND_RECEIVE boundary. */
    double **Periodic_Translate;      /*!< \brief Translation vector for each SEND_RECEIVE boundary. */
    string *Marker_CfgFile_TagBound;			/*!< \brief Global index for markers using config file. */
    unsigned short *Marker_All_KindBC,			/*!< \brief Global index for boundaries using grid information. */
    *Marker_CfgFile_KindBC;		/*!< \brief Global index for boundaries using config file. */
    short *Marker_All_SendRecv;		/*!< \brief Information about if the boundary is sended (+), received (-). */
    short *Marker_All_PerBound;	/*!< \brief Global index for periodic bc using the grid information. */
    unsigned long nExtIter;			/*!< \brief Number of external iterations. */
    unsigned long ExtIter;			/*!< \brief Current external iteration number. */
    unsigned long IntIter;			/*!< \brief Current internal iteration number. */
    unsigned long Unst_nIntIter;			/*!< \brief Number of internal iterations (Dual time Method). */
    long Unst_RestartIter;			/*!< \brief Iteration number to restart an unsteady simulation (Dual time Method). */
    long Unst_AdjointIter;			/*!< \brief Iteration number to begin the reverse time integration in the direct solver for the unsteady adjoint. */
    unsigned short nRKStep;			/*!< \brief Number of steps of the explicit Runge-Kutta method. */
    double *RK_Alpha_Step;			/*!< \brief Runge-Kutta beta coefficients. */
    unsigned short nMGLevels;		/*!< \brief Number of multigrid levels (coarse levels). */
    unsigned short nCFL;			/*!< \brief Number of CFL, one for each multigrid level. */
    double
    CFLRedCoeff_Turb,		/*!< \brief CFL reduction coefficient on the LevelSet problem. */
    CFLRedCoeff_AdjFlow,	/*!< \brief CFL reduction coefficient for the adjoint problem. */
    CFLRedCoeff_AdjTurb,	/*!< \brief CFL reduction coefficient for the adjoint problem. */
    CFLFineGrid,		/*!< \brief CFL of the finest grid. */
    Max_DeltaTime,  		/*!< \brief Max delta time. */
    Unst_CFL;		/*!< \brief Unsteady CFL number. */
    bool AddIndNeighbor;			/*!< \brief Include indirect neighbor in the agglomeration process. */
    unsigned short nDV;		/*!< \brief Number of design variables. */
    unsigned short nFFDBox;		/*!< \brief Number of ffd boxes. */
    unsigned short nGridMovement;		/*!< \brief Number of grid movement types specified. */
    unsigned short nParamDV;		/*!< \brief Number of parameters of the design variable. */
    double **ParamDV;				/*!< \brief Parameters of the design variable. */
    double **CoordFFDBox;				/*!< \brief Coordinates of the FFD boxes. */
    unsigned short **DegreeFFDBox;	/*!< \brief Degree of the FFD boxes. */
    string *FFDTag;				/*!< \brief Parameters of the design variable. */
    string *TagFFDBox;				/*!< \brief Tag of the FFD box. */
    unsigned short GeometryMode;			/*!< \brief Gemoetry mode (analysis or gradient computation). */
    unsigned short MGCycle;			/*!< \brief Kind of multigrid cycle. */
    unsigned short FinestMesh;		/*!< \brief Finest mesh for the full multigrid approach. */
    unsigned short nMG_PreSmooth,                 /*!< \brief Number of MG pre-smooth parameters found in config file. */
    nMG_PostSmooth,                             /*!< \brief Number of MG post-smooth parameters found in config file. */
    nMG_CorrecSmooth;                           /*!< \brief Number of MG correct-smooth parameters found in config file. */
    unsigned short *MG_PreSmooth,	/*!< \brief Multigrid Pre smoothing. */
    *MG_PostSmooth,					/*!< \brief Multigrid Post smoothing. */
    *MG_CorrecSmooth;					/*!< \brief Multigrid Jacobi implicit smoothing of the correction. */
    unsigned short Kind_Solver,	/*!< \brief Kind of solver Euler, NS, Continuous adjoint, etc.  */
    Kind_FluidModel,			/*!< \brief Kind of the Fluid Model: Ideal or Van der Walls, ... . */
    Kind_ViscosityModel,			/*!< \brief Kind of the Viscosity Model*/
    Kind_ConductivityModel,			/*!< \brief Kind of the Thermal Conductivity Model*/
    Kind_FreeStreamOption,			/*!< \brief Kind of free stream option to choose if initializing with density or temperature  */
    Kind_InitOption,			/*!< \brief Kind of Init option to choose if initializing with Reynolds number or with thermodynamic conditions   */
    Kind_GasModel,				/*!< \brief Kind of the Gas Model. */
    *Kind_GridMovement,    /*!< \brief Kind of the unsteady mesh movement. */
    Kind_Gradient_Method,		/*!< \brief Numerical method for computation of spatial gradients. */
    Kind_Linear_Solver,		/*!< \brief Numerical solver for the implicit scheme. */
    Kind_Linear_Solver_Prec,		/*!< \brief Preconditioner of the linear solver. */
    Kind_AdjTurb_Linear_Solver,		/*!< \brief Numerical solver for the turbulent adjoint implicit scheme. */
    Kind_AdjTurb_Linear_Prec,		/*!< \brief Preconditioner of the turbulent adjoint linear solver. */
    Kind_SlopeLimit,				/*!< \brief Global slope limiter. */
    Kind_SlopeLimit_Flow,		/*!< \brief Slope limiter for flow equations.*/
    Kind_SlopeLimit_TNE2,		/*!< \brief Slope limiter for flow equations.*/
    Kind_SlopeLimit_AdjTNE2,		/*!< \brief Slope limiter for flow equations.*/
    Kind_SlopeLimit_Turb,		/*!< \brief Slope limiter for the turbulence equation.*/
    Kind_SlopeLimit_AdjLevelSet,		/*!< \brief Slope limiter for the adjoint level set equation.*/
    Kind_SlopeLimit_AdjTurb,	/*!< \brief Slope limiter for the adjoint turbulent equation.*/
    Kind_SlopeLimit_AdjFlow,	/*!< \brief Slope limiter for the adjoint equation.*/
    Kind_TimeNumScheme,			/*!< \brief Global explicit or implicit time integration. */
    Kind_TimeIntScheme_Flow,	/*!< \brief Time integration for the flow equations. */
    Kind_TimeIntScheme_AdjFlow,		/*!< \brief Time integration for the adjoint flow equations. */
    Kind_TimeIntScheme_TNE2,	/*!< \brief Time integration for the flow equations. */
    Kind_TimeIntScheme_AdjTNE2, /*!< \brief Time integration for the flow equations. */
    Kind_TimeIntScheme_LinFlow,		/*!< \brief Time integration for the linearized flow equations. */
    Kind_TimeIntScheme_Turb,	/*!< \brief Time integration for the turbulence model. */
    Kind_TimeIntScheme_AdjLevelSet,	/*!< \brief Time integration for the adjoint level set model. */
    Kind_TimeIntScheme_AdjTurb,	/*!< \brief Time integration for the adjoint turbulence model. */
    Kind_TimeIntScheme_Wave,	/*!< \brief Time integration for the wave equations. */
    Kind_TimeIntScheme_Heat,	/*!< \brief Time integration for the wave equations. */
    Kind_TimeIntScheme_Poisson,	/*!< \brief Time integration for the wave equations. */
    Kind_TimeIntScheme_FEA,	/*!< \brief Time integration for the FEA equations. */
    Kind_ConvNumScheme,			/*!< \brief Global definition of the convective term. */
    Kind_ConvNumScheme_Flow,	/*!< \brief Centered or upwind scheme for the flow equations. */
    Kind_ConvNumScheme_Heat,	/*!< \brief Centered or upwind scheme for the flow equations. */
    Kind_ConvNumScheme_TNE2,	/*!< \brief Centered or upwind scheme for the flow equations. */
    Kind_ConvNumScheme_AdjFlow,		/*!< \brief Centered or upwind scheme for the adjoint flow equations. */
    Kind_ConvNumScheme_AdjTNE2,		/*!< \brief Centered or upwind scheme for the adjoint TNE2 equations. */
    Kind_ConvNumScheme_LinFlow,		/*!< \brief Centered or upwind scheme for the linearized flow equations. */
    Kind_ConvNumScheme_Turb,	/*!< \brief Centered or upwind scheme for the turbulence model. */
    Kind_ConvNumScheme_AdjTurb,	/*!< \brief Centered or upwind scheme for the adjoint turbulence model. */
    Kind_ConvNumScheme_AdjLevelSet,	/*!< \brief Centered or upwind scheme for the adjoint level set equation. */
    Kind_ConvNumScheme_Template,	/*!< \brief Centered or upwind scheme for the level set equation. */
    Kind_Centered,				/*!< \brief Centered scheme. */
    Kind_Centered_Flow,			/*!< \brief Centered scheme for the flow equations. */
    Kind_Centered_TNE2,			/*!< \brief Centered scheme for the flow equations. */
    Kind_Centered_AdjLevelSet,			/*!< \brief Centered scheme for the level set equation. */
    Kind_Centered_AdjFlow,			/*!< \brief Centered scheme for the adjoint flow equations. */
    Kind_Centered_AdjTNE2,			/*!< \brief Centered scheme for the adjoint TNE2 equations. */
    Kind_Centered_LinFlow,			/*!< \brief Centered scheme for the linearized flow equations. */
    Kind_Centered_Turb,			/*!< \brief Centered scheme for the turbulence model. */
    Kind_Centered_AdjTurb,		/*!< \brief Centered scheme for the adjoint turbulence model. */
    Kind_Centered_Template,		/*!< \brief Centered scheme for the template model. */
    Kind_Upwind,				/*!< \brief Upwind scheme. */
    Kind_Upwind_Flow,			/*!< \brief Upwind scheme for the flow equations. */
    Kind_Upwind_TNE2,			/*!< \brief Upwind scheme for the flow equations. */
    Kind_Upwind_AdjLevelSet,			/*!< \brief Upwind scheme for the level set equations. */
    Kind_Upwind_AdjFlow,			/*!< \brief Upwind scheme for the adjoint flow equations. */
    Kind_Upwind_AdjTNE2,			/*!< \brief Upwind scheme for the adjoint TNE2 equations. */
    Kind_Upwind_LinFlow,			/*!< \brief Upwind scheme for the linearized flow equations. */
    Kind_Upwind_Turb,			/*!< \brief Upwind scheme for the turbulence model. */
    Kind_Upwind_AdjTurb,		/*!< \brief Upwind scheme for the adjoint turbulence model. */
    Kind_Upwind_Template,			/*!< \brief Upwind scheme for the template model. */
    SpatialOrder,		/*!< \brief Order of the spatial numerical integration.*/
    SpatialOrder_Flow,		/*!< \brief Order of the spatial numerical integration.*/
    SpatialOrder_Turb,		/*!< \brief Order of the spatial numerical integration.*/
    SpatialOrder_TNE2,		/*!< \brief Order of the spatial numerical integration.*/
    SpatialOrder_AdjFlow,		/*!< \brief Order of the spatial numerical integration.*/
    SpatialOrder_AdjTurb,		/*!< \brief Order of the spatial numerical integration.*/
    SpatialOrder_AdjTNE2,     /*!< \brief Order of the spatial numerical integration.*/
    SpatialOrder_AdjLevelSet;		/*!< \brief Order of the spatial numerical integration.*/
    
    unsigned short Kind_Turb_Model;			/*!< \brief Turbulent model definition. */
    string ML_Turb_Model_File;  /*!< \brief File containing turbulence model. */
    string ML_Turb_Model_FeatureSet; /*! <\brief What are the input and ouput features > */
    string *ML_Turb_Model_Extra; /*! <\brief Store for extra variables coming from ML turb model */
    unsigned short nML_Turb_Model_Extra; /*!<\brief number of strings there */
    
    unsigned short Kind_Trans_Model,			/*!< \brief Transition model definition. */
    Kind_Inlet, *Kind_Data_Riemann;           /*!< \brief Kind of inlet boundary treatment. */
    double Linear_Solver_Error;		/*!< \brief Min error of the linear solver for the implicit formulation. */
    unsigned long Linear_Solver_Iter;		/*!< \brief Max iterations of the linear solver for the implicit formulation. */
    unsigned long Linear_Solver_Restart_Frequency;   /*!< \brief Restart frequency of the linear solver for the implicit formulation. */
    double Roe_Kappa;		/*!< \brief Relaxation of the Roe scheme. */
    double Relaxation_Factor_Flow;		/*!< \brief Relaxation coefficient of the linear solver mean flow. */
    double Relaxation_Factor_Turb;		/*!< \brief Relaxation coefficient of the linear solver turbulence. */
    double Relaxation_Factor_AdjFlow;		/*!< \brief Relaxation coefficient of the linear solver adjoint mean flow. */
    double AdjTurb_Linear_Error;		/*!< \brief Min error of the turbulent adjoint linear solver for the implicit formulation. */
    double EntropyFix_Coeff;              /*!< \brief Entropy fix coefficient. */
    unsigned short AdjTurb_Linear_Iter;		/*!< \brief Min error of the turbulent adjoint linear solver for the implicit formulation. */
    double *Section_Location;                  /*!< \brief Airfoil section limit. */
    unsigned short nSections,      /*!< \brief Number of section cuts to make when calculating internal volume. */
    nVolSections;               /*!< \brief Number of sections. */
    double* Kappa_Flow,           /*!< \brief Numerical dissipation coefficients for the flow equations. */
    *Kappa_AdjFlow,                  /*!< \brief Numerical dissipation coefficients for the adjoint equations. */
    *Kappa_TNE2,             /*!< \brief Numerical dissipation coefficients for the TNE2 equations. */
    *Kappa_AdjTNE2,          /*!< \brief Numerical dissipation coefficients for the adjoint TNE2 equations. */
    *Kappa_LinFlow;                  /*!< \brief Numerical dissipation coefficients for the linearized equations. */
    double Kappa_1st_AdjFlow,	/*!< \brief JST 1st order dissipation coefficient for adjoint flow equations (coarse multigrid levels). */
    Kappa_2nd_AdjFlow,			/*!< \brief JST 2nd order dissipation coefficient for adjoint flow equations. */
    Kappa_4th_AdjFlow,			/*!< \brief JST 4th order dissipation coefficient for adjoint flow equations. */
    Kappa_1st_LinFlow,			/*!< \brief JST 1st order dissipation coefficient for linearized flow equations (coarse multigrid levels). */
    Kappa_4th_LinFlow,			/*!< \brief JST 4th order dissipation coefficient for linearized flow equations. */
    Kappa_1st_Flow,			/*!< \brief JST 1st order dissipation coefficient for flow equations (coarse multigrid levels). */
    Kappa_2nd_Flow,			/*!< \brief JST 2nd order dissipation coefficient for flow equations. */
    Kappa_4th_Flow,			/*!< \brief JST 4th order dissipation coefficient for flow equations. */
    Kappa_1st_TNE2,			/*!< \brief JST 1st order dissipation coefficient for flow equations (coarse multigrid levels). */
    Kappa_2nd_TNE2,			/*!< \brief JST 2nd order dissipation coefficient for flow equations. */
    Kappa_4th_TNE2,			/*!< \brief JST 4th order dissipation coefficient for flow equations. */
    Kappa_1st_AdjTNE2,			/*!< \brief JST 1st order dissipation coefficient for flow equations (coarse multigrid levels). */
    Kappa_2nd_AdjTNE2,			/*!< \brief JST 2nd order dissipation coefficient for flow equations. */
    Kappa_4th_AdjTNE2;			/*!< \brief JST 4th order dissipation coefficient for flow equations. */
    
    double Min_Beta_RoeTurkel,		/*!< \brief Minimum value of Beta for the Roe-Turkel low Mach preconditioner. */
    Max_Beta_RoeTurkel;		/*!< \brief Maximum value of Beta for the Roe-Turkel low Mach preconditioner. */
    unsigned long GridDef_Nonlinear_Iter, /*!< \brief Number of nonlinear increments for grid deformation. */
    GridDef_Linear_Iter; /*!< \brief Number of linear smoothing iterations for grid deformation. */
    unsigned short Deform_Stiffness_Type; /*!< \brief Type of element stiffness imposed for FEA mesh deformation. */
    bool Deform_Output;  /*!< \brief Print the residuals during mesh deformation to the console. */
    double Deform_Tol_Factor; /*!< Factor to multiply smallest volume for deform tolerance (0.001 default) */
    unsigned short Deform_Linear_Solver; /*!< Numerical method to deform the grid */
    unsigned short FFD_Continuity; /*!< Surface continuity at the intersection with the FFD */
    double Deform_ElasticityMod, Deform_PoissonRatio; /*!< young's modulus and poisson ratio for volume deformation stiffness model */
    bool Visualize_Deformation;	/*!< \brief Flag to visualize the deformation in MDC. */
    double Mach;		/*!< \brief Mach number. */
    double Reynolds;	/*!< \brief Reynolds number. */
    double Froude;	/*!< \brief Froude number. */
    double Length_Reynolds;	/*!< \brief Reynolds length (dimensional). */
    double AoA,			/*!< \brief Angle of attack (just external flow). */
    AoS;				/*!< \brief Angle of sideSlip (just external flow). */
    bool Fixed_CL_Mode;			/*!< \brief Activate fixed CL mode (external flow only). */
    double Target_CL;			/*!< \brief Specify a target CL instead of AoA (external flow only). */
    double Damp_Fixed_CL;			/*!< \brief Damping coefficient for fixed CL mode (external flow only). */
    unsigned long Iter_Fixed_CL;			/*!< \brief Iterations to re-evaluate the angle of attack (external flow only). */
    bool Update_AoA;			/*!< \brief Boolean flag for whether to update the AoA for fixed lift mode on a given iteration. */
    double ChargeCoeff;		/*!< \brief Charge coefficient (just for poisson problems). */
    double *U_FreeStreamND;			/*!< \brief Reference variables at the infinity, free stream values. */
    unsigned short Cauchy_Func_Flow,	/*!< \brief Function where to apply the convergence criteria in the flow problem. */
    Cauchy_Func_AdjFlow,				/*!< \brief Function where to apply the convergence criteria in the adjoint problem. */
    Cauchy_Func_LinFlow,				/*!< \brief Function where to apply the convergence criteria in the linearized problem. */
    Cauchy_Elems;						/*!< \brief Number of elements to evaluate. */
    unsigned short Residual_Func_Flow;	/*!< \brief Equation to apply residual convergence to. */
    unsigned long StartConv_Iter;	/*!< \brief Start convergence criteria at iteration. */
    double Cauchy_Eps;	/*!< \brief Epsilon used for the convergence. */
    unsigned long Wrt_Sol_Freq,	/*!< \brief Writing solution frequency. */
    Wrt_Sol_Freq_DualTime,	/*!< \brief Writing solution frequency for Dual Time. */
    Wrt_Con_Freq,				/*!< \brief Writing convergence history frequency. */
    Wrt_Con_Freq_DualTime;				/*!< \brief Writing convergence history frequency. */
    bool Wrt_Unsteady;  /*!< \brief Write unsteady data adding header and prefix. */
    bool LowFidelitySim;  /*!< \brief Compute a low fidelity simulation. */
    bool Restart,	/*!< \brief Restart solution (for direct, adjoint, and linearized problems).*/
    Restart_Flow;	/*!< \brief Restart flow solution for adjoint and linearized problems. */
    unsigned short nMarker_Monitoring,	/*!< \brief Number of markers to monitor. */
    nMarker_Designing,					/*!< \brief Number of markers for the objective function. */
    nMarker_GeoEval,					/*!< \brief Number of markers for the objective function. */
    nMarker_Plotting,					/*!< \brief Number of markers to plot. */
    nMarker_Moving,               /*!< \brief Number of markers in motion (DEFORMING, MOVING_WALL, or FLUID_STRUCTURE). */
    nMarker_DV;               /*!< \brief Number of markers affected by the design variables. */
    string *Marker_Monitoring,     /*!< \brief Markers to monitor. */
    *Marker_Designing,         /*!< \brief Markers to plot. */
    *Marker_GeoEval,         /*!< \brief Markers to plot. */
    *Marker_Plotting,          /*!< \brief Markers to plot. */
    *Marker_Moving,            /*!< \brief Markers in motion (DEFORMING, MOVING_WALL, or FLUID_STRUCTURE). */
    *Marker_DV;            /*!< \brief Markers affected by the design variables. */
    unsigned short  *Marker_All_Monitoring,        /*!< \brief Global index for monitoring using the grid information. */
    *Marker_All_GeoEval,       /*!< \brief Global index for geometrical evaluation. */
    *Marker_All_Plotting,        /*!< \brief Global index for plotting using the grid information. */
    *Marker_All_DV,          /*!< \brief Global index for design variable markers using the grid information. */
    *Marker_All_Moving,          /*!< \brief Global index for moving surfaces using the grid information. */
    *Marker_All_Designing,         /*!< \brief Global index for moving using the grid information. */
    *Marker_All_Out_1D,      /*!< \brief Global index for moving using 1D integrated output. */
    *Marker_CfgFile_Monitoring,     /*!< \brief Global index for monitoring using the config information. */
    *Marker_CfgFile_Designing,      /*!< \brief Global index for monitoring using the config information. */
    *Marker_CfgFile_GeoEval,      /*!< \brief Global index for monitoring using the config information. */
    *Marker_CfgFile_Plotting,     /*!< \brief Global index for plotting using the config information. */
    *Marker_CfgFile_Out_1D,      /*!< \brief Global index for plotting using the config information. */
    *Marker_CfgFile_Moving,       /*!< \brief Global index for moving surfaces using the config information. */
    *Marker_CfgFile_DV,       /*!< \brief Global index for design variable markers using the config information. */
    *Marker_CfgFile_PerBound;     /*!< \brief Global index for periodic boundaries using the config information. */
    string *PlaneTag;      /*!< \brief Global index for the plane adaptation (upper, lower). */
    double DualVol_Power;			/*!< \brief Power for the dual volume in the grid adaptation sensor. */
    unsigned short Analytical_Surface;	/*!< \brief Information about the analytical definition of the surface for grid adaptation. */
    unsigned short Axis_Orientation;	/*!< \brief Axis orientation. */
    unsigned short Mesh_FileFormat;	/*!< \brief Mesh input format. */
    unsigned short Output_FileFormat;	/*!< \brief Format of the output files. */
    bool CFL_Adapt;      /*!< \brief Adaptive CFL number. */
    double RefAreaCoeff,		/*!< \brief Reference area for coefficient computation. */
    RefElemLength,				/*!< \brief Reference element length for computing the slope limiting epsilon. */
    RefSharpEdges,				/*!< \brief Reference coefficient for detecting sharp edges. */
    RefLengthMoment,			/*!< \brief Reference length for moment computation. */
    *RefOriginMoment,           /*!< \brief Origin for moment computation. */
    *RefOriginMoment_X,      /*!< \brief X Origin for moment computation. */
    *RefOriginMoment_Y,      /*!< \brief Y Origin for moment computation. */
    *RefOriginMoment_Z,      /*!< \brief Z Origin for moment computation. */
    *CFL_AdaptParam,      /*!< \brief Information about the CFL ramp. */
    *CFL,
    DomainVolume;		/*!< \brief Volume of the computational grid. */
    unsigned short nRefOriginMoment_X,    /*!< \brief Number of X-coordinate moment computation origins. */
    nRefOriginMoment_Y,           /*!< \brief Number of Y-coordinate moment computation origins. */
    nRefOriginMoment_Z;           /*!< \brief Number of Z-coordinate moment computation origins. */
    string Mesh_FileName,			/*!< \brief Mesh input file. */
    Mesh_Out_FileName,				/*!< \brief Mesh output file. */
    Solution_FlowFileName,			/*!< \brief Flow solution input file. */
    Solution_LinFileName,			/*!< \brief Linearized flow solution input file. */
    Solution_AdjFileName,			/*!< \brief Adjoint solution input file for drag functional. */
    Flow_FileName,					/*!< \brief Flow variables output file. */
    Structure_FileName,					/*!< \brief Structure variables output file. */
    SurfStructure_FileName,					/*!< \brief Surface structure variables output file. */
    SurfWave_FileName,					/*!< \brief Surface structure variables output file. */
    SurfHeat_FileName,					/*!< \brief Surface structure variables output file. */
    Wave_FileName,					/*!< \brief Wave variables output file. */
    Heat_FileName,					/*!< \brief Heat variables output file. */
    AdjWave_FileName,					/*!< \brief Adjoint wave variables output file. */
    Residual_FileName,				/*!< \brief Residual variables output file. */
    Conv_FileName,					/*!< \brief Convergence history output file. */
    Breakdown_FileName,			    /*!< \brief Breakdown output file. */
    Restart_FlowFileName,			/*!< \brief Restart file for flow variables. */
    Restart_WaveFileName,			/*!< \brief Restart file for wave variables. */
    Restart_HeatFileName,			/*!< \brief Restart file for heat variables. */
    Restart_LinFileName,			/*!< \brief Restart file for linearized flow variables. */
    Restart_AdjFileName,			/*!< \brief Restart file for adjoint variables, drag functional. */
    Adj_FileName,					/*!< \brief Output file with the adjoint variables. */
    Lin_FileName,					/*!< \brief Output file with the linearized variables. */
    ObjFunc_Grad_FileName,			/*!< \brief Gradient of the objective function. */
    ObjFunc_Value_FileName,			/*!< \brief Objective function. */
    SurfFlowCoeff_FileName,			/*!< \brief Output file with the flow variables on the surface. */
    SurfAdjCoeff_FileName,			/*!< \brief Output file with the adjoint variables on the surface. */
    SurfLinCoeff_FileName,			/*!< \brief Output file with the linearized variables on the surface. */
    New_SU2_FileName;        		/*!< \brief Output SU2 mesh file converted from CGNS format. */
    unsigned short nSpecies, 		/*!< \brief No of species present in plasma */
    nReactions;									/*!< \brief Number of reactions in chemical model. */
    bool Low_MemoryOutput,      /*!< \brief Write a volume solution file */
    Wrt_Vol_Sol,                /*!< \brief Write a volume solution file */
    Wrt_Srf_Sol,                /*!< \brief Write a surface solution file */
    Wrt_Csv_Sol,                /*!< \brief Write a surface comma-separated values solution file */
    Wrt_Residuals,              /*!< \brief Write residuals to solution file */
    Wrt_Limiters,              /*!< \brief Write residuals to solution file */
    Wrt_SharpEdges,              /*!< \brief Write residuals to solution file */
    Wrt_Halo,                   /*!< \brief Write rind layers in solution files */
    Plot_Section_Forces,       /*!< \brief Write sectional forces for specified markers. */
    Wrt_1D_Output;                /*!< \brief Write average stagnation pressure specified markers. */
    unsigned short Console_Output_Verb;  /*!< \brief Level of verbosity for console output */
    double *ArrheniusCoefficient,					/*!< \brief Arrhenius reaction coefficient */
    *ArrheniusEta,								/*!< \brief Arrhenius reaction temperature exponent */
    *ArrheniusTheta,							/*!< \brief Arrhenius reaction characteristic temperature */
    *CharVibTemp,									/*!< \brief Characteristic vibrational temperature for e_vib */
    *RotationModes,				/*!< \brief Rotational modes of energy storage */
    *Ref_Temperature,   			/*!< \brief Reference temperature for thermodynamic relations */
    *Tcf_a,   /*!< \brief Rate controlling temperature exponent (fwd) */
    *Tcf_b,   /*!< \brief Rate controlling temperature exponent (fwd) */
    *Tcb_a,   /*!< \brief Rate controlling temperature exponent (bkw) */
    *Tcb_b,   /*!< \brief Rate controlling temperature exponent (bkw) */
    *Diss;                /*!< \brief Dissociation potential. */
    unsigned short nMass,                 /*!< \brief No of particle masses */
    nTemp;						/*!< \brief No of freestream temperatures specified */
    bool Inlet_Outlet_Defined; /*!< \brief  that inlet and outlet conditions are defined for each species*/
    double *Particle_Mass,         /*!< \brief Mass of all particles present in the plasma */
    *Molar_Mass,               /*!< \brief Molar mass of species in the plasma [kg/kmol] */
    Mixture_Molar_mass,       /*!< \brief Molar mass of the multi-species fluid [kg/kmol] */
    *Gas_Composition,          /*!< \brief Initial mass fractions of flow [dimensionless] */
    *Enthalpy_Formation,     /*!< \brief Enthalpy of formation */
    **Blottner,               /*!< \brief Blottner viscosity coefficients */
    *Species_Ref_Temperature,  /*!< \brief Reference Temperature for viscosity of all particles present in the plasma */
    *Species_Ref_Viscosity;    /*!< \brief Reference viscosity  of all particles present in the plasma */
    unsigned short *nElStates; /*!< \brief Number of electron states. */
    double **CharElTemp, /*!< \brief Characteristic temperature of electron states. */
    **degen; /*!< \brief Degeneracy of electron states. */
    double Gamma,			/*!< \brief Ratio of specific heats of the gas. */
    Bulk_Modulus,			/*!< \brief Value of the bulk modulus for incompressible flows. */
    ArtComp_Factor,			/*!< \brief Value of the artificial compresibility factor for incompressible flows. */
    Gas_Constant,     /*!< \brief Specific gas constant. */
    Gas_ConstantND,     /*!< \brief Non-dimensional specific gas constant. */
    Gas_Constant_Ref, /*!< \brief Reference specific gas constant. */
    Temperature_Critical,   /*!< \brief Critical Temperature for real fluid model.  */
    Pressure_Critical,   /*!< \brief Critical Pressure for real fluid model.  */
    Density_Critical,   /*!< \brief Critical Density for real fluid model.  */
    Acentric_Factor,   /*!< \brief Acentric Factor for real fluid model.  */
    Mu_ConstantND,   /*!< \brief Constant Viscosity for ConstantViscosity model.  */
    Kt_ConstantND,   /*!< \brief Constant Thermal Conductivity for ConstantConductivity model.  */
    Mu_RefND,   /*!< \brief reference viscosity for Sutherland model.  */
    Mu_Temperature_RefND,   /*!< \brief reference Temperature for Sutherland model.  */
    Mu_SND,   /*!< \brief reference S for Sutherland model.  */
    FreeSurface_Zero,	/*!< \brief Coordinate of the level set zero. */
    FreeSurface_Depth,	/*!< \brief Coordinate of the level set zero. */
    *Velocity_FreeStream,     /*!< \brief Total velocity of the fluid.  */
    Energy_FreeStream,     /*!< \brief Total energy of the fluid.  */
    ModVel_FreeStream,     /*!< \brief Total density of the fluid.  */
    ModVel_FreeStreamND,     /*!< \brief Total density of the fluid.  */
    Density_FreeStream,     /*!< \brief Total density of the fluid. */
    Viscosity_FreeStream,     /*!< \brief Total density of the fluid.  */
    Tke_FreeStream,     /*!< \brief Total turbulent kinetic energy of the fluid.  */
    Intermittency_FreeStream,     /*!< \brief Freestream intermittency (for sagt transition model) of the fluid.  */
    TurbulenceIntensity_FreeStream,     /*!< \brief Freestream turbulent intensity (for sagt transition model) of the fluid.  */
    Turb2LamViscRatio_FreeStream,          /*!< \brief Ratio of turbulent to laminar viscosity. */
    NuFactor_FreeStream,  /*!< \brief Ratio of turbulent to laminar viscosity. */
    NuFactor_Engine,  /*!< \brief Ratio of turbulent to laminar viscosity at the engine. */
    Pressure_FreeStream,     /*!< \brief Total pressure of the fluid. */
    Temperature_FreeStream,  /*!< \brief Total temperature of the fluid.  */
    Temperature_ve_FreeStream,  /*!< \brief Total vibrational-electronic temperature of the fluid.  */
    *MassFrac_FreeStream, /*!< \brief Mixture mass fractions of the fluid. */
    Prandtl_Lam,      /*!< \brief Laminar Prandtl number for the gas.  */
    Prandtl_Turb,     /*!< \brief Turbulent Prandtl number for the gas.  */
    Length_Ref,       /*!< \brief Reference length for non-dimensionalization. */
    Pressure_Ref,     /*!< \brief Reference pressure for non-dimensionalization.  */
    Temperature_Ref,  /*!< \brief Reference temperature for non-dimensionalization.*/
    Density_Ref,      /*!< \brief Reference density for non-dimensionalization.*/
    Velocity_Ref,     /*!< \brief Reference velocity for non-dimensionalization.*/
    Time_Ref,         /*!< \brief Reference time for non-dimensionalization. */
    Viscosity_Ref,    /*!< \brief Reference viscosity for non-dimensionalization. */
    Conductivity_Ref,    /*!< \brief Reference conductivity for non-dimensionalization. */
    Energy_Ref,    /*!< \brief Reference viscosity for non-dimensionalization. */
    Wall_Temperature,    /*!< \brief Temperature at an isotropic wall in Kelvin. */
    Omega_Ref,        /*!< \brief Reference angular velocity for non-dimensionalization. */
    Force_Ref,        /*!< \brief Reference body force for non-dimensionalization. */
    Pressure_FreeStreamND,     /*!< \brief Farfield pressure value (external flow). */
    Temperature_FreeStreamND,  /*!< \brief Farfield temperature value (external flow). */
    Density_FreeStreamND,      /*!< \brief Farfield density value (external flow). */
    Velocity_FreeStreamND[3],    /*!< \brief Farfield velocity values (external flow). */
    Energy_FreeStreamND,       /*!< \brief Farfield energy value (external flow). */
    Viscosity_FreeStreamND,    /*!< \brief Farfield viscosity value (external flow). */
    Tke_FreeStreamND,    /*!< \brief Farfield kinetic energy (external flow). */
    Omega_FreeStreamND, /*!< \brief Specific dissipation (external flow). */
    Omega_FreeStream, /*!< \brief Specific dissipation (external flow). */
    pnorm_heat;           /*!< \brief pnorm for heat-flux objective functions. */
    int ***Reactions;					/*!< \brief Reaction map for chemically reacting, multi-species flows. */
    double ***Omega00,        /*!< \brief Collision integrals (Omega(0,0)) */
    ***Omega11;                  /*!< \brief Collision integrals (Omega(1,1)) */
    double ElasticyMod,			/*!< \brief Young's modulus of elasticity. */
    PoissonRatio,						/*!< \brief Poisson's ratio. */
    MaterialDensity;								/*!< \brief Material density. */
    double Wave_Speed;			/*!< \brief Wave speed used in the wave solver. */
    double Thermal_Diffusivity;			/*!< \brief Thermal diffusivity used in the heat solver. */
    double Cyclic_Pitch,          /*!< \brief Cyclic pitch for rotorcraft simulations. */
    Collective_Pitch;             /*!< \brief Collective pitch for rotorcraft simulations. */
    string Motion_Filename;				/*!< \brief Arbitrary mesh motion input base filename. */
    double Mach_Motion;			/*!< \brief Mach number based on mesh velocity and freestream quantities. */
    double *Motion_Origin_X,    /*!< \brief X-coordinate of the mesh motion origin. */
    *Motion_Origin_Y,           /*!< \brief Y-coordinate of the mesh motion origin. */
    *Motion_Origin_Z,           /*!< \brief Z-coordinate of the mesh motion origin. */
    *Translation_Rate_X,           /*!< \brief Translational velocity of the mesh in the x-direction. */
    *Translation_Rate_Y,           /*!< \brief Translational velocity of the mesh in the y-direction. */
    *Translation_Rate_Z,           /*!< \brief Translational velocity of the mesh in the z-direction. */
    *Rotation_Rate_X,           /*!< \brief Angular velocity of the mesh about the x-axis. */
    *Rotation_Rate_Y,           /*!< \brief Angular velocity of the mesh about the y-axis. */
    *Rotation_Rate_Z,           /*!< \brief Angular velocity of the mesh about the z-axis. */
    *Pitching_Omega_X,           /*!< \brief Angular frequency of the mesh pitching about the x-axis. */
    *Pitching_Omega_Y,           /*!< \brief Angular frequency of the mesh pitching about the y-axis. */
    *Pitching_Omega_Z,           /*!< \brief Angular frequency of the mesh pitching about the z-axis. */
    *Pitching_Ampl_X,           /*!< \brief Pitching amplitude about the x-axis. */
    *Pitching_Ampl_Y,           /*!< \brief Pitching amplitude about the y-axis. */
    *Pitching_Ampl_Z,           /*!< \brief Pitching amplitude about the z-axis. */
    *Pitching_Phase_X,           /*!< \brief Pitching phase offset about the x-axis. */
    *Pitching_Phase_Y,           /*!< \brief Pitching phase offset about the y-axis. */
    *Pitching_Phase_Z,           /*!< \brief Pitching phase offset about the z-axis. */
    *Plunging_Omega_X,           /*!< \brief Angular frequency of the mesh plunging in the x-direction. */
    *Plunging_Omega_Y,           /*!< \brief Angular frequency of the mesh plunging in the y-direction. */
    *Plunging_Omega_Z,           /*!< \brief Angular frequency of the mesh plunging in the z-direction. */
    *Plunging_Ampl_X,           /*!< \brief Plunging amplitude in the x-direction. */
    *Plunging_Ampl_Y,           /*!< \brief Plunging amplitude in the y-direction. */
    *Plunging_Ampl_Z;           /*!< \brief Plunging amplitude in the z-direction. */
    unsigned short nMotion_Origin_X,    /*!< \brief Number of X-coordinate mesh motion origins. */
    nMotion_Origin_Y,           /*!< \brief Number of Y-coordinate mesh motion origins. */
    nMotion_Origin_Z,           /*!< \brief Number of Z-coordinate mesh motion origins. */
    nTranslation_Rate_X,           /*!< \brief Number of Translational x-velocities for mesh motion. */
    nTranslation_Rate_Y,           /*!< \brief Number of Translational y-velocities for mesh motion. */
    nTranslation_Rate_Z,           /*!< \brief Number of Translational z-velocities for mesh motion. */
    nRotation_Rate_X,           /*!< \brief Number of Angular velocities about the x-axis for mesh motion. */
    nRotation_Rate_Y,           /*!< \brief Number of Angular velocities about the y-axis for mesh motion. */
    nRotation_Rate_Z,           /*!< \brief Number of Angular velocities about the z-axis for mesh motion. */
    nPitching_Omega_X,           /*!< \brief Number of Angular frequencies about the x-axis for pitching. */
    nPitching_Omega_Y,           /*!< \brief Number of Angular frequencies about the y-axis for pitching. */
    nPitching_Omega_Z,           /*!< \brief Number of Angular frequencies about the z-axis for pitching. */
    nPitching_Ampl_X,           /*!< \brief Number of Pitching amplitudes about the x-axis. */
    nPitching_Ampl_Y,           /*!< \brief Number of Pitching amplitudes about the y-axis. */
    nPitching_Ampl_Z,           /*!< \brief Number of Pitching amplitudes about the z-axis. */
    nPitching_Phase_X,           /*!< \brief Number of Pitching phase offsets about the x-axis. */
    nPitching_Phase_Y,           /*!< \brief Number of Pitching phase offsets about the y-axis. */
    nPitching_Phase_Z,           /*!< \brief Number of Pitching phase offsets about the z-axis. */
    nPlunging_Omega_X,           /*!< \brief Number of Angular frequencies in the x-direction for plunging. */
    nPlunging_Omega_Y,           /*!< \brief Number of Angular frequencies in the y-direction for plunging. */
    nPlunging_Omega_Z,           /*!< \brief Number of Angular frequencies in the z-direction for plunging. */
    nPlunging_Ampl_X,           /*!< \brief Number of Plunging amplitudes in the x-direction. */
    nPlunging_Ampl_Y,           /*!< \brief Number of Plunging amplitudes in the y-direction. */
    nPlunging_Ampl_Z,           /*!< \brief Number of Plunging amplitudes in the z-direction. */
    nMoveMotion_Origin,         /*!< \brief Number of motion origins. */
    *MoveMotion_Origin;         /*!< \brief Keeps track if we should move moment origin. */
    vector<vector<vector<double> > > Aeroelastic_np1, /*!< \brief Aeroelastic solution at time level n+1. */
    Aeroelastic_n, /*!< \brief Aeroelastic solution at time level n. */
    Aeroelastic_n1; /*!< \brief Aeroelastic solution at time level n-1. */
    double FreqPlungeAeroelastic, /*!< \brief Plunging natural frequency for Aeroelastic. */
    FreqPitchAeroelastic; /*!< \brief Pitch natural frequency for Aeroelastic. */
    double *Aeroelastic_plunge, /*!< \brief Value of plunging coordinate at the end of an external iteration. */
    *Aeroelastic_pitch; /*!< \brief Value of pitching coordinate at the end of an external iteration. */
    unsigned short Gust_Type,	/*!< \brief Type of Gust. */
    Gust_Dir;   /*!< \brief Direction of the gust */
    double Gust_WaveLength,     /*!< \brief The gust wavelength. */
    Gust_Periods,              /*!< \brief Number of gust periods. */
    Gust_Ampl,                  /*!< \brief Gust amplitude. */
    Gust_Begin_Time,            /*!< \brief Time at which to begin the gust. */
    Gust_Begin_Loc;             /*!< \brief Location at which the gust begins. */
    long Visualize_CV; /*!< \brief Node number for the CV to be visualized */
    bool ExtraOutput;
    unsigned long Nonphys_Points, /*!< \brief Current number of non-physical points in the solution. */
    Nonphys_Reconstr;      /*!< \brief Current number of non-physical reconstructions for 2nd-order upwinding. */
    bool ParMETIS;      /*!< \brief Boolean for activating ParMETIS mode (while testing). */
    
    /*!< \brief param is a map from the option name (config file string) to a pointer to an option child class */
    //	map<string, CAnyOptionRef*> param;
    
    /*!<brief all_options is a map containing all of the options. This is used during config file parsing
     to track the options which have not been set (so the default values can be used). Without this map
     there would be no list of all the config file options. > */
    map<string, bool> all_options;
    
    /*<brief param is a map from the option name (config file string) to its decoder (the specific child
     class of COptionBase that turns the string into a value) */
    map<string, COptionBase*> option_map;
    
    
    // All of the addXxxOptions take in the name of the option, and a refernce to the field of that option
    // in the option structure. Depending on the specific type, it may take in a default value, and may
    // take in extra options. The addXxxOptions mostly follow the same pattern, so please see addDoubleOption
    // for detailed comments.
    //
    // List options are those that can be an unknown number of elements, and also take in a reference to
    // an integer. This integer will be populated with the number of elements of that type unmarshaled.
    //
    // Array options are those with a fixed number of elements.
    //
    // List and Array options should also be able to be specified with the string "NONE" indicating that there
    // are no elements. This allows the option to be present in a config file but left blank.
    
    /*!<\brief addDoubleOption creates a config file parser for an option with the given name whose
     value can be represented by a double.*/
    void addDoubleOption(const string name, double & option_field, double default_value) {
        // Check if the key is already in the map. If this fails, it is coder error
        // and not user error, so throw.
        assert(option_map.find(name) == option_map.end());
        
        // Add this option to the list of all the options
        all_options.insert(pair<string, bool>(name, true));
        
        // Create the parser for a double option with a reference to the option_field and the desired
        // default value. This will take the string in the config file, convert it to a double, and
        // place that double in the memory location specified by the reference.
        COptionBase* val = new COptionDouble(name, option_field, default_value);
        
        // Create an association between the option name ("CFL") and the parser generated above.
        // During configuration, the parsing script will get the option name, and use this map
        // to find how to parse that option.
        option_map.insert(pair<string, COptionBase *>(name, val));
    }
    
    void addStringOption(const string name, string & option_field, string default_value) {
        assert(option_map.find(name) == option_map.end());
        all_options.insert(pair<string, bool>(name, true));
        COptionBase* val = new COptionString(name, option_field, default_value);
        option_map.insert(pair<string, COptionBase *>(name, val));
    }
    
    void addIntegerOption(const string name, int & option_field, int default_value) {
        assert(option_map.find(name) == option_map.end());
        all_options.insert(pair<string, bool>(name, true));
        COptionBase* val = new COptionInt(name, option_field, default_value);
        option_map.insert(pair<string, COptionBase *>(name, val));
    }
    
    void addUnsignedLongOption(const string name, unsigned long & option_field, unsigned long default_value) {
        assert(option_map.find(name) == option_map.end());
        all_options.insert(pair<string, bool>(name, true));
        COptionBase* val = new COptionULong(name, option_field, default_value);
        option_map.insert(pair<string, COptionBase *>(name, val));
    }
    
    void addUnsignedShortOption(const string name, unsigned short & option_field, unsigned short default_value) {
        assert(option_map.find(name) == option_map.end());
        all_options.insert(pair<string, bool>(name, true));
        COptionBase* val = new COptionUShort(name, option_field, default_value);
        option_map.insert(pair<string, COptionBase *>(name, val));
    }
    
    void addLongOption(const string name, long & option_field, long default_value) {
        assert(option_map.find(name) == option_map.end());
        all_options.insert(pair<string, bool>(name, true));
        COptionBase* val = new COptionLong(name, option_field, default_value);
        option_map.insert(pair<string, COptionBase *>(name, val));
    }
    
    void addBoolOption(const string name, bool & option_field, bool default_value) {
        assert(option_map.find(name) == option_map.end());
        all_options.insert(pair<string, bool>(name, true));
        COptionBase* val = new COptionBool(name, option_field, default_value);
        option_map.insert(pair<string, COptionBase *>(name, val));
    }
    
    // enum types work differently than all of the others because there are a small number of valid
    // string entries for the type. One must also provide a list of all the valid strings of that type.
    template <class Tenum>
    void addEnumOption(const string name, unsigned short & option_field, const map<string, Tenum> & enum_map, Tenum default_value) {
        assert(option_map.find(name) == option_map.end());
        all_options.insert(pair<string, bool>(name, true));
        COptionBase* val = new COptionEnum<Tenum>(name, enum_map, option_field, default_value);
        option_map.insert(pair<string, COptionBase *>(name, val));
        return;
    }
    
    
    // input_size is the number of options read in from the config file
    template <class Tenum>
    void addEnumListOption(const string name, unsigned short & input_size, unsigned short * & option_field, const map<string, Tenum> & enum_map) {
        input_size = 0;
        assert(option_map.find(name) == option_map.end());
        all_options.insert(pair<string, bool>(name, true));
        COptionBase* val = new COptionEnumList<Tenum>(name, enum_map, option_field, input_size);
        option_map.insert( pair<string, COptionBase*>(name, val) );
    }
    
    void addDoubleArrayOption(const string name, const int size, double * & option_field, double * default_value) {
        
        double * def = new double [size];
        for (int i = 0; i < size; i++) {
            def[i] = default_value[i];
        }
        assert(option_map.find(name) == option_map.end());
        all_options.insert(pair<string, bool>(name, true));
        COptionBase* val = new COptionDoubleArray(name, size, option_field, def);
        option_map.insert(pair<string, COptionBase *>(name, val));
    }
    
    void addDoubleListOption(const string name, unsigned short & size, double * & option_field) {
        assert(option_map.find(name) == option_map.end());
        all_options.insert(pair<string, bool>(name, true));
        COptionBase* val = new COptionDoubleList(name, size, option_field);
        option_map.insert(pair<string, COptionBase *>(name, val));
    }
    
    void addUShortListOption(const string name, unsigned short & size, unsigned short * & option_field) {
        assert(option_map.find(name) == option_map.end());
        all_options.insert(pair<string, bool>(name, true));
        COptionBase* val = new COptionUShortList(name, size, option_field);
        option_map.insert(pair<string, COptionBase *>(name, val));
    }
    
    void addStringListOption(const string name, unsigned short & num_marker, string* & option_field) {
        assert(option_map.find(name) == option_map.end());
        all_options.insert(pair<string, bool>(name, true));
        COptionBase* val = new COptionStringList(name, num_marker, option_field);
        option_map.insert(pair<string, COptionBase *>(name, val));
    }
    
    void addConvectOption(const string name, unsigned short & space_field, unsigned short & centered_field, unsigned short & upwind_field) {
        assert(option_map.find(name) == option_map.end());
        all_options.insert(pair<string, bool>(name, true));
        COptionBase* val = new COptionConvect(name, space_field, centered_field, upwind_field);
        option_map.insert(pair<string, COptionBase *>(name, val));
    }
    
    void addMathProblemOption(const string name, bool & Adjoint, const bool & Adjoint_default,
                              bool & Linearized, const bool & Linearized_default,
                              bool & Restart_Flow, const bool & Restart_Flow_default) {
        assert(option_map.find(name) == option_map.end());
        all_options.insert(pair<string, bool>(name, true));
        COptionBase* val = new COptionMathProblem(name, Adjoint, Adjoint_default, Linearized, Linearized_default, Restart_Flow, Restart_Flow_default);
        option_map.insert(pair<string, COptionBase *>(name, val));
    }
    
    void addDVParamOption(const string name, unsigned short & nDV_field, double** & paramDV, string* & FFDTag,
                          unsigned short* & design_variable) {
        assert(option_map.find(name) == option_map.end());
        all_options.insert(pair<string, bool>(name, true));
        COptionBase* val = new COptionDVParam(name, nDV_field, paramDV, FFDTag, design_variable);
        option_map.insert(pair<string, COptionBase *>(name, val));
    }
    
    void addFFDDefOption(const string name, unsigned short & nFFD_field, double** & coordFFD, string* & FFDTag) {
        assert(option_map.find(name) == option_map.end());
        all_options.insert(pair<string, bool>(name, true));
        COptionBase* val = new COptionFFDDef(name, nFFD_field, coordFFD, FFDTag);
        option_map.insert(pair<string, COptionBase *>(name, val));
    }
    
    void addFFDDegreeOption(const string name, unsigned short & nFFD_field, unsigned short** & degreeFFD) {
        assert(option_map.find(name) == option_map.end());
        all_options.insert(pair<string, bool>(name, true));
        COptionBase* val = new COptionFFDDegree(name, nFFD_field, degreeFFD);
        option_map.insert(pair<string, COptionBase *>(name, val));
    }
    
    void addStringDoubleListOption(const string name, unsigned short & list_size, string * & string_field,
                                   double* & double_field) {
        assert(option_map.find(name) == option_map.end());
        all_options.insert(pair<string, bool>(name, true));
        COptionBase* val = new COptionStringDoubleList(name, list_size, string_field, double_field);
        option_map.insert(pair<string, COptionBase *>(name, val));
    }
    
    void addInletOption(const string name, unsigned short & nMarker_Inlet, string * & Marker_Inlet,
                        double* & Ttotal, double* & Ptotal, double** & FlowDir) {
        assert(option_map.find(name) == option_map.end());
        all_options.insert(pair<string, bool>(name, true));
        COptionBase* val = new COptionInlet(name, nMarker_Inlet, Marker_Inlet, Ttotal, Ptotal, FlowDir);
        option_map.insert(pair<string, COptionBase *>(name, val));
    }
    template <class Tenum>
    
    void addRiemannOption(const string name, unsigned short & nMarker_Riemann, string * & Marker_Riemann, unsigned short* & option_field, const map<string, Tenum> & enum_map,
                          double* & var1, double* & var2, double** & FlowDir) {
        assert(option_map.find(name) == option_map.end());
        all_options.insert(pair<string, bool>(name, true));
        COptionBase* val = new COptionRiemann<Tenum>(name, nMarker_Riemann, Marker_Riemann, option_field, enum_map, var1, var2, FlowDir);
        option_map.insert(pair<string, COptionBase *>(name, val));
    }
    
    void addExhaustOption(const string name, unsigned short & nMarker_Exhaust, string * & Marker_Exhaust,
                          double* & Ttotal, double* & Ptotal) {
        assert(option_map.find(name) == option_map.end());
        all_options.insert(pair<string, bool>(name, true));
        COptionBase* val = new COptionExhaust(name, nMarker_Exhaust, Marker_Exhaust, Ttotal, Ptotal);
        option_map.insert(pair<string, COptionBase *>(name, val));
    }
    
    void addBleedOption(const string name, unsigned short & nMarker_Bleed, string * & Marker_Bleed,
                        double* & MassFlow_Target, double* & Temp_Target) {
        assert(option_map.find(name) == option_map.end());
        all_options.insert(pair<string, bool>(name, true));
        COptionBase* val = new COptionBleed(name, nMarker_Bleed, Marker_Bleed, MassFlow_Target, Temp_Target);
        option_map.insert(pair<string, COptionBase *>(name, val));
    }
    
    void addPeriodicOption(const string & name, unsigned short & nMarker_PerBound,
                           string* & Marker_PerBound, string* & Marker_PerDonor,
                           double** & RotCenter, double** & RotAngles, double** & Translation) {
        assert(option_map.find(name) == option_map.end());
        all_options.insert(pair<string, bool>(name, true));
        COptionBase* val = new COptionPeriodic(name, nMarker_PerBound, Marker_PerBound, Marker_PerDonor, RotCenter, RotAngles, Translation);
        option_map.insert(pair<string, COptionBase *>(name, val));
    }
    
    void addActuatorDiskOption(const string & name, unsigned short & nMarker_ActDisk_Inlet, unsigned short & nMarker_ActDisk_Outlet,
                               string* & Marker_ActDisk_Inlet, string* & Marker_ActDisk_Outlet,
                               double** & ActDisk_Origin, double* & ActDisk_RootRadius, double* & ActDisk_TipRadius,
                               double* & ActDisk_PressJump, double* & ActDisk_TempJump, double* & ActDisk_Omega,
                               unsigned short* & ActDisk_Distribution) {
        assert(option_map.find(name) == option_map.end());
        all_options.insert(pair<string, bool>(name, true));
        COptionBase* val = new COptionActuatorDisk(name, nMarker_ActDisk_Inlet, nMarker_ActDisk_Outlet, Marker_ActDisk_Inlet, Marker_ActDisk_Outlet, ActDisk_Origin, ActDisk_RootRadius, ActDisk_TipRadius, ActDisk_PressJump, ActDisk_TempJump, ActDisk_Omega, ActDisk_Distribution);
        option_map.insert(pair<string, COptionBase *>(name, val));
    }
    
    void addPythonOption(const string name) {
        assert(option_map.find(name) == option_map.end());
        all_options.insert(pair<string, bool>(name, true));
        COptionBase* val = new COptionPython(name);
        option_map.insert(pair<string, COptionBase *>(name, val));
    }
    
public:
    
    vector<string> fields; /*!< \brief Tags for the different fields in a restart file. */
    
    /*!
     * \brief Constructor of the class which reads the input file.
     */
    CConfig(char case_filename[MAX_STRING_SIZE], unsigned short val_software, unsigned short val_iZone, unsigned short val_nZone, unsigned short val_nDim, unsigned short verb_level);
    
    /*!
     * \brief Constructor of the class which reads the input file.
     */
    CConfig(char case_filename[MAX_STRING_SIZE], unsigned short val_software);
    
    /*!
     * \brief Constructor of the class which reads the input file.
     */
    CConfig(char case_filename[MAX_STRING_SIZE], CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CConfig(void);
    
    /*!
     * \brief Initializes pointers to null
     */
    void SetPointersNull(void);
    
    /*!
     * \brief breaks an input line from the config file into a set of tokens
     * \param[in] str - the input line string
     * \param[out] option_name - the name of the option found at the beginning of the line
     * \param[out] option_value - the tokens found after the "=" sign on the line
     * \returns false if the line is empty or a commment, true otherwise
     */
    bool TokenizeString(string & str, string & option_name,
                        vector<string> & option_value);
    
    /*!
     * \brief Get reference origin for moment computation.
     * \param[in] val_marker - the marker we are monitoring.
     * \return Reference origin (in cartesians coordinates) for moment computation.
     */
    double *GetRefOriginMoment(unsigned short val_marker);
    
    /*!
     * \brief Get reference origin x-coordinate for moment computation.
     * \param[in] val_marker - the marker we are monitoring.
     * \return Reference origin x-coordinate (in cartesians coordinates) for moment computation.
     */
    double GetRefOriginMoment_X(unsigned short val_marker);
    
    /*!
     * \brief Get reference origin y-coordinate for moment computation.
     * \param[in] val_marker - the marker we are monitoring.
     * \return Reference origin y-coordinate (in cartesians coordinates) for moment computation.
     */
    double GetRefOriginMoment_Y(unsigned short val_marker);
    
    /*!
     * \brief Get reference origin z-coordinate for moment computation.
     * \param[in] val_marker - the marker we are monitoring.
     * \return Reference origin z-coordinate (in cartesians coordinates) for moment computation.
     */
    double GetRefOriginMoment_Z(unsigned short val_marker);
    
    /*!
     * \brief Set reference origin x-coordinate for moment computation.
     * \param[in] val_marker - the marker we are monitoring.
     * \param[in] val_origin - New x-coordinate of the mesh motion origin.
     */
    void SetRefOriginMoment_X(unsigned short val_marker, double val_origin);
    
    /*!
     * \brief Set reference origin y-coordinate for moment computation.
     * \param[in] val_marker - the marker we are monitoring.
     * \param[in] val_origin - New y-coordinate of the mesh motion origin.
     */
    void SetRefOriginMoment_Y(unsigned short val_marker, double val_origin);
    
    /*!
     * \brief Set reference origin z-coordinate for moment computation.
     * \param[in] val_marker - the marker we are monitoring.
     * \param[in] val_origin - New z-coordinate of the mesh motion origin.
     */
    void SetRefOriginMoment_Z(unsigned short val_marker, double val_origin);
    
    /*!
     * \brief Get index of the upper and lower horizontal plane.
     * \param[in] index - 0 means upper surface, and 1 means lower surface.
     * \return Index of the upper and lower surface.
     */
    string GetPlaneTag(unsigned short index);
    
    /*!
     * \brief Get the integration limits for the equivalent area computation.
     * \param[in] index - 0 means x_min, and 1 means x_max.
     * \return Integration limits for the equivalent area computation.
     */
    double GetEA_IntLimit(unsigned short index);
    
    /*!
     * \brief Get the integration limits for the equivalent area computation.
     * \param[in] index - 0 means x_min, and 1 means x_max.
     * \return Integration limits for the equivalent area computation.
     */
    double GetEA_ScaleFactor(void);
    
    /*!
     * \brief Get the limit value for the adjoint variables.
     * \return Limit value for the adjoint variables.
     */
    double GetAdjointLimit(void);
    
    /*!
     * \brief Get the the coordinates where of the box where the grid is going to be deformed.
     * \return Coordinates where of the box where the grid is going to be deformed.
     */
    double *GetHold_GridFixed_Coord(void);
    
    /*!
     * \brief Get the the coordinates where of the box where a subsonic region is imposed.
     * \return Coordinates where of the box where the grid is going to be a subsonic region.
     */
    double *GetSubsonic_Engine_Box(void);
    
    /*!
     * \brief Get the power of the dual volume in the grid adaptation sensor.
     * \return Power of the dual volume in the grid adaptation sensor.
     */
    double GetDualVol_Power(void);
    
    /*!
     * \brief Get Information about if there is an analytical definition of the surface for doing the
     *        grid adaptation.
     * \return Definition of the surfaces. NONE implies that there isn't any analytical definition
     *         and it will use and interpolation.
     */
    unsigned short GetAnalytical_Surface(void);
    
    /*!
     * \brief Get Information about if there is an analytical definition of the surface for doing the
     *        grid adaptation.
     * \return Definition of the surfaces. NONE implies that there isn't any analytical definition
     *         and it will use and interpolation.
     */
    unsigned short GetAxis_Orientation(void);
    
    /*!
     * \brief Get the ratio of density for a free surface problem.
     * \return Ratio of density for a free surface problem.
     */
    double GetRatioDensity(void);
    
    /*!
     * \brief Get the ratio of viscosity for a free surface problem.
     * \return Ratio of viscosity for a free surface problem.
     */
    double GetRatioViscosity(void);
    
    /*!
     * \brief Get the thickness of the interfase for a free surface problem.
     * \return Thickness of the interfase for a free surface problem.
     */
    double GetFreeSurface_Thickness(void);
    
    /*!
     * \brief Get the damping of the free surface for a free surface problem.
     * \return Damping of the interfase for a free surface problem.
     */
    double GetFreeSurface_Damping_Coeff(void);
    
    /*!
     * \brief Get the damping of the free surface for a free surface problem.
     * \return Damping of the interfase for a free surface problem.
     */
    double GetFreeSurface_Damping_Length(void);
    
    /*!
     * \brief Get the outlet position of the free surface for a free surface problem.
     * \return Outlet position of the interfase for a free surface problem.
     */
    double GetFreeSurface_Outlet(void);
    
    /*!
     * \brief Creates a tecplot file to visualize the partition made by the DDC software.
     * \return <code>TRUE</code> if the partition is going to be plotted; otherwise <code>FALSE</code>.
     */
    bool GetExtraOutput(void);
    
    /*!
     * \brief Get the value of the Mach number (velocity divided by speed of sound).
     * \return Value of the Mach number.
     */
    double GetMach(void);
    
    /*!
     * \brief Get the value of the Gamma of fluid (ratio of specific heats).
     * \return Value of the constant: Gamma
     */
    double GetGamma(void);
    
    /*!
     * \brief Get the value of the Gamma of fluid (ratio of specific heats) for a particular species.
     * \param[in] - val_Species: Index of desired species specific heat ratio.
     * \return Value of the constant: Species_Gamma[iSpecies]
     */
    //double GetSpecies_Gamma(unsigned short val_Species);
    
    /*!
     * \brief Get the value of the charge number for a particular species (1 for ions, -1 for electrons, 0 for neutral).
     * \param[in] - val_Species: Index of desired species charge number.
     * \return Value of the constant: Charge_Number[val_Species]
     */
    //int GetCharge_Number(unsigned short val_Species);
    
    /*!
     * \brief Get the values of the CFL adapation.
     * \return Value of CFL adapation
     */
    double GetCFL_AdaptParam(unsigned short val_index);
    
    /*!
     * \brief Get the values of the CFL adapation.
     * \return Value of CFL adapation
     */
    bool GetCFL_Adapt(void);
    
    /*!
     * \brief Get the value of the limits for the sections.
     * \return Value of the limits for the sections.
     */
    double GetSection_Location(unsigned short val_var);
    
    /*!
     * \brief Get the array that maps chemical consituents to each chemical reaction.
     * \return Memory location of the triple pointer to the 3-D reaction map array.
     */
    int ***GetReaction_Map(void);
    
    /*!
     * \brief Get the array containing the curve fit coefficients for the Omega(0,0) collision integrals.
     * \return Memory location of the triple pointer to the 3-D collision integral array.
     */
    double ***GetCollisionIntegral00(void);
    
    /*!
     * \brief Get the array containing the curve fit coefficients for the Omega(1,1) collision integrals.
     * \return Memory location of the triple pointer to the 3-D collision integral array.
     */
    double ***GetCollisionIntegral11(void);
    
    /*!
     * \brief Get the value of the bulk modulus.
     * \return Value of the bulk modulus.
     */
    double GetBulk_Modulus(void);
    
    /*!
     * \brief Get the value of the Gamma of fluid (ratio of specific heats) for monatomic species.
     * \return Value of the constant: GammaMonatomic
     */
    //double GetGammaMonatomic(void);
    
    /*!
     * \brief Get the value of the Gamma of fluid (ratio of specific heats) for diatomic species.
     * \return Value of the constant: Gamma
     */
    //double GetGammaDiatomic(void);
    
    /*!
     * \brief Get the artificial compresibility factor.
     * \return Value of the artificial compresibility factor.
     */
    double GetArtComp_Factor(void);
    
    /*!
     * \brief Get the Level set zero for free surface .
     * \return Value of the level set zero coordinate
     */
    double GetFreeSurface_Zero(void);
    
    /*!
     * \brief Get the Level set zero for free surface .
     * \return Value of the level set zero coordinate
     */
    double GetFreeSurface_Depth(void);
    
    /*!
     * \brief Get the value of specific gas constant.
     * \return Value of the constant: Gamma
     */
    double GetGas_Constant(void);
    
    /*!
     * \brief Get the value of specific gas constant.
     * \return Value of the constant: Gamma
     */
    double GetGas_ConstantND(void);
    
    /*!
     * \brief Get the value of specific gas constant for a particular species.
     * \param[in] val_Species - Index of desired species gas constant.
     * \return Value of the constant: R
     */
    //double GetSpecies_Gas_Constant(unsigned short val_Species);
    
    /*!
     * \brief Get the coefficients of the Blottner viscosity model
     * \param[in] val_Species - Index of the species
     * \param[in] val_Coeff - Index of the coefficient (As, Bs, Cs)
     * \return Value of the Blottner coefficient
     */
    double GetBlottnerCoeff(unsigned short val_Species, unsigned short val_Coeff);
    
    /*!
     * \brief Get the p-norm for heat-flux objective functions (adjoint problem).
     * \return Value of the heat flux p-norm
     */
    double GetPnormHeat(void);
    
    /*!
     * \brief Get the value of wall temperature.
     * \return Value of the constant: Temperature
     */
    double GetWallTemperature(void);
    
    /*!
     * \brief Get the reference value for the specific gas constant.
     * \return Reference value for the specific gas constant.
     */
    double GetGas_Constant_Ref(void);
    
    /*!
     * \brief Get the value of the frestream temperature.
     * \return Freestream temperature.
     */
    double GetTemperature_FreeStream(void);
    
    /*!
     * \brief Get the value of the frestream temperature.
     * \return Freestream temperature.
     */
    double GetEnergy_FreeStream(void);
    
    /*!
     * \brief Get the value of the frestream temperature.
     * \return Freestream temperature.
     */
    double GetViscosity_FreeStream(void);
    
    /*!
     * \brief Get the value of the frestream temperature.
     * \return Freestream temperature.
     */
    double GetDensity_FreeStream(void);
    
    /*!
     * \brief Get the value of the frestream temperature.
     * \return Freestream temperature.
     */
    double GetModVel_FreeStream(void);
    
    /*!
     * \brief Get the value of the frestream temperature.
     * \return Freestream temperature.
     */
    double GetModVel_FreeStreamND(void);
    
    /*!
     * \brief Get the value of the frestream vibrational-electronic temperature.
     * \return Freestream temperature.
     */
    double GetTemperature_ve_FreeStream(void);
    
    /*!
     * \brief Get the value of the laminar Prandtl number.
     * \return Laminar Prandtl number.
     */
    double GetPrandtl_Lam(void);
    
    /*!
     * \brief Get the value of the turbulent Prandtl number.
     * \return Turbulent Prandtl number.
     */
    double GetPrandtl_Turb(void);
    
    /*!
     * \brief Get the value of the reference length for non-dimensionalization.
     *        This value should always be 1 internally, and is not user-specified.
     * \return Reference length for non-dimensionalization.
     */
    double GetLength_Ref(void);
    
    /*!
     * \brief Get the value of the reference pressure for non-dimensionalization.
     * \return Reference pressure for non-dimensionalization.
     */
    double GetPressure_Ref(void);
    
    /*!
     * \brief Get the value of the reference pressure for non-dimensionalization.
     * \return Reference pressure for non-dimensionalization.
     */
    double GetEnergy_Ref(void);
    
    /*!
     * \brief Get the value of the reference temperature for non-dimensionalization.
     * \return Reference temperature for non-dimensionalization.
     */
    double GetTemperature_Ref(void);
    
    /*!
     * \brief Get the value of the reference density for non-dimensionalization.
     * \return Reference density for non-dimensionalization.
     */
    double GetDensity_Ref(void);
    
    /*!
     * \brief Get the value of the reference velocity for non-dimensionalization.
     * \return Reference velocity for non-dimensionalization.
     */
    double GetVelocity_Ref(void);
    
    /*!
     * \brief Get the value of the reference time for non-dimensionalization.
     * \return Reference time for non-dimensionalization.
     */
    double GetTime_Ref(void);
    
    /*!
     * \brief Get the value of the reference viscosity for non-dimensionalization.
     * \return Reference viscosity for non-dimensionalization.
     */
    double GetViscosity_Ref(void);
    
    /*!
     * \brief Get the value of the reference conductivity for non-dimensionalization.
     * \return Reference conductivity for non-dimensionalization.
     */
    double GetConductivity_Ref(void);
    
    /*!
     * \brief Get the value of the reference angular velocity for non-dimensionalization.
     * \return Reference angular velocity for non-dimensionalization.
     */
    double GetOmega_Ref(void);
    
    /*!
     * \brief Get the value of the reference force for non-dimensionalization.
     * \return Reference force for non-dimensionalization.
     */
    double GetForce_Ref(void);
    
    /*!
     * \brief Get the value of the non-dimensionalized freestream pressure.
     * \return Non-dimensionalized freestream pressure.
     */
    double GetPressure_FreeStream(void);
    
    /*!
     * \brief Get the value of the non-dimensionalized freestream pressure.
     * \return Non-dimensionalized freestream pressure.
     */
    double GetPressure_FreeStreamND(void);
    
    /*!
     * \brief Get the vector of the dimensionalized freestream velocity.
     * \return Dimensionalized freestream velocity vector.
     */
    double* GetVelocity_FreeStream(void);
    
    /*!
     * \brief Get the value of the non-dimensionalized freestream temperature.
     * \return Non-dimensionalized freestream temperature.
     */
    double GetTemperature_FreeStreamND(void);
    
    /*!
     * \brief Get the value of the non-dimensionalized freestream density.
     * \return Non-dimensionalized freestream density.
     */
    double GetDensity_FreeStreamND(void);
    
    /*!
     * \brief Get the vector of the non-dimensionalized freestream velocity.
     * \return Non-dimensionalized freestream velocity vector.
     */
    double* GetVelocity_FreeStreamND(void);
    
    /*!
     * \brief Get the value of the non-dimensionalized freestream energy.
     * \return Non-dimensionalized freestream energy.
     */
    double GetEnergy_FreeStreamND(void);
    
    /*!
     * \brief Get the value of the non-dimensionalized freestream viscosity.
     * \return Non-dimensionalized freestream viscosity.
     */
    double GetViscosity_FreeStreamND(void);
    
    /*!
     * \brief Get the value of the non-dimensionalized freestream viscosity.
     * \return Non-dimensionalized freestream viscosity.
     */
    double GetTke_FreeStreamND(void);
    
    /*!
     * \brief Get the value of the non-dimensionalized freestream viscosity.
     * \return Non-dimensionalized freestream viscosity.
     */
    double GetOmega_FreeStreamND(void);
    
    /*!
     * \brief Get the value of the non-dimensionalized freestream viscosity.
     * \return Non-dimensionalized freestream viscosity.
     */
    double GetTke_FreeStream(void);
    
    /*!
     * \brief Get the value of the non-dimensionalized freestream viscosity.
     * \return Non-dimensionalized freestream viscosity.
     */
    double GetOmega_FreeStream(void);
    
    /*!
     * \brief Get the value of the non-dimensionalized freestream intermittency.
     * \return Non-dimensionalized freestream intermittency.
     */
    double GetIntermittency_FreeStream(void);
    
    /*!
     * \brief Get the value of the non-dimensionalized freestream turbulence intensity.
     * \return Non-dimensionalized freestream intensity.
     */
    double GetTurbulenceIntensity_FreeStream(void);
    
    /*!
     * \brief Get the value of the non-dimensionalized freestream turbulence intensity.
     * \return Non-dimensionalized freestream intensity.
     */
    double GetNuFactor_FreeStream(void);
    
    /*!
     * \brief Get the value of the non-dimensionalized engine turbulence intensity.
     * \return Non-dimensionalized engine intensity.
     */
    double GetNuFactor_Engine(void);
    
    /*!
     * \brief Get the value of the turbulent to laminar viscosity ratio.
     * \return Ratio of turbulent to laminar viscosity ratio.
     */
    double GetTurb2LamViscRatio_FreeStream(void);
    
    /*!
     * \brief Get the vector of free stream mass fraction values.
     * \return Ratio of species mass to mixture mass.
     */
    double* GetMassFrac_FreeStream(void);
    
    /*!
     * \brief Get the value of the Reynolds length.
     * \return Reynolds length.
     */
    double GetLength_Reynolds(void);
    
    /*!
     * \brief Get the start up iterations using the fine grid, this works only for multigrid problems.
     * \return Start up iterations using the fine grid.
     */
    unsigned short GetnStartUpIter(void);
    
    /*!
     * \brief Get the reference area for non dimensional coefficient computation. If the value from the
     *        is 0 then, the code will compute the reference area using the projection of the shape into
     *        the z plane (3D) or the x plane (2D).
     * \return Value of the reference area for coefficient computation.
     */
    double GetRefAreaCoeff(void);
    
    /*!
     * \brief Get the wave speed.
     * \return Value of the wave speed.
     */
    double GetWaveSpeed(void);
    
    /*!
     * \brief Get the wave speed.
     * \return Value of the wave speed.
     */
    double GetThermalDiffusivity(void);
    
    /*!
     * \brief Get the Young's modulus of elasticity.
     * \return Value of the Young's modulus of elasticity.
     */
    double GetElasticyMod(void);
    
    /*!
     * \brief Get the Poisson's ratio.
     * \return Value of the Poisson's ratio.
     */
    double GetPoissonRatio(void);
    
    /*!
     * \brief Get the Material Density.
     * \return Value of the Material Density.
     */
    double GetMaterialDensity(void);
    
    /*!
     * \brief Get the reference length for computing moment (the default value is 1).
     * \return Reference length for moment computation.
     */
    double GetRefLengthMoment(void);
    
    /*!
     * \brief Get the reference element length for computing the slope limiting epsilon.
     * \return Reference element length for slope limiting epsilon.
     */
    double GetRefElemLength(void);
    
    /*!
     * \brief Get the reference coefficient for detecting sharp edges.
     * \return Reference coefficient for detecting sharp edges.
     */
    double GetRefSharpEdges(void);
    
    /*!
     * \brief Get the volume of the whole domain using the fine grid, this value is common for all the grids
     *        in the multigrid method.
     * \return Volume of the whole domain.
     */
    double GetDomainVolume(void);
    
    /*!
     * \brief In case the <i>RefAreaCoeff</i> is equal to 0 then, it is necessary to compute a reference area,
     *        with this function we set the value of the reference area.
     * \param[in] val_area - Value of the reference area for non dimensional coefficient computation.
     */
    void SetRefAreaCoeff(double val_area);
    
    /*!
     * \brief Set the value of the domain volume computed on the finest grid.
     * \note This volume do not include the volume of the body that is being simulated.
     * \param[in] val_volume - Value of the domain volume computed on the finest grid.
     */
    void SetDomainVolume(double val_volume);
    
    /*!
     * \brief Set the finest mesh in a multigrid strategy.
     * \note If we are using a Full Multigrid Strategy or a start up with finest grid, it is necessary
     *       to change several times the finest grid.
     * \param[in] val_finestmesh - Index of the finest grid.
     */
    void SetFinestMesh(unsigned short val_finestmesh);
    
    /*!
     * \brief Set the kind of time integration scheme.
     * \note If we are solving different equations it will be necessary to change several
     *       times the kind of time integration, to choose the right scheme.
     * \param[in] val_kind_timeintscheme - Kind of time integration scheme.
     */
    void SetKind_TimeIntScheme(unsigned short val_kind_timeintscheme);
    
    /*!
     * \brief Set the parameters of the convective numerical scheme.
     * \note The parameters will change because we are solving different kind of equations.
     * \param[in] val_kind_convnumscheme - Center or upwind scheme.
     * \param[in] val_kind_centered - If centered scheme, kind of centered scheme (JST, etc.).
     * \param[in] val_kind_upwind - If upwind scheme, kind of upwind scheme (Roe, etc.).
     * \param[in] val_kind_slopelimit - If upwind scheme, kind of slope limit.
     */
    void SetKind_ConvNumScheme(unsigned short val_kind_convnumscheme, unsigned short val_kind_centered,
                               unsigned short val_kind_upwind, unsigned short val_kind_slopelimit, unsigned short val_order_spatial_int);
    
    /*!
     * \brief Get the value of limiter coefficient.
     * \return Value of the limiter coefficient.
     */
    double GetLimiterCoeff(void);
    
    /*!
     * \brief Freeze the value of the limiter after a number of iterations.
     * \return Number of iterations.
     */
    unsigned long GetLimiterIter(void);
    
    /*!
     * \brief Get the value of sharp edge limiter.
     * \return Value of the sharp edge limiter coefficient.
     */
    double GetSharpEdgesCoeff(void);
    
    /*!
     * \brief Get the Reynolds number. Dimensionless number that gives a measure of the ratio of inertial forces
     *        to viscous forces and consequently quantifies the relative importance of these two types of forces
     *        for given flow condition.
     * \return Value of the Reynolds number.
     */
    double GetReynolds(void);
    
    /*!
     * \brief Get the Froude number for free surface problems.
     * \return Value of the Froude number.
     */
    double GetFroude(void);
    
    /*!
     * \brief Set the Froude number for free surface problems.
     * \return Value of the Froude number.
     */
    void SetFroude(double val_froude);
    
    /*!
     * \brief Set the Froude number for free surface problems.
     * \return Value of the Froude number.
     */
    void SetMach(double val_mach);
    
    /*!
     * \brief Set the Froude number for free surface problems.
     * \return Value of the Froude number.
     */
    void SetReynolds(double val_reynolds);
    
    /*!
     * \brief Set the Froude number for free surface problems.
     * \return Value of the Froude number.
     */
    void SetLength_Ref(double val_length_ref);
    
    /*!
     * \brief Set the Froude number for free surface problems.
     * \return Value of the Froude number.
     */
    void SetVelocity_Ref(double val_velocity_ref);
    
    /*!
     * \brief Set the Froude number for free surface problems.
     * \return Value of the Froude number.
     */
    //void SetPressure_Ref(double val_pressure_ref);
    
    /*!
     * \brief Set the Froude number for free surface problems.
     * \return Value of the Froude number.
     */
    void SetDensity_Ref(double val_density_ref);
    
    /*!
     * \brief Set the reference temperature.
     * \return Value of the Froude number.
     */
    void SetTemperature_Ref(double val_temperature_ref);
    
    /*!
     * \brief Set the Froude number for free surface problems.
     * \return Value of the Froude number.
     */
    void SetTime_Ref(double val_time_ref);
    
    /*!
     * \brief Set the Froude number for free surface problems.
     * \return Value of the Froude number.
     */
    void SetEnergy_Ref(double val_energy_ref);
    
    /*!
     * \brief Set the Froude number for free surface problems.
     * \return Value of the Froude number.
     */
    void SetOmega_Ref(double val_omega_ref);
    
    /*!
     * \brief Set the Froude number for free surface problems.
     * \return Value of the Froude number.
     */
    void SetForce_Ref(double val_force_ref);
    
    /*!
     * \brief Set the Froude number for free surface problems.
     * \return Value of the Froude number.
     */
    void SetGas_Constant_Ref(double val_gas_constant_ref);
    
    /*!
     * \brief Set the Froude number for free surface problems.
     * \return Value of the Froude number.
     */
    void SetGas_Constant(double val_gas_constant);
    
    /*!
     * \brief Set the Froude number for free surface problems.
     * \return Value of the Froude number.
     */
    void SetViscosity_Ref(double val_viscosity_ref);
    
    /*!
     * \brief Set the Froude number for free surface problems.
     * \return Value of the Froude number.
     */
    void SetConductivity_Ref(double val_conductivity_ref);
    
    /*!
     * \brief Set the Froude number for free surface problems.
     * \return Value of the Froude number.
     */
    void SetPressure_FreeStreamND(double val_pressure_freestreamnd);
    
    /*!
     * \brief Set the Froude number for free surface problems.
     * \return Value of the Froude number.
     */
    void SetPressure_FreeStream(double val_pressure_freestream);
    
    /*!
     * \brief Set the Froude number for free surface problems.
     * \return Value of the Froude number.
     */
    void SetDensity_FreeStreamND(double val_density_freestreamnd);
    
    /*!
     * \brief Set the Froude number for free surface problems.
     * \return Value of the Froude number.
     */
    void SetDensity_FreeStream(double val_density_freestream);
    
    /*!
     * \brief Set the Froude number for free surface problems.
     * \return Value of the Froude number.
     */
    void SetViscosity_FreeStream(double val_viscosity_freestream);
    
    /*!
     * \brief Set the Froude number for free surface problems.
     * \return Value of the Froude number.
     */
    void SetModVel_FreeStream(double val_modvel_freestream);
    
    /*!
     * \brief Set the Froude number for free surface problems.
     * \return Value of the Froude number.
     */
    void SetModVel_FreeStreamND(double val_modvel_freestreamnd);
    
    /*!
     * \brief Set the Froude number for free surface problems.
     * \return Value of the Froude number.
     */
    void SetTemperature_FreeStream(double val_temperature_freestream);
    
    /*!
     * \brief Set the Froude number for free surface problems.
     * \return Value of the Froude number.
     */
    void SetTemperature_FreeStreamND(double val_temperature_freestreamnd);
    
    /*!
     * \brief Set the Froude number for free surface problems.
     * \return Value of the Froude number.
     */
    void SetGas_ConstantND(double val_gas_constantnd);
    
    /*!
     * \brief Set the Froude number for free surface problems.
     * \return Value of the Froude number.
     */
    void SetVelocity_FreeStreamND(double val_velocity_freestreamnd, unsigned short val_dim);
    
    /*!
     * \brief Set the Froude number for free surface problems.
     * \return Value of the Froude number.
     */
    void SetViscosity_FreeStreamND(double val_viscosity_freestreamnd);
    
    /*!
     * \brief Set the Froude number for free surface problems.
     * \return Value of the Froude number.
     */
    void SetTke_FreeStreamND(double val_tke_freestreamnd);
    
    /*!
     * \brief Set the Froude number for free surface problems.
     * \return Value of the Froude number.
     */
    void SetOmega_FreeStreamND(double val_omega_freestreamnd);
    
    /*!
     * \brief Set the Froude number for free surface problems.
     * \return Value of the Froude number.
     */
    void SetTke_FreeStream(double val_tke_freestream);
    
    /*!
     * \brief Set the Froude number for free surface problems.
     * \return Value of the Froude number.
     */
    void SetOmega_FreeStream(double val_omega_freestream);
    
    /*!
     * \brief Set the Froude number for free surface problems.
     * \return Value of the Froude number.
     */
    void SetEnergy_FreeStreamND(double val_energy_freestreamnd);
    
    /*!
     * \brief Set the Froude number for free surface problems.
     * \return Value of the Froude number.
     */
    void SetEnergy_FreeStream(double val_energy_freestream);
    
    /*!
     * \brief Set the Froude number for free surface problems.
     * \return Value of the Froude number.
     */
    void SetTotal_UnstTimeND(double val_total_unsttimend);
    
    /*!
     * \brief Get the angle of attack of the body. This is the angle between a reference line on a lifting body
     *        (often the chord line of an airfoil) and the vector representing the relative motion between the
     *        lifting body and the fluid through which it is moving.
     * \return Value of the angle of attack.
     */
    double GetAoA(void);
    
    /*!
     * \brief Set the angle of attack.
     * \param[in] val_AoA - Value of the angle of attack.
     */
    void SetAoA(double val_AoA);
    
    /*!
     * \brief Set the angle of attack.
     * \param[in] val_AoA - Value of the angle of attack.
     */
    void SetAoS(double val_AoS);
    
    /*!
     * \brief Get the angle of sideslip of the body. It relates to the rotation of the aircraft centerline from
     *        the relative wind.
     * \return Value of the angle of sideslip.
     */
    double GetAoS(void);
    
    /*!
     * \brief Get the charge coefficient that is used in the poissonal potential simulation.
     * \return Value of the charge coefficient.
     */
    double GetChargeCoeff(void);
    
    /*!
     * \brief Get the number of multigrid levels.
     * \return Number of multigrid levels (without including the original grid).
     */
    unsigned short GetnMGLevels(void);
    
    /*!
     * \brief Set the number of multigrid levels.
     * \param[in] val_nMGLevels - Index of the mesh were the CFL is applied
     */
    void SetMGLevels(unsigned short val_nMGLevels);
    
    /*!
     * \brief Get the index of the finest grid.
     * \return Index of the finest grid in a multigrid strategy, this is 0 unless we are
     performing a Full multigrid.
     */
    unsigned short GetFinestMesh(void);
    
    /*!
     * \brief Get the kind of multigrid (V or W).
     * \note This variable is used in a recursive way to perform the different kind of cycles
     * \return 0 or 1 depending of we are dealing with a V or W cycle.
     */
    unsigned short GetMGCycle(void);
    
    /*!
     * \brief Get the king of evaluation in the geometrical module.
     * \return 0 or 1 depending of we are dealing with a V or W cycle.
     */
    unsigned short GetGeometryMode(void);
    
    /*!
     * \brief Get the Courant Friedrich Levi number for each grid.
     * \param[in] val_mesh - Index of the mesh were the CFL is applied.
     * \return CFL number for each grid.
     */
    double GetCFL(unsigned short val_mesh);
    
    /*!
     * \brief Get the Courant Friedrich Levi number for each grid.
     * \param[in] val_mesh - Index of the mesh were the CFL is applied.
     * \return CFL number for each grid.
     */
    void SetCFL(unsigned short val_mesh, double val_cfl);
    
    /*!
     * \brief Get the Courant Friedrich Levi number for each grid, for each species
     * \param[in] val_mesh - Index of the mesh were the CFL is applied.
     * \param[in] val_Species - Index of the chemical species
     * \return CFL number for each grid.
     */
    //double GetCFL(unsigned short val_mesh, unsigned short val_Species);
    
    /*!
     * \brief Get the Courant Friedrich Levi number for unsteady simulations.
     * \return CFL number for unsteady simulations.
     */
    double GetUnst_CFL(void);
    
    /*!
     * \brief Get the Courant Friedrich Levi number for unsteady simulations.
     * \return CFL number for unsteady simulations.
     */
    double GetMax_DeltaTime(void);
    
    /*!
     * \brief Get a parameter of the particular design variable.
     * \param[in] val_dv - Number of the design variable that we want to read.
     * \param[in] val_param - Index of the parameter that we want to read.
     * \return Design variable parameter.
     */
    double GetParamDV(unsigned short val_dv, unsigned short val_param);
    
    /*!
     * \brief Get a parameter of the particular design variable.
     * \param[in] val_ffd - Number of the ffd that we want to read.
     * \param[in] val_coord - Index of the coordinate that we want to read.
     * \return FFD parameter.
     */
    double GetCoordFFDBox(unsigned short val_ffd, unsigned short val_coord);
    
    /*!
     * \brief Get a parameter of the particular design variable.
     * \param[in] val_ffd - Number of the ffd that we want to read.
     * \param[in] val_coord - Index of the coordinate that we want to read.
     * \return FFD parameter.
     */
    unsigned short GetDegreeFFDBox(unsigned short val_ffd, unsigned short val_degree);
    
    /*!
     * \brief Get the FFD Tag of a particular design variable.
     * \param[in] val_dv - Number of the design variable that we want to read.
     * \return Design variable parameter.
     */
    string GetFFDTag(unsigned short val_dv);
    
    /*!
     * \brief Get the FFD Tag of a particular design variable.
     * \param[in] val_dv - Number of the design variable that we want to read.
     * \return Design variable parameter.
     */
    string GetTagFFDBox(unsigned short val_ffd);
    
    /*!
     * \brief Get the number of design variables.
     * \return Number of the design variables.
     */
    unsigned short GetnDV(void);
    
    /*!
     * \brief Get the number of design variables.
     * \return Number of the design variables.
     */
    unsigned short GetnFFDBox(void);
    
    /*!
     * \brief Get the required continuity level at the surface intersection with the FFD
     * \return Continuity level at the surface intersection.
     */
    unsigned short GetFFD_Continuity(void);
    
    /*!
     * \brief Get the number of Runge-Kutta steps.
     * \return Number of Runge-Kutta steps.
     */
    unsigned short GetnRKStep(void);
    
    /*!
     * \brief Get the total number of boundary markers.
     * \return Total number of boundary markers.
     */
    unsigned short GetnMarker_All(void);
    
    /*!
     * \brief Get the total number of boundary markers.
     * \return Total number of boundary markers.
     */
    unsigned short GetnMarker_Max(void);
    
    /*!
     * \brief Get the total number of boundary markers.
     * \return Total number of boundary markers.
     */
    unsigned short GetnMarker_EngineInflow(void);
    
    /*!
     * \brief Get the total number of boundary markers.
     * \return Total number of boundary markers.
     */
    unsigned short GetnMarker_EngineBleed(void);
    
    /*!
     * \brief Get the total number of boundary markers.
     * \return Total number of boundary markers.
     */
    unsigned short GetnMarker_EngineExhaust(void);
    
    /*!
     * \brief Get the total number of boundary markers.
     * \return Total number of boundary markers.
     */
    unsigned short GetnMarker_NearFieldBound(void);
    
    /*!
     * \brief Get the total number of boundary markers.
     * \return Total number of boundary markers.
     */
    unsigned short GetnMarker_InterfaceBound(void);
    
    /*!
     * \brief Get the total number of boundary markers.
     * \return Total number of boundary markers.
     */
    unsigned short GetnMarker_ActDisk_Inlet(void);
    
    /*!
     * \brief Get the total number of boundary markers.
     * \return Total number of boundary markers.
     */
    unsigned short GetnMarker_ActDisk_Outlet(void);
    
    /*!
     * \brief Get the total number of 1D output markers.
     * \return Total number of monitoring markers.
     */
    unsigned short GetnMarker_Out_1D(void);
    
    
    /*!
     * \brief Get the total number of monitoring markers.
     * \return Total number of monitoring markers.
     */
    unsigned short GetnMarker_Monitoring(void);
    
    /*!
     * \brief Get the total number of moving markers.
     * \return Total number of moving markers.
     */
    unsigned short GetnMarker_Moving(void);
    
    /*!
     * \brief Stores the number of marker in the simulation.
     * \param[in] val_nmarker - Number of markers of the problem.
     */
    void SetnMarker_All(unsigned short val_nmarker);
    
    /*!
     * \brief Get the number of external iterations.
     * \return Number of external iterations.
     */
    unsigned long GetnExtIter(void);
    
    /*!
     * \brief Get the number of internal iterations.
     * \return Number of internal iterations.
     */
    unsigned long GetUnst_nIntIter(void);
    
    /*!
     * \brief Get the restart iteration number for unsteady simulations.
     * \return Restart iteration number for unsteady simulations.
     */
    long GetUnst_RestartIter(void);
    
    /*!
     * \brief Get the starting direct iteration number for the unsteady adjoint (reverse time integration).
     * \return Starting direct iteration number for the unsteady adjoint.
     */
    long GetUnst_AdjointIter(void);
    
    /*!
     * \brief Retrieves the number of periodic time instances for Time Spectral.
     * \return: Number of periodic time instances for Time Spectral.
     */
    unsigned short GetnTimeInstances(void);
    
    /*!
     * \brief Retrieves the period of oscillations to be used with Time Spectral.
     * \return: Period for Time Spectral.
     */
    double GetTimeSpectral_Period(void);
    
    /*!
     * \brief Set the number of external iterations.
     * \note This is important in no time depending methods, where only
     *       one external iteration is needed.
     * \param[in] val_niter - Set the number of external iterations.
     */
    void SetnExtIter(unsigned long val_niter);
    
    /*!
     * \brief Set the current external iteration number.
     * \param[in] val_iter - Current external iteration number.
     */
    void SetExtIter(unsigned long val_iter);
    
    /*!
     * \brief Set the current internal iteration number.
     * \param[in] val_iter - Current external iteration number.
     */
    void SetIntIter(unsigned long val_iter);
    
    /*!
     * \brief Get the current internal iteration number.
     * \return Current external iteration.
     */
    unsigned long GetExtIter(void);
    
    /*!
     * \brief Get the current external iteration number.
     * \return Current external iteration.
     */
    unsigned long GetIntIter(void);
    
    /*!
     * \brief Get the frequency for writing the solution file.
     * \return It writes the solution file with this frequency.
     */
    unsigned long GetWrt_Sol_Freq(void);
    
    /*!
     * \brief Get the frequency for writing the solution file in Dual Time.
     * \return It writes the solution file with this frequency.
     */
    unsigned long GetWrt_Sol_Freq_DualTime(void);
    
    /*!
     * \brief Get the frequency for writing the convergence file.
     * \return It writes the convergence file with this frequency.
     */
    unsigned long GetWrt_Con_Freq(void);
    
    /*!
     * \brief Get the frequency for writing the convergence file in Dual Time.
     * \return It writes the convergence file with this frequency.
     */
    unsigned long GetWrt_Con_Freq_DualTime(void);
    
    /*!
     * \brief Get information about writing unsteady headers and file extensions.
     * \return 	<code>TRUE</code> means that unsteady solution files will be written.
     */
    bool GetWrt_Unsteady(void);
    
    /*!
     * \brief Get information about performing a low fidelity simulation.
     * \return 	<code>TRUE</code> means that a low fidelity simulation will be performed.
     */
    bool GetLowFidelitySim(void);
    
    /*!
     * \brief Get information about writing a volume solution file.
     * \return <code>TRUE</code> means that a volume solution file will be written.
     */
    bool GetWrt_Vol_Sol(void);
    
    /*!
     * \brief Get information about writing a volume solution file.
     * \return <code>TRUE</code> means that a volume solution file will be written.
     */
    bool GetLow_MemoryOutput(void);
    
    /*!
     * \brief Get information about writing a surface solution file.
     * \return <code>TRUE</code> means that a surface solution file will be written.
     */
    bool GetWrt_Srf_Sol(void);
    
    /*!
     * \brief Get information about writing a surface comma-separated values (CSV) solution file.
     * \return <code>TRUE</code> means that a surface comma-separated values (CSV) solution file will be written.
     */
    bool GetWrt_Csv_Sol(void);
    
    /*!
     * \brief Get information about writing residuals to volume solution file.
     * \return <code>TRUE</code> means that residuals will be written to the solution file.
     */
    bool GetWrt_Residuals(void);
    
    /*!
     * \brief Get information about writing residuals to volume solution file.
     * \return <code>TRUE</code> means that residuals will be written to the solution file.
     */
    bool GetWrt_Limiters(void);
    
    /*!
     * \brief Get information about writing residuals to volume solution file.
     * \return <code>TRUE</code> means that residuals will be written to the solution file.
     */
    bool GetWrt_SharpEdges(void);
    
    /*!
     * \brief Get information about writing rind layers to the solution files.
     * \return <code>TRUE</code> means that rind layers will be written to the solution file.
     */
    bool GetWrt_Halo(void);
    
    /*!
     * \brief Get information about writing sectional force files.
     * \return <code>TRUE</code> means that sectional force files will be written for specified markers.
     */
    bool GetPlot_Section_Forces(void);
    
    /*!
     * \brief Get information about writing average stagnation pressure
     * \return <code>TRUE</code> means that the average stagnation pressure will be output for specified markers.
     */
    bool GetWrt_1D_Output(void);
    
    /*!
     * \brief Get the alpha (convective) coefficients for the Runge-Kutta integration scheme.
     * \param[in] val_step - Index of the step.
     * \return Alpha coefficient for the Runge-Kutta integration scheme.
     */
    double Get_Alpha_RKStep(unsigned short val_step);
    
    /*!
     * \brief Get the index of the surface defined in the geometry file.
     * \param[in] val_marker - Value of the marker in which we are interested.
     * \return Value of the index that is in the geometry file for the surface that
     *         has the marker <i>val_marker</i>.
     */
    string GetMarker_All_TagBound(unsigned short val_marker);
    
    /*!
     * \brief Get the index of the surface defined in the geometry file.
     * \param[in] val_marker - Value of the marker in which we are interested.
     * \return Value of the index that is in the geometry file for the surface that
     *         has the marker <i>val_marker</i>.
     */
    string GetMarker_ActDisk_Inlet(unsigned short val_marker);
    
    /*!
     * \brief Get the index of the surface defined in the geometry file.
     * \param[in] val_marker - Value of the marker in which we are interested.
     * \return Value of the index that is in the geometry file for the surface that
     *         has the marker <i>val_marker</i>.
     */
    string GetMarker_ActDisk_Outlet(unsigned short val_marker);
    
    /*!
     * \brief Get the index of the surface defined in the geometry file.
     * \param[in] val_marker - Value of the marker in which we are interested.
     * \return Value of the index that is in the geometry file for the surface that
     *         has the marker <i>val_marker</i>.
     */
    string GetMarker_EngineInflow(unsigned short val_marker);
    
    /*!
     * \brief Get the index of the surface defined in the geometry file.
     * \param[in] val_marker - Value of the marker in which we are interested.
     * \return Value of the index that is in the geometry file for the surface that
     *         has the marker <i>val_marker</i>.
     */
    string GetMarker_EngineBleed(unsigned short val_marker);
    
    /*!
     * \brief Get the index of the surface defined in the geometry file.
     * \param[in] val_marker - Value of the marker in which we are interested.
     * \return Value of the index that is in the geometry file for the surface that
     *         has the marker <i>val_marker</i>.
     */
    string GetMarker_EngineExhaust(unsigned short val_marker);
    
    /*!
     * \brief Get the name of the surface defined in the geometry file.
     * \param[in] val_marker - Value of the marker in which we are interested.
     * \return Name that is in the geometry file for the surface that
     *         has the marker <i>val_marker</i>.
     */
    string GetMarker_Monitoring(unsigned short val_marker);
    
    /*!
     * \brief Get the tag if the iMarker defined in the geometry file.
     * \param[in] val_tag - Value of the tag in which we are interested.
     * \return Value of the marker <i>val_marker</i> that is in the geometry file
     *         for the surface that has the tag.
     */
    short GetMarker_All_TagBound(string val_tag);
    
    /*!
     * \brief Get the kind of boundary for each marker.
     * \param[in] val_marker - Index of the marker in which we are interested.
     * \return Kind of boundary for the marker <i>val_marker</i>.
     */
    unsigned short GetMarker_All_KindBC(unsigned short val_marker);
    
    /*!
     * \brief Get the kind of boundary for each marker.
     * \param[in] val_marker - Index of the marker in which we are interested.
     * \return Kind of boundary for the marker <i>val_marker</i>.
     */
    unsigned short GetMarker_All_Out_1D(unsigned short val_marker);
    
    /*!
     * \brief Set the value of the boundary <i>val_boundary</i> (read from the config file)
     *        for the marker <i>val_marker</i>.
     * \param[in] val_marker - Index of the marker in which we are interested.
     * \param[in] val_boundary - Kind of boundary read from config file.
     */
    void SetMarker_All_Out_1D(unsigned short val_marker, unsigned short val_boundary);
    
    
    /*!
     * \brief Set the value of the boundary <i>val_boundary</i> (read from the config file)
     *        for the marker <i>val_marker</i>.
     * \param[in] val_marker - Index of the marker in which we are interested.
     * \param[in] val_boundary - Kind of boundary read from config file.
     */
    void SetMarker_All_KindBC(unsigned short val_marker, unsigned short val_boundary);
    
    /*!
     * \brief Set the value of the index <i>val_index</i> (read from the geometry file) for
     *        the marker <i>val_marker</i>.
     * \param[in] val_marker - Index of the marker in which we are interested.
     * \param[in] val_index - Index of the surface read from geometry file.
     */
    void SetMarker_All_TagBound(unsigned short val_marker, string val_index);
    
    /*!
     * \brief Set if a marker <i>val_marker</i> is going to be monitored <i>val_monitoring</i>
     *        (read from the config file).
     * \note This is important for non dimensional coefficient computation.
     * \param[in] val_marker - Index of the marker in which we are interested.
     * \param[in] val_monitoring - 0 or 1 depending if the the marker is going to be monitored.
     */
    void SetMarker_All_Monitoring(unsigned short val_marker, unsigned short val_monitoring);
    
    /*!
     * \brief Set if a marker <i>val_marker</i> is going to be monitored <i>val_monitoring</i>
     *        (read from the config file).
     * \note This is important for non dimensional coefficient computation.
     * \param[in] val_marker - Index of the marker in which we are interested.
     * \param[in] val_monitoring - 0 or 1 depending if the the marker is going to be monitored.
     */
    void SetMarker_All_GeoEval(unsigned short val_marker, unsigned short val_geoeval);
    
    /*!
     * \brief Set if a marker <i>val_marker</i> is going to be designed <i>val_designing</i>
     *        (read from the config file).
     * \note This is important for non dimensional coefficient computation.
     * \param[in] val_marker - Index of the marker in which we are interested.
     * \param[in] val_monitoring - 0 or 1 depending if the the marker is going to be designed.
     */
    void SetMarker_All_Designing(unsigned short val_marker, unsigned short val_designing);
    
    /*!
     * \brief Set if a marker <i>val_marker</i> is going to be plot <i>val_plotting</i>
     *        (read from the config file).
     * \param[in] val_marker - Index of the marker in which we are interested.
     * \param[in] val_plotting - 0 or 1 depending if the the marker is going to be plot.
     */
    void SetMarker_All_Plotting(unsigned short val_marker, unsigned short val_plotting);
    
    /*!
     * \brief Set if a marker <i>val_marker</i> is going to be affected by design variables <i>val_moving</i>
     *        (read from the config file).
     * \param[in] val_marker - Index of the marker in which we are interested.
     * \param[in] val_DV - 0 or 1 depending if the the marker is affected by design variables.
     */
    void SetMarker_All_DV(unsigned short val_marker, unsigned short val_DV);
    
    /*!
     * \brief Set if a marker <i>val_marker</i> is going to be moved <i>val_moving</i>
     *        (read from the config file).
     * \param[in] val_marker - Index of the marker in which we are interested.
     * \param[in] val_moving - 0 or 1 depending if the the marker is going to be moved.
     */
    void SetMarker_All_Moving(unsigned short val_marker, unsigned short val_moving);
    
    /*!
     * \brief Set if a marker <i>val_marker</i> is going to be periodic <i>val_perbound</i>
     *        (read from the config file).
     * \param[in] val_marker - Index of the marker in which we are interested.
     * \param[in] val_perbound - Index of the surface with the periodic boundary.
     */
    void SetMarker_All_PerBound(unsigned short val_marker, short val_perbound);
    
    /*!
     * \brief Set if a marker <i>val_marker</i> is going to be sent or receive <i>val_index</i>
     *        from another domain.
     * \param[in] val_marker - 0 or 1 depending if the the marker is going to be moved.
     * \param[in] val_index - Index of the surface read from geometry file.
     */
    void SetMarker_All_SendRecv(unsigned short val_marker, short val_index);
    
    /*!
     * \brief Get the send-receive information for a marker <i>val_marker</i>.
     * \param[in] val_marker - 0 or 1 depending if the the marker is going to be moved.
     * \return If positive, the information is sended to that domain, in case negative
     *         the information is receive from that domain.
     */
    short GetMarker_All_SendRecv(unsigned short val_marker);
    
    /*!
     * \brief Get an internal index that identify the periodic boundary conditions.
     * \param[in] val_marker - Value of the marker that correspond with the periodic boundary.
     * \return The internal index of the periodic boundary condition.
     */
    short GetMarker_All_PerBound(unsigned short val_marker);
    
    /*!
     * \brief Get the monitoring information for a marker <i>val_marker</i>.
     * \param[in] val_marker - 0 or 1 depending if the the marker is going to be monitored.
     * \return 0 or 1 depending if the marker is going to be monitored.
     */
    unsigned short GetMarker_All_Monitoring(unsigned short val_marker);
    
    /*!
     * \brief Get the monitoring information for a marker <i>val_marker</i>.
     * \param[in] val_marker - 0 or 1 depending if the the marker is going to be monitored.
     * \return 0 or 1 depending if the marker is going to be monitored.
     */
    unsigned short GetMarker_All_GeoEval(unsigned short val_marker);
    
    /*!
     * \brief Get the design information for a marker <i>val_marker</i>.
     * \param[in] val_marker - 0 or 1 depending if the the marker is going to be monitored.
     * \return 0 or 1 depending if the marker is going to be monitored.
     */
    unsigned short GetMarker_All_Designing(unsigned short val_marker);
    
    /*!
     * \brief Get the plotting information for a marker <i>val_marker</i>.
     * \param[in] val_marker - 0 or 1 depending if the the marker is going to be moved.
     * \return 0 or 1 depending if the marker is going to be plotted.
     */
    unsigned short GetMarker_All_Plotting(unsigned short val_marker);
    
    /*!
     * \brief Get the DV information for a marker <i>val_marker</i>.
     * \param[in] val_marker - 0 or 1 depending if the the marker is going to be affected by design variables.
     * \return 0 or 1 depending if the marker is going to be affected by design variables.
     */
    unsigned short GetMarker_All_DV(unsigned short val_marker);
    
    /*!
     * \brief Get the motion information for a marker <i>val_marker</i>.
     * \param[in] val_marker - 0 or 1 depending if the the marker is going to be moved.
     * \return 0 or 1 depending if the marker is going to be moved.
     */
    unsigned short GetMarker_All_Moving(unsigned short val_marker);
    
    /*!
     * \brief Get the number of pre-smoothings in a multigrid strategy.
     * \param[in] val_mesh - Index of the grid.
     * \return Number of smoothing iterations.
     */
    unsigned short GetMG_PreSmooth(unsigned short val_mesh);
    
    /*!
     * \brief Get the number of post-smoothings in a multigrid strategy.
     * \param[in] val_mesh - Index of the grid.
     * \return Number of smoothing iterations.
     */
    unsigned short GetMG_PostSmooth(unsigned short val_mesh);
    
    /*!
     * \brief Get the number of implicit Jacobi smoothings of the correction in a multigrid strategy.
     * \param[in] val_mesh - Index of the grid.
     * \return Number of implicit smoothing iterations.
     */
    unsigned short GetMG_CorrecSmooth(unsigned short val_mesh);
    
    /*!
     * \brief Governing equations of the flow (it can be different from the run time equation).
     * \param[in] val_zone - Zone where the soler is applied.
     * \return Governing equation that we are solving.
     */
    unsigned short GetKind_Solver(void);
    
    /*!
     * \brief Governing equations of the flow (it can be different from the run time equation).
     * \param[in] val_zone - Zone where the soler is applied.
     * \return Governing equation that we are solving.
     */
    unsigned short GetKind_Regime(void);
    
    /*!
     * \brief Governing equations of the flow (it can be different from the run time equation).
     * \param[in] val_zone - Zone where the soler is applied.
     * \return Governing equation that we are solving.
     */
    unsigned short GetSystemMeasurements(void);
    
    /*!
     * \brief Gas model that we are using.
     * \return Gas model that we are using.
     */
    unsigned short GetKind_GasModel(void);
    
    /*!
     * \brief Fluid model that we are using.
     * \return Fluid model that we are using.
     */
    unsigned short GetKind_FluidModel(void);
    
    /*!
     * \brief free stream option to initialize the solution
     * \return free stream option
     */
    unsigned short GetKind_FreeStreamOption(void);
    
    /*!
     * \brief free stream option to initialize the solution
     * \return free stream option
     */
    unsigned short GetKind_InitOption(void);
    /*!
     * \brief Get the value of the critical pressure.
     * \return Critical pressure.
     */
    double GetPressure_Critical(void);
    
    /*!
     * \brief Get the value of the critical temperature.
     * \return Critical temperature.
     */
    double GetTemperature_Critical(void);
    
    /*!
     * \brief Get the value of the critical pressure.
     * \return Critical pressure.
     */
    double GetAcentric_Factor(void);
    
    /*!
     * \brief Get the value of the critical temperature.
     * \return Critical temperature.
     */
    unsigned short GetKind_ViscosityModel(void);
    
    /*!
     * \brief Get the value of the thermal conductivity .
     * \return Critical temperature.
     */
    unsigned short GetKind_ConductivityModel(void);
    
    /*!
     * \brief Get the value of the critical temperature.
     * \return Critical temperature.
     */
    double GetMu_ConstantND(void);
    
    /*!
     * \brief Get the value of the non-dimensional thermal conductivity.
     * \return Critical temperature.
     */
    double GetKt_ConstantND(void);
    
    /*!
     * \brief Get the value of the critical temperature.
     * \return Critical temperature.
     */
    double GetMu_RefND(void);
    
    /*!
     * \brief Get the value of the critical temperature.
     * \return Critical temperature.
     */
    double GetMu_Temperature_RefND(void);
    
    /*!
     * \brief Get the value of the critical temperature.
     * \return Critical temperature.
     */
    double GetMu_SND(void);
    
    /*!
     * \brief Get the value of the critical temperature.
     * \return Critical temperature.
     */
    void SetMu_ConstantND(double mu_const);
    
    /*!
     * \brief Get the value of the critical temperature.
     * \return Critical temperature.
     */
    void SetKt_ConstantND(double kt_const);
    
    /*!
     * \brief Get the value of the critical temperature.
     * \return Critical temperature.
     */
    void SetMu_RefND(double mu_ref);
    
    /*!
     * \brief Get the value of the critical temperature.
     * \return Critical temperature.
     */
    void SetMu_Temperature_RefND(double mu_Tref);
    
    /*!
     * \brief Get the value of the critical temperature.
     * \return Critical temperature.
     */
    void SetMu_SND(double mu_s);
    
    /*!
     * \brief Get the kind of method for computation of spatial gradients.
     * \return Numerical method for computation of spatial gradients.
     */
    unsigned short GetKind_Gradient_Method(void);
    
    /*!
     * \brief Get the kind of solver for the implicit solver.
     * \return Numerical solver for implicit formulation (solving the linear system).
     */
    unsigned short GetKind_Linear_Solver(void);
    
    /*!
     * \brief Get the kind of solver for the implicit solver.
     * \return Numerical solver for implicit formulation (solving the linear system).
     */
    unsigned short GetDeform_Linear_Solver(void);
    
    /*!
     * \brief Get the kind of preconditioner for the implicit solver.
     * \return Numerical preconditioner for implicit formulation (solving the linear system).
     */
    unsigned short GetKind_Linear_Solver_Prec(void);
    
    /*!
     * \brief Set the kind of preconditioner for the implicit solver.
     * \return Numerical preconditioner for implicit formulation (solving the linear system).
     */
    void SetKind_Linear_Solver_Prec(unsigned short val_kind_prec);
    
    /*!
     * \brief Get min error of the linear solver for the implicit formulation.
     * \return Min error of the linear solver for the implicit formulation.
     */
    double GetLinear_Solver_Error(void);
    
    /*!
     * \brief Get max number of iterations of the linear solver for the implicit formulation.
     * \return Max number of iterations of the linear solver for the implicit formulation.
     */
    unsigned long GetLinear_Solver_Iter(void);
    
    /*!
     * \brief Get restart frequency of the linear solver for the implicit formulation.
     * \return Restart frequency of the linear solver for the implicit formulation.
     */
    unsigned long GetLinear_Solver_Restart_Frequency(void);
    
    /*!
     * \brief Get the relaxation coefficient of the linear solver for the implicit formulation.
     * \return relaxation coefficient of the linear solver for the implicit formulation.
     */
    double GetRelaxation_Factor_Flow(void);
    
    /*!
     * \brief Get the relaxation coefficient of the linear solver for the implicit formulation.
     * \return relaxation coefficient of the linear solver for the implicit formulation.
     */
    double GetRelaxation_Factor_AdjFlow(void);
    
    /*!
     * \brief Get the relaxation coefficient of the linear solver for the implicit formulation.
     * \return relaxation coefficient of the linear solver for the implicit formulation.
     */
    double GetRelaxation_Factor_Turb(void);
    
    /*!
     * \brief Get the relaxation coefficient of the linear solver for the implicit formulation.
     * \return relaxation coefficient of the linear solver for the implicit formulation.
     */
    double GetRoe_Kappa(void);
    
    /*!
     * \brief Get the kind of solver for the implicit solver.
     * \return Numerical solver for implicit formulation (solving the linear system).
     */
    unsigned short GetKind_AdjTurb_Linear_Solver(void);
    
    /*!
     * \brief Get the kind of preconditioner for the implicit solver.
     * \return Numerical preconditioner for implicit formulation (solving the linear system).
     */
    unsigned short GetKind_AdjTurb_Linear_Prec(void);
    
    /*!
     * \brief Set the kind of preconditioner for the implicit solver.
     * \return Numerical preconditioner for implicit formulation (solving the linear system).
     */
    void SetKind_AdjTurb_Linear_Prec(unsigned short val_kind_prec);
    
    /*!
     * \brief Get min error of the linear solver for the implicit formulation.
     * \return Min error of the linear solver for the implicit formulation.
     */
    double GetAdjTurb_Linear_Error(void);
    
    /*!
     * \brief Get the entropy fix.
     * \return Vaule of the entropy fix.
     */
    double GetEntropyFix_Coeff(void);
    
    /*!
     * \brief Get max number of iterations of the linear solver for the implicit formulation.
     * \return Max number of iterations of the linear solver for the implicit formulation.
     */
    unsigned short GetAdjTurb_Linear_Iter(void);
    
    /*!
     * \brief Get CFL reduction factor for adjoint turbulence model.
     * \return CFL reduction factor.
     */
    double GetCFLRedCoeff_AdjTurb(void);
    
    /*!
     * \brief Get the number of linear smoothing iterations for mesh deformation.
     * \return Number of linear smoothing iterations for mesh deformation.
     */
    unsigned long GetGridDef_Linear_Iter(void);
    
    /*!
     * \brief Get the number of nonlinear increments for mesh deformation.
     * \return Number of nonlinear increments for mesh deformation.
     */
    unsigned long GetGridDef_Nonlinear_Iter(void);
    
    /*!
     * \brief Get information about writing grid deformation residuals to the console.
     * \return <code>TRUE</code> means that grid deformation residuals will be written to the console.
     */
    bool GetDeform_Output(void);
    
    /*!
     * \brief Get factor to multiply smallest volume for deform tolerance.
     * \return Factor to multiply smallest volume for deform tolerance.
     */
    double GetDeform_Tol_Factor(void);
    
    /*!
     * \brief Get Young's modulus for deformation (constant stiffness deformation)
     */
    double GetDeform_ElasticityMod(void);
    
    /*!
     * \brief Get Poisson's ratio for deformation (constant stiffness deformation)
     * \
     */
    double GetDeform_PoissonRatio(void);
    
    /*!
     * \brief Get the type of stiffness to impose for FEA mesh deformation.
     * \return type of stiffness to impose for FEA mesh deformation.
     */
    unsigned short GetDeform_Stiffness_Type(void);
    
    /*!
     * \brief Creates a teot file to visualize the deformation made by the MDC software.
     * \return <code>TRUE</code> if the deformation is going to be plotted; otherwise <code>FALSE</code>.
     */
    bool GetVisualize_Deformation(void);
    
    /*!
     * \brief Get the kind of SU2 software component.
     * \return Kind of the SU2 software component.
     */
    unsigned short GetKind_SU2(void);
    
    /*!
     * \brief Get the kind of non-dimensionalization.
     * \return Kind of non-dimensionalization.
     */
    unsigned short GetRef_NonDim(void);
    
    /*!
     * \brief Get the kind of SU2 software component.
     * \return Kind of the SU2 software component.
     */
    void SetKind_SU2(unsigned short val_kind_su2);
    
    /*!
     * \brief Get the kind of the turbulence model.
     * \return Kind of the turbulence model.
     */
    unsigned short GetKind_Turb_Model(void);
    
    /*!
     * \brief Get the file containing the ML model
     */
    string GetML_Turb_Model_File(void);
    
    /*!
     * \brief File containing a check for the proper creation of the turb model
     * \return Temporary ml->SU2 file name.
     */
    string GetML_Turb_Model_FeatureSet(void);
    
    /*!
     * \brief File containing a check for the proper creation of the turb model
     * \return Temporary ml->SU2 file name.
     */
    string* GetML_Turb_Model_Extra(void);
    
    /*!
     * \brief File containing a check for the proper creation of the turb model
     * \return Temporary ml->SU2 file name.
     */
    unsigned short GetNumML_Turb_Model_Extra(void);
    
    /*!
     * \brief Get the kind of the transition model.
     * \return Kind of the transion model.
     */
    unsigned short GetKind_Trans_Model(void);
    
    /*!
     * \brief Get the kind of adaptation technique.
     * \return Kind of adaptation technique.
     */
    unsigned short GetKind_Adaptation(void);
    
    /*!
     * \brief Get the number of new elements added in the adaptation process.
     * \return percentage of new elements that are going to be added in the adaptation.
     */
    double GetNew_Elem_Adapt(void);
    
    /*!
     * \brief Get the kind of time integration method.
     * \note This is the information that the code will use, the method will
     *       change in runtime depending of the specific equation (direct, adjoint,
     *       linearized) that is being solved.
     * \return Kind of time integration method.
     */
    unsigned short GetKind_TimeIntScheme(void);
    
    /*!
     * \brief Get the kind of convective numerical scheme.
     * \note This is the information that the code will use, the method will
     *       change in runtime depending of the specific equation (direct, adjoint,
     *       linearized) that is being solved.
     * \return Kind of the convective scheme.
     */
    unsigned short GetKind_ConvNumScheme(void);
    
    /*!
     * \brief Get kind of center scheme for the convective terms.
     * \note This is the information that the code will use, the method will
     *       change in runtime depending of the specific equation (direct, adjoint,
     *       linearized) that is being solved.
     * \return Kind of center scheme for the convective terms.
     */
    unsigned short GetKind_Centered(void);
    
    /*!
     * \brief Get kind of upwind scheme for the convective terms.
     * \note This is the information that the code will use, the method will
     *       change in runtime depending of the specific equation (direct, adjoint,
     *       linearized) that is being solved.
     * \return Kind of upwind scheme for the convective terms.
     */
    unsigned short GetKind_Upwind(void);
    
    /*!
     * \brief Get the order of the spatial integration.
     * \note This is the information that the code will use, the method will
     *       change in runtime depending of the specific equation (direct, adjoint,
     *       linearized) that is being solved.
     * \return Kind of upwind scheme for the convective terms.
     */
    unsigned short GetSpatialOrder(void);
    
    /*!
     * \brief Get the order of the spatial integration.
     * \note This is the information that the code will use, the method will
     *       change in runtime depending of the specific equation (direct, adjoint,
     *       linearized) that is being solved.
     * \return Kind of upwind scheme for the convective terms.
     */
    unsigned short GetSpatialOrder_Flow(void);
    
    /*!
     * \brief Get the order of the spatial integration.
     * \note This is the information that the code will use, the method will
     *       change in runtime depending of the specific equation (direct, adjoint,
     *       linearized) that is being solved.
     * \return Kind of upwind scheme for the convective terms.
     */
    unsigned short GetSpatialOrder_Turb(void);
    
    /*!
     * \brief Get the order of the spatial integration.
     * \note This is the information that the code will use, the method will
     *       change in runtime depending of the specific equation (direct, adjoint,
     *       linearized) that is being solved.
     * \return Kind of upwind scheme for the convective terms.
     */
    unsigned short GetSpatialOrder_TNE2(void);
    
    /*!
     * \brief Get the order of the spatial integration.
     * \note This is the information that the code will use, the method will
     *       change in runtime depending of the specific equation (direct, adjoint,
     *       linearized) that is being solved.
     * \return Kind of upwind scheme for the convective terms.
     */
    unsigned short GetSpatialOrder_AdjLevelSet(void);
    
    /*!
     * \brief Get the order of the spatial integration.
     * \note This is the information that the code will use, the method will
     *       change in runtime depending of the specific equation (direct, adjoint,
     *       linearized) that is being solved.
     * \return Kind of upwind scheme for the convective terms.
     */
    unsigned short GetSpatialOrder_AdjFlow(void);
    
    /*!
     * \brief Get the order of the spatial integration.
     * \note This is the information that the code will use, the method will
     *       change in runtime depending of the specific equation (direct, adjoint,
     *       linearized) that is being solved.
     * \return Kind of upwind scheme for the convective terms.
     */
    unsigned short GetSpatialOrder_AdjTNE2(void);
    
    /*!
     * \brief Get the kind of integration scheme (explicit or implicit)
     *        for the flow equations.
     * \note This value is obtained from the config file, and it is constant
     *       during the computation.
     * \return Kind of integration scheme for the flow equations.
     */
    unsigned short GetKind_TimeIntScheme_Flow(void);
    
    /*!
     * \brief Get the kind of integration scheme (explicit or implicit)
     *        for the flow equations.
     * \note This value is obtained from the config file, and it is constant
     *       during the computation.
     * \return Kind of integration scheme for the flow equations.
     */
    unsigned short GetKind_TimeIntScheme_TNE2(void);
    
    /*!
     * \brief Get the kind of integration scheme (explicit or implicit)
     *        for the flow equations.
     * \note This value is obtained from the config file, and it is constant
     *       during the computation.
     * \return Kind of integration scheme for the plasma equations.
     */
    unsigned short GetKind_TimeIntScheme_Wave(void);
    
    /*!
     * \brief Get the kind of integration scheme (explicit or implicit)
     *        for the flow equations.
     * \note This value is obtained from the config file, and it is constant
     *       during the computation.
     * \return Kind of integration scheme for the plasma equations.
     */
    unsigned short GetKind_TimeIntScheme_Heat(void);
    
    /*!
     * \brief Get the kind of integration scheme (explicit or implicit)
     *        for the flow equations.
     * \note This value is obtained from the config file, and it is constant
     *       during the computation.
     * \return Kind of integration scheme for the plasma equations.
     */
    unsigned short GetKind_TimeIntScheme_Poisson(void);
    
    /*!
     * \brief Get the kind of integration scheme (explicit or implicit)
     *        for the flow equations.
     * \note This value is obtained from the config file, and it is constant
     *       during the computation.
     * \return Kind of integration scheme for the plasma equations.
     */
    unsigned short GetKind_TimeIntScheme_FEA(void);
    
    /*!
     * \brief Get the kind of integration scheme (explicit or implicit)
     *        for the template equations.
     * \note This value is obtained from the config file, and it is constant
     *       during the computation.
     * \return Kind of integration scheme for the plasma equations.
     */
    //unsigned short GetKind_TimeIntScheme_Template(void);
    
    /*!
     * \brief Get the kind of convective numerical scheme for the flow
     *        equations (centered or upwind).
     * \note This value is obtained from the config file, and it is constant
     *       during the computation.
     * \return Kind of convective numerical scheme for the flow equations.
     */
    unsigned short GetKind_ConvNumScheme_Flow(void);
    
    /*!
     * \brief Get the kind of convective numerical scheme for the flow
     *        equations (centered or upwind).
     * \note This value is obtained from the config file, and it is constant
     *       during the computation.
     * \return Kind of convective numerical scheme for the flow equations.
     */
    unsigned short GetKind_ConvNumScheme_TNE2(void);
    
    /*!
     * \brief Get the kind of convective numerical scheme for the flow
     *        equations (centered or upwind).
     * \note This value is obtained from the config file, and it is constant
     *       during the computation.
     * \return Kind of convective numerical scheme for the flow equations.
     */
    unsigned short GetKind_ConvNumScheme_AdjTNE2(void);
    
    /*!
     * \brief Get the kind of convective numerical scheme for the template
     *        equations (centered or upwind).
     * \note This value is obtained from the config file, and it is constant
     *       during the computation.
     * \return Kind of convective numerical scheme for the flow equations.
     */
    unsigned short GetKind_ConvNumScheme_Template(void);
    
    /*!
     * \brief Get the kind of convective numerical scheme for the adjoint level set
     *        equations (centered or upwind).
     * \note This value is obtained from the config file, and it is constant
     *       during the computation.
     * \return Kind of convective numerical scheme for the level set equation.
     */
    unsigned short GetKind_ConvNumScheme_AdjLevelSet(void);
    
    /*!
     * \brief Get the kind of center convective numerical scheme for the flow equations.
     * \note This value is obtained from the config file, and it is constant
     *       during the computation.
     * \return Kind of center convective numerical scheme for the flow equations.
     */
    unsigned short GetKind_Centered_Flow(void);
    
    /*!
     * \brief Get the kind of center convective numerical scheme for the two-temperature model.
     * \note This value is obtained from the config file, and it is constant
     *       during the computation.
     * \return Kind of center convective numerical scheme for the flow equations.
     */
    unsigned short GetKind_Centered_TNE2(void);
    
    /*!
     * \brief Get the kind of center convective numerical scheme for the two-temperature model.
     * \note This value is obtained from the config file, and it is constant
     *       during the computation.
     * \return Kind of center convective numerical scheme for the flow equations.
     */
    unsigned short GetKind_Centered_AdjTNE2(void);
    
    /*!
     * \brief Get the kind of center convective numerical scheme for the adjoint level set equations.
     * \note This value is obtained from the config file, and it is constant
     *       during the computation.
     * \return Kind of center convective numerical scheme for the level set equations.
     */
    unsigned short GetKind_Centered_AdjLevelSet(void);
    
    /*!
     * \brief Get the kind of center convective numerical scheme for the plasma equations.
     * \note This value is obtained from the config file, and it is constant
     *       during the computation.
     * \return Kind of center convective numerical scheme for the flow equations.
     */
    //unsigned short GetKind_Centered_Template(void);
    
    /*!
     * \brief Get the kind of upwind convective numerical scheme for the flow equations.
     * \note This value is obtained from the config file, and it is constant
     *       during the computation.
     * \return Kind of upwind convective numerical scheme for the flow equations.
     */
    unsigned short GetKind_Upwind_Flow(void);
    
    /*!
     * \brief Get the kind of upwind convective numerical scheme for the flow equations.
     * \note This value is obtained from the config file, and it is constant
     *       during the computation.
     * \return Kind of upwind convective numerical scheme for the flow equations.
     */
    unsigned short GetKind_Upwind_TNE2(void);
    
    /*!
     * \brief Get the kind of upwind convective numerical scheme for the flow equations.
     * \note This value is obtained from the config file, and it is constant
     *       during the computation.
     * \return Kind of upwind convective numerical scheme for the flow equations.
     */
    unsigned short GetKind_Upwind_AdjTNE2(void);
    
    /*!
     * \brief Get the kind of upwind convective numerical scheme for the adjoint level set equation.
     * \note This value is obtained from the config file, and it is constant
     *       during the computation.
     * \return Kind of upwind convective numerical scheme for the flow equations.
     */
    unsigned short GetKind_Upwind_AdjLevelSet(void);
    
    /*!
     * \brief Get the method for limiting the spatial gradients.
     * \return Method for limiting the spatial gradients.
     */
    unsigned short GetKind_SlopeLimit(void);
    
    /*!
     * \brief Get the method for limiting the spatial gradients.
     * \return Method for limiting the spatial gradients solving the flow equations.
     */
    unsigned short GetKind_SlopeLimit_Flow(void);
    
    /*!
     * \brief Get the method for limiting the spatial gradients.
     * \return Method for limiting the spatial gradients solving the flow equations.
     */
    unsigned short GetKind_SlopeLimit_TNE2(void);
    
    /*!
     * \brief Get the method for limiting the spatial gradients.
     * \return Method for limiting the spatial gradients solving the flow equations.
     */
    unsigned short GetKind_SlopeLimit_AdjTNE2(void);
    
    /*!
     * \brief Get the method for limiting the spatial gradients.
     * \return Method for limiting the spatial gradients solving the turbulent equation.
     */
    unsigned short GetKind_SlopeLimit_Turb(void);
    
    /*!
     * \brief Get the method for limiting the spatial gradients.
     * \return Method for limiting the spatial gradients solving the level set equation.
     */
    unsigned short GetKind_SlopeLimit_AdjLevelSet(void);
    
    /*!
     * \brief Get the method for limiting the spatial gradients.
     * \return Method for limiting the spatial gradients solving the adjoint turbulent equation.
     */
    unsigned short GetKind_SlopeLimit_AdjTurb(void);
    
    /*!
     * \brief Get the method for limiting the spatial gradients.
     * \return Method for limiting the spatial gradients solving the adjoint flow equation.
     */
    unsigned short GetKind_SlopeLimit_AdjFlow(void);
    
    /*!
     * \brief Value of the calibrated constant for the Lax method (center scheme).
     * \note This constant is used in coarse levels and with first order methods.
     * \return Calibrated constant for the Lax method.
     */
    double GetKappa_1st_Flow(void);
    
    /*!
     * \brief Value of the calibrated constant for the JST method (center scheme).
     * \return Calibrated constant for the JST method for the flow equations.
     */
    double GetKappa_2nd_Flow(void);
    
    /*!
     * \brief Value of the calibrated constant for the JST method (center scheme).
     * \return Calibrated constant for the JST method for the flow equations.
     */
    double GetKappa_4th_Flow(void);
    
    /*!
     * \brief Value of the calibrated constant for the Lax method (center scheme).
     * \note This constant is used in coarse levels and with first order methods.
     * \return Calibrated constant for the Lax method.
     */
    double GetKappa_1st_TNE2(void);
    
    /*!
     * \brief Value of the calibrated constant for the JST method (center scheme).
     * \return Calibrated constant for the JST method for the flow equations.
     */
    double GetKappa_2nd_TNE2(void);
    
    /*!
     * \brief Value of the calibrated constant for the JST method (center scheme).
     * \return Calibrated constant for the JST method for the flow equations.
     */
    double GetKappa_4th_TNE2(void);
    
    /*!
     * \brief Get the kind of integration scheme (explicit or implicit)
     *        for the adjoint flow equations.
     * \note This value is obtained from the config file, and it is constant
     *       during the computation.
     * \return Kind of integration scheme for the adjoint flow equations.
     */
    unsigned short GetKind_TimeIntScheme_AdjFlow(void);
    
    /*!
     * \brief Get the kind of integration scheme (explicit or implicit)
     *        for the adjoint flow equations.
     * \note This value is obtained from the config file, and it is constant
     *       during the computation.
     * \return Kind of integration scheme for the adjoint flow equations.
     */
    unsigned short GetKind_TimeIntScheme_AdjTNE2(void);
    
    /*!
     * \brief Get the kind of convective numerical scheme for the adjoint flow
     *        equations (centered or upwind).
     * \note This value is obtained from the config file, and it is constant
     *       during the computation.
     * \return Kind of convective numerical scheme for the adjoint flow equations.
     */
    unsigned short GetKind_ConvNumScheme_AdjFlow(void);
    
    /*!
     * \brief Get the kind of center convective numerical scheme for the adjoint flow equations.
     * \note This value is obtained from the config file, and it is constant
     *       during the computation.
     * \return Kind of center convective numerical scheme for the adjoint flow equations.
     */
    unsigned short GetKind_Centered_AdjFlow(void);
    
    /*!
     * \brief Get the kind of upwind convective numerical scheme for the adjoint flow equations.
     * \note This value is obtained from the config file, and it is constant
     *       during the computation.
     * \return Kind of upwind convective numerical scheme for the adjoint flow equations.
     */
    unsigned short GetKind_Upwind_AdjFlow(void);
    
    /*!
     * \brief Value of the calibrated constant for the high order method (center scheme).
     * \return Calibrated constant for the high order center method for the adjoint flow equations.
     */
    double GetKappa_2nd_AdjFlow(void);
    
    /*!
     * \brief Value of the calibrated constant for the high order method (center scheme).
     * \return Calibrated constant for the high order center method for the adjoint flow equations.
     */
    double GetKappa_4th_AdjFlow(void);
    
    /*!
     * \brief Value of the calibrated constant for the low order method (center scheme).
     * \return Calibrated constant for the low order center method for the adjoint flow equations.
     */
    double GetKappa_1st_AdjFlow(void);
    
    /*!
     * \brief Value of the calibrated constant for the high order method (center scheme).
     * \return Calibrated constant for the high order center method for the adjoint flow equations.
     */
    double GetKappa_2nd_AdjTNE2(void);
    
    /*!
     * \brief Value of the calibrated constant for the high order method (center scheme).
     * \return Calibrated constant for the high order center method for the adjoint flow equations.
     */
    double GetKappa_4th_AdjTNE2(void);
    
    /*!
     * \brief Value of the calibrated constant for the low order method (center scheme).
     * \return Calibrated constant for the low order center method for the adjoint flow equations.
     */
    double GetKappa_1st_AdjTNE2(void);
    
    /*!
     * \brief Get the kind of integration scheme (explicit or implicit)
     *        for the linearized flow equations.
     * \note This value is obtained from the config file, and it is constant
     *       during the computation.
     * \return Kind of integration scheme for the linearized flow equations.
     */
    unsigned short GetKind_TimeIntScheme_LinFlow(void);
    
    /*!
     * \brief Get the kind of convective numerical scheme for the linearized flow
     *        equations (centered or upwind).
     * \note This value is obtained from the config file, and it is constant
     *       during the computation.
     * \return Kind of convective numerical scheme for the linearized flow equations.
     */
    unsigned short GetKind_ConvNumScheme_LinFlow(void);
    
    /*!
     * \brief Get the kind of center convective numerical scheme for the linearized flow equations.
     * \note This value is obtained from the config file, and it is constant
     *       during the computation.
     * \return Kind of center convective numerical scheme for the linearized flow equations.
     */
    unsigned short GetKind_Centered_LinFlow(void);
    
    /*!
     * \brief Get the kind of upwind convective numerical scheme for the linearized flow equations.
     * \note This value is obtained from the config file, and it is constant
     *       during the computation.
     * \return Kind of upwind convective numerical scheme for the linearized flow equations.
     */
    unsigned short GetKind_Upwind_LinFlow(void);
    
    /*!
     * \brief Value of the calibrated constant for the high order method (center scheme).
     * \return Calibrated constant for the high order center method for the linearized flow equations.
     */
    double GetKappa_4th_LinFlow(void);
    
    /*!
     * \brief Value of the calibrated constant for the low order method (center scheme).
     * \return Calibrated constant for the low order center method for the linearized flow equations.
     */
    double GetKappa_1st_LinFlow(void);
    
    /*!
     * \brief Get the kind of integration scheme (implicit)
     *        for the turbulence equations.
     * \note This value is obtained from the config file, and it is constant
     *       during the computation.
     * \return Kind of integration scheme for the turbulence equations.
     */
    unsigned short GetKind_TimeIntScheme_Turb(void);
    
    /*!
     * \brief Get the kind of integration scheme (implicit)
     *        for the level set equations.
     * \note This value is obtained from the config file, and it is constant
     *       during the computation.
     * \return Kind of integration scheme for the level set equations.
     */
    unsigned short GetKind_TimeIntScheme_AdjLevelSet(void);
    
    /*!
     * \brief Get the kind of convective numerical scheme for the turbulence
     *        equations (upwind).
     * \note This value is obtained from the config file, and it is constant
     *       during the computation.
     * \return Kind of convective numerical scheme for the turbulence equations.
     */
    unsigned short GetKind_ConvNumScheme_Turb(void);
    
    /*!
     * \brief Get the kind of center convective numerical scheme for the turbulence equations.
     * \note This value is obtained from the config file, and it is constant
     *       during the computation.
     * \return Kind of center convective numerical scheme for the turbulence equations.
     */
    unsigned short GetKind_Centered_Turb(void);
    
    /*!
     * \brief Get the kind of upwind convective numerical scheme for the turbulence equations.
     * \note This value is obtained from the config file, and it is constant
     *       during the computation.
     * \return Kind of upwind convective numerical scheme for the turbulence equations.
     */
    unsigned short GetKind_Upwind_Turb(void);
    
    /*!
     * \brief Get the kind of integration scheme (explicit or implicit)
     *        for the adjoint turbulence equations.
     * \note This value is obtained from the config file, and it is constant
     *       during the computation.
     * \return Kind of integration scheme for the adjoint turbulence equations.
     */
    unsigned short GetKind_TimeIntScheme_AdjTurb(void);
    
    /*!
     * \brief Get the kind of convective numerical scheme for the adjoint turbulence
     *        equations (centered or upwind).
     * \note This value is obtained from the config file, and it is constant
     *       during the computation.
     * \return Kind of convective numerical scheme for the adjoint turbulence equations.
     */
    unsigned short GetKind_ConvNumScheme_AdjTurb(void);
    
    /*!
     * \brief Get the kind of center convective numerical scheme for the adjoint turbulence equations.
     * \note This value is obtained from the config file, and it is constant
     *       during the computation.
     * \return Kind of center convective numerical scheme for the adjoint turbulence equations.
     */
    unsigned short GetKind_Centered_AdjTurb(void);
    
    /*!
     * \brief Get the kind of upwind convective numerical scheme for the adjoint turbulence equations.
     * \note This value is obtained from the config file, and it is constant
     *       during the computation.
     * \return Kind of upwind convective numerical scheme for the adjoint turbulence equations.
     */
    unsigned short GetKind_Upwind_AdjTurb(void);
    
    /*!
     * \brief Provides information about the way in which the turbulence will be treated by the
     *        adjoint method.
     * \return <code>FALSE</code> means that the adjoint turbulence equations will be used.
     */
    bool GetFrozen_Visc(void);
    
    /*!
     * \brief Viscous limiter mean flow.
     * \return <code>FALSE</code> means no viscous limiter turb equations.
     */
    bool GetViscous_Limiter_Flow(void);
    
    /*!
     * \brief Viscous limiter turb equations.
     * \return <code>FALSE</code> means no viscous limiter turb equations.
     */
    bool GetViscous_Limiter_Turb(void);
    
    /*!
     * \brief Provides information about if the sharp edges are going to be removed from the sensitivity.
     * \return <code>FALSE</code> means that the sharp edges will be removed from the sensitivity.
     */
    bool GetSens_Remove_Sharp(void);
    
    /*!
     * \brief Get the kind of inlet boundary condition treatment (total conditions or mass flow).
     * \return Kind of inlet boundary condition.
     */
    unsigned short GetKind_Inlet(void);
    
    /*!
     * \brief Get the number of sections.
     * \return Number of sections
     */
    unsigned short GetnSections(void);
    
    /*!
     * \brief Get the number of sections for computing internal volume.
     * \return Number of sections for computing internal volume.
     */
    unsigned short GetnVolSections(void);
    
    /*!
     * \brief Provides information about the the nodes that are going to be moved on a deformation
     *        volumetric grid deformation.
     * \return <code>TRUE</code> means that only the points on the FFD box will be moved.
     */
    bool GetHold_GridFixed(void);
    
    /*!
     * \brief Get the kind of objective function. There are several options: Drag coefficient,
     *        Lift coefficient, efficiency, etc.
     * \note The objective function will determine the boundary condition of the adjoint problem.
     * \return Kind of objective function.
     */
    unsigned short GetKind_ObjFunc(void);
    
    /*!
     * \brief Get the kind of sensitivity smoothing technique.
     * \return Kind of sensitivity smoothing technique.
     */
    unsigned short GetKind_SensSmooth(void);
    
    /*!
     * \brief Provides information about the time integration, and change the write in the output
     *        files information about the iteration.
     * \return The kind of time integration: Steady state, time stepping method (unsteady) or
     *         dual time stepping method (unsteady).
     */
    unsigned short GetUnsteady_Simulation(void);
    
    /*!
     * \brief Provides the number of species present in the plasma
     * \return: The number of species present in the plasma, read from input file
     */
    unsigned short GetnSpecies(void);
    
    /*!
     * \brief Provides the number of chemical reactions in the chemistry model
     * \return: The number of chemical reactions, read from input file
     */
    unsigned short GetnReactions(void);
    
    /*!
     * \brief Provides the number of chemical reactions in the chemistry model
     * \return: The number of chemical reactions, read from input file
     */
    double GetArrheniusCoeff(unsigned short iReaction);
    
    /*!
     * \brief Provides the number of chemical reactions in the chemistry model
     * \return: The number of chemical reactions, read from input file
     */
    double GetArrheniusEta(unsigned short iReaction);
    
    /*!
     * \brief Provides the number of chemical reactions in the chemistry model
     * \return: The number of chemical reactions, read from input file
     */
    double GetArrheniusTheta(unsigned short iReaction);
    
    /*!
     * \brief Provides the rate controlling temperature exponents for chemistry.
     * \return: Rate controlling temperature exponents.
     */
    double* GetRxnTcf_a(void);
    
    /*!
     * \brief Provides the rate controlling temperature exponents for chemistry.
     * \return: Rate controlling temperature exponents.
     */
    double* GetRxnTcf_b(void);
    
    /*!
     * \brief Provides the rate controlling temperature exponents for chemistry.
     * \return: Rate controlling temperature exponents.
     */
    double* GetRxnTcb_a(void);
    
    /*!
     * \brief Provides the rate controlling temperature exponents for chemistry.
     * \return: Rate controlling temperature exponents.
     */
    double* GetRxnTcb_b(void);
    
    /*!
     * \brief Dissociation potential of species.
     * \return: Dissociation potential.
     */
    double* GetDissociationPot(void);
    
    /*!
     * \brief Provides the number of rotational modes of energy storage
     * \return: Vector of rotational mode count
     */
    double* GetRotationModes(void);
    
    /*!
     * \brief Provides the characteristic vibrational temperature for calculating e_vib
     * \return: Vector of characteristic vibrational temperatures [K]
     */
    double* GetCharVibTemp(void);
    
    /*!
     * \brief Provides the characteristic electronic temperature for calculating e_el
     * \return: Vector of characteristic vibrational temperatures [K]
     */
    double** GetCharElTemp(void);
    
    /*!
     * \brief Provides the degeneracy of electron states for calculating e_el
     * \return: Vector of characteristic vibrational temperatures [K]
     */
    double** GetElDegeneracy(void);
    
    /*!
     * \brief Provides number electron states for calculating e_el
     * \return: Vector of number of electron states for each species
     */
    unsigned short* GetnElStates(void);
    
    
    /*!
     * \brief Provides the thermodynamic reference temperatures from the JANAF tables
     * \return: Vector of reference temperatures [K]
     */
    double* GetRefTemperature(void);
    
    /*!
     * \brief Provides the characteristic vibrational temperature for calculating e_vib
     * \return: The number of chemical reactions, read from input file
     */
    double GetCharVibTemp(unsigned short iSpecies);
    
    /*!
     * \brief Provides a table of equilibrium constants for a particular chemical reaction for a supplied gas model.
     * \return: Matrix of reaction constants
     */
    void GetChemistryEquilConstants(double **RxnConstantTable, unsigned short iReaction);
    
    /*!
     * \brief Provides the molar mass of each species present in multi species fluid
     * \return: Vector of molar mass of each species in kg/kmol
     */
    double* GetMolar_Mass(void);
    
    /*!
     * \brief Provides the molar mass of each species present in multi species fluid
     * \return: Mass of each species in Kg
     */
    double GetMolar_Mass(unsigned short iSpecies);
    
    /*!
     * \brief Retrieves the number of monatomic species in the multicomponent gas.
     * \return: Number of monatomic species.
     */
    //unsigned short GetnMonatomics(void);
    
    /*!
     * \brief Retrieves the number of monatomic species in the multicomponent gas.
     * \return: Number of monatomic species.
     */
    //unsigned short GetnDiatomics(void);
    
    /*!
     * \brief Provides the molar mass of each species present in multi species fluid
     * \return: Molar mass of the specified gas consituent [kg/kmol]
     */
    double GetInitial_Gas_Composition(unsigned short iSpecies);
    
    /*!
     * \brief Retrieves the multi-species fluid mixture molar mass.
     * \return: Molar mass of the fluid mixture
     */
    //double GetMixtureMolar_Mass();
    
    /*!
     * \brief Provides the formation enthalpy of the specified species at standard conditions
     * \return: Enthalpy of formation
     */
    double* GetEnthalpy_Formation(void);
    
    /*!
     * \brief Provides the formation enthalpy of the specified species at standard conditions
     * \return: Enthalpy of formation
     */
    double GetEnthalpy_Formation(unsigned short iSpecies);
    
    /*!
     * \brief Provides the restart information.
     * \return Restart information, if <code>TRUE</code> then the code will use the solution as restart.
     */
    bool GetRestart(void);
    
    /*!
     * \brief Provides the number of varaibles.
     * \return Number of variables.
     */
    //unsigned short GetnVar(void);
    
    /*!
     * \brief Provides the number of varaibles.
     * \return Number of variables.
     */
    unsigned short GetnZone(void);
    
    /*!
     * \brief Provides the number of varaibles.
     * \return Number of variables.
     */
    unsigned short GetiZone(void);
    
    /*!
     * \brief For some problems like adjoint or the linearized equations it
     *		  is necessary to restart the flow solution.
     * \return Flow restart information, if <code>TRUE</code> then the code will restart the flow solution.
     */
    
    bool GetRestart_Flow(void);
    
    /*!
     * \brief Indicates whether electron gas is present in the gas mixture.
     */
    bool GetIonization(void);
    
    /*!
     * \brief Information about computing and plotting the equivalent area distribution.
     * \return <code>TRUE</code> or <code>FALSE</code>  depending if we are computing the equivalent area.
     */
    bool GetEquivArea(void);
    
    /*!
     * \brief Information about computing and plotting the equivalent area distribution.
     * \return <code>TRUE</code> or <code>FALSE</code>  depending if we are computing the equivalent area.
     */
    bool GetInvDesign_Cp(void);
    
    /*!
     * \brief Information about computing and plotting the equivalent area distribution.
     * \return <code>TRUE</code> or <code>FALSE</code>  depending if we are computing the equivalent area.
     */
    bool GetInvDesign_HeatFlux(void);
    
    /*!
     * \brief Get name of the input grid.
     * \return File name of the input grid.
     */
    string GetMesh_FileName(void);
    
    /*!
     * \brief Get name of the output grid, this parameter is important for grid
     *        adaptation and deformation.
     * \return File name of the output grid.
     */
    string GetMesh_Out_FileName(void);
    
    /*!
     * \brief Get the name of the file with the solution of the flow problem.
     * \return Name of the file with the solution of the flow problem.
     */
    string GetSolution_FlowFileName(void);
    
    /*!
     * \brief Get the name of the file with the solution of the linearized flow problem.
     * \return Name of the file with the solution of the linearized flow problem.
     */
    string GetSolution_LinFileName(void);
    
    /*!
     * \brief Get the name of the file with the solution of the adjoint flow problem
     *		  with drag objective function.
     * \return Name of the file with the solution of the adjoint flow problem with
     *         drag objective function.
     */
    string GetSolution_AdjFileName(void);
    
    /*!
     * \brief Get the name of the file with the residual of the problem.
     * \return Name of the file with the residual of the problem.
     */
    //string GetResidual_FileName(void);
    
    /*!
     * \brief Get the format of the input/output grid.
     * \return Format of the input/output grid.
     */
    unsigned short GetMesh_FileFormat(void);
    
    /*!
     * \brief Get the format of the output solution.
     * \return Format of the output solution.
     */
    unsigned short GetOutput_FileFormat(void);
    
    /*!
     * \brief Get the name of the file with the convergence history of the problem.
     * \return Name of the file with convergence history of the problem.
     */
    string GetConv_FileName(void);
    
    /*!
     * \brief Get the name of the file with the forces breakdown of the problem.
     * \return Name of the file with forces breakdown of the problem.
     */
    string GetBreakdown_FileName(void);
    
    /*!
     * \brief Get the name of the file with the flow variables.
     * \return Name of the file with the primitive variables.
     */
    string GetFlow_FileName(void);
    
    /*!
     * \brief Get the name of the file with the structure variables.
     * \return Name of the file with the structure variables.
     */
    string GetStructure_FileName(void);
    
    /*!
     * \brief Get the name of the file with the structure variables.
     * \return Name of the file with the structure variables.
     */
    string GetSurfStructure_FileName(void);
    
    /*!
     * \brief Get the name of the file with the structure variables.
     * \return Name of the file with the structure variables.
     */
    string GetSurfWave_FileName(void);
    
    /*!
     * \brief Get the name of the file with the structure variables.
     * \return Name of the file with the structure variables.
     */
    string GetSurfHeat_FileName(void);
    
    /*!
     * \brief Get the name of the file with the wave variables.
     * \return Name of the file with the wave variables.
     */
    string GetWave_FileName(void);
    
    /*!
     * \brief Get the name of the file with the wave variables.
     * \return Name of the file with the wave variables.
     */
    string GetHeat_FileName(void);
    
    /*!
     * \brief Get the name of the file with the adjoint wave variables.
     * \return Name of the file with the adjoint wave variables.
     */
    string GetAdjWave_FileName(void);
    
    /*!
     * \brief Get the name of the restart file for the wave variables.
     * \return Name of the restart file for the flow variables.
     */
    string GetRestart_WaveFileName(void);
    
    /*!
     * \brief Get the name of the restart file for the heat variables.
     * \return Name of the restart file for the flow variables.
     */
    string GetRestart_HeatFileName(void);
    
    /*!
     * \brief Get the name of the restart file for the flow variables.
     * \return Name of the restart file for the flow variables.
     */
    string GetRestart_FlowFileName(void);
    
    /*!
     * \brief Get the name of the restart file for the linearized flow variables.
     * \return Name of the restart file for the linearized flow variables.
     */
    string GetRestart_LinFileName(void);
    
    /*!
     * \brief Get the name of the restart file for the adjoint variables (drag objective function).
     * \return Name of the restart file for the adjoint variables (drag objective function).
     */
    string GetRestart_AdjFileName(void);
    
    /*!
     * \brief Get the name of the file with the adjoint variables.
     * \return Name of the file with the adjoint variables.
     */
    string GetAdj_FileName(void);
    
    /*!
     * \brief Get the name of the file with the linearized flow variables.
     * \return Name of the file with the linearized flow variables.
     */
    string GetLin_FileName(void);
    
    /*!
     * \brief Get the name of the file with the gradient of the objective function.
     * \return Name of the file with the gradient of the objective function.
     */
    string GetObjFunc_Grad_FileName(void);
    
    /*!
     * \brief Get the name of the file with the gradient of the objective function.
     * \return Name of the file with the gradient of the objective function.
     */
    string GetObjFunc_Value_FileName(void);
    
    /*!
     * \brief Get the name of the file with the surface information for the flow problem.
     * \return Name of the file with the surface information for the flow problem.
     */
    string GetSurfFlowCoeff_FileName(void);
    
    /*!
     * \brief Get the name of the file with the surface information for the adjoint problem.
     * \return Name of the file with the surface information for the adjoint problem.
     */
    string GetSurfAdjCoeff_FileName(void);
    
    /*!
     * \brief Get the name of the file with the surface information for the linearized flow problem.
     * \return Name of the file with the surface information for the linearized flow problem.
     */
    string GetSurfLinCoeff_FileName(void);
    
    /*!
     * \brief Augment the input filename with the iteration number for an unsteady file.
     * \param[in] val_filename - String value of the base filename.
     * \param[in] val_iter - Unsteady iteration number or time spectral instance.
     * \return Name of the file with the iteration numer for an unsteady solution file.
     */
    string GetUnsteady_FileName(string val_filename, int val_iter);
    
    /*!
     * \brief Append the input filename string with the appropriate objective function extension.
     * \param[in] val_filename - String value of the base filename.
     * \return Name of the file with the appropriate objective function extension.
     */
    string GetObjFunc_Extension(string val_filename);
    
    /*!
     * \brief Get functional that is going to be used to evaluate the residual flow convergence.
     * \return Functional that is going to be used to evaluate the residual flow convergence.
     */
    unsigned short GetResidual_Func_Flow(void);
    
    /*!
     * \brief Get functional that is going to be used to evaluate the flow convergence.
     * \return Functional that is going to be used to evaluate the flow convergence.
     */
    unsigned short GetCauchy_Func_Flow(void);
    
    /*!
     * \brief Get functional that is going to be used to evaluate the adjoint flow convergence.
     * \return Functional that is going to be used to evaluate the adjoint flow convergence.
     */
    unsigned short GetCauchy_Func_AdjFlow(void);
    
    /*!
     * \brief Get functional that is going to be used to evaluate the linearized flow convergence.
     * \return Functional that is going to be used to evaluate the linearized flow convergence.
     */
    unsigned short GetCauchy_Func_LinFlow(void);
    
    /*!
     * \brief Get the number of iterations that are considered in the Cauchy convergence criteria.
     * \return Number of elements in the Cauchy criteria.
     */
    unsigned short GetCauchy_Elems(void);
    
    /*!
     * \brief Get the number of iterations that are not considered in the convergence criteria.
     * \return Number of iterations before starting with the convergence criteria.
     */
    unsigned long GetStartConv_Iter(void);
    
    /*!
     * \brief Get the value of convergence criteria for the Cauchy method in the direct,
     *        adjoint or linearized problem.
     * \return Value of the convergence criteria.
     */
    double GetCauchy_Eps(void);
    
    /*!
     * \brief If we are prforming an unsteady simulation, there is only
     *        one value of the time step for the complete simulation.
     * \return Value of the time step in an unsteady simulation (non dimensional).
     */
    double GetDelta_UnstTimeND(void);
    
    /*!
     * \brief If we are prforming an unsteady simulation, there is only
     *        one value of the time step for the complete simulation.
     * \return Value of the time step in an unsteady simulation (non dimensional).
     */
    double GetTotal_UnstTimeND(void);
    
    /*!
     * \brief If we are prforming an unsteady simulation, there is only
     *        one value of the time step for the complete simulation.
     * \return Value of the time step in an unsteady simulation.
     */
    double GetDelta_UnstTime(void);
    
    /*!
     * \brief Set the value of the unsteadty time step using the CFL number.
     * \param[in] val_delta_unsttimend - Value of the unsteady time step using CFL number.
     */
    void SetDelta_UnstTimeND(double val_delta_unsttimend);
    
    /*!
     * \brief If we are performing an unsteady simulation, this is the
     * 	value of max physical time for which we run the simulation
     * \return Value of the physical time in an unsteady simulation.
     */
    double GetTotal_UnstTime(void);
    
    /*!
     * \brief If we are performing an unsteady simulation, this is the
     * 	value of current time.
     * \return Value of the physical time in an unsteady simulation.
     */
    double GetCurrent_UnstTime(void);
    
    /*!
     * \brief Divide the rectbles and hexahedron.
     * \return <code>TRUE</code> if the elements must be divided; otherwise <code>FALSE</code>.
     */
    bool GetEngine_Intake(void);
    
    /*!
     * \brief Value of the design variable step, we use this value in design problems.
     * \param[in] val_dv - Number of the design variable that we want to read.
     * \return Design variable step.
     */
    double GetDV_Value(unsigned short val_dv);
    
    /*!
     * \brief Get information about the grid movement.
     * \return <code>TRUE</code> if there is a grid movement; otherwise <code>FALSE</code>.
     */
    bool GetGrid_Movement(void);
    
    /*!
     * \brief Get the type of dynamic mesh motion.
     * \param[in] val_iZone - Number for the current zone in the mesh (each zone has independent motion).
     * \return Type of dynamic mesh motion.
     */
    unsigned short GetKind_GridMovement(unsigned short val_iZone);
    
    /*!
     * \brief Set the type of dynamic mesh motion.
     * \param[in] val_iZone - Number for the current zone in the mesh (each zone has independent motion).
     * \param[in] motion_Type - Specify motion type.
     */
    void SetKind_GridMovement(unsigned short val_iZone, unsigned short motion_Type);
    
    /*!
     * \brief Get the mach number based on the mesh velocity and freestream quantities.
     * \return Mach number based on the mesh velocity and freestream quantities.
     */
    double GetMach_Motion(void);
    
    /*!
     * \brief Get x-coordinate of the mesh motion origin.
     * \param[in] val_iZone - Number for the current zone in the mesh (each zone has independent motion).
     * \return X-coordinate of the mesh motion origin.
     */
    double GetMotion_Origin_X(unsigned short val_iZone);
    
    /*!
     * \brief Get y-coordinate of the mesh motion origin
     * \param[in] val_iZone - Number for the current zone in the mesh (each zone has independent motion).
     * \return Y-coordinate of the mesh motion origin.
     */
    double GetMotion_Origin_Y(unsigned short val_iZone);
    
    /*!
     * \brief Get z-coordinate of the mesh motion origin
     * \param[in] val_iZone - Number for the current zone in the mesh (each zone has independent motion).
     * \return Z-coordinate of the mesh motion origin.
     */
    double GetMotion_Origin_Z(unsigned short val_iZone);
    
    /*!
     * \brief Set x-coordinate of the mesh motion origin.
     * \param[in] val_iZone - Number for the current zone in the mesh (each zone has independent motion).
     * \param[in] val_origin - New x-coordinate of the mesh motion origin.
     */
    void SetMotion_Origin_X(unsigned short val_iZone, double val_origin);
    
    /*!
     * \brief Set y-coordinate of the mesh motion origin
     * \param[in] val_iZone - Number for the current zone in the mesh (each zone has independent motion).
     * \param[in] val_origin - New y-coordinate of the mesh motion origin.
     */
    void SetMotion_Origin_Y(unsigned short val_iZone, double val_origin);
    
    /*!
     * \brief Set z-coordinate of the mesh motion origin
     * \param[in] val_iZone - Number for the current zone in the mesh (each zone has independent motion).
     * \param[in] val_origin - New y-coordinate of the mesh motion origin.
     */
    void SetMotion_Origin_Z(unsigned short val_iZone, double val_origin);
    
    /*!
     * \brief Get the translational velocity of the mesh in the x-direction.
     * \param[in] val_iZone - Number for the current zone in the mesh (each zone has independent motion).
     * \return Translational velocity of the mesh in the x-direction.
     */
    double GetTranslation_Rate_X(unsigned short val_iZone);
    
    /*!
     * \brief Get the translational velocity of the mesh in the y-direction.
     * \param[in] val_iZone - Number for the current zone in the mesh (each zone has independent motion).
     * \return Translational velocity of the mesh in the y-direction.
     */
    double GetTranslation_Rate_Y(unsigned short val_iZone);
    
    /*!
     * \brief Get the translational velocity of the mesh in the z-direction.
     * \param[in] val_iZone - Number for the current zone in the mesh (each zone has independent motion).
     * \return Translational velocity of the mesh in the z-direction.
     */
    double GetTranslation_Rate_Z(unsigned short val_iZone);
    
    /*!
     * \brief Get the angular velocity of the mesh about the x-axis.
     * \param[in] val_iZone - Number for the current zone in the mesh (each zone has independent motion).
     * \return Angular velocity of the mesh about the x-axis.
     */
    double GetRotation_Rate_X(unsigned short val_iZone);
    
    /*!
     * \brief Get the angular velocity of the mesh about the y-axis.
     * \param[in] val_iZone - Number for the current zone in the mesh (each zone has independent motion).
     * \return Angular velocity of the mesh about the y-axis.
     */
    double GetRotation_Rate_Y(unsigned short val_iZone);
    
    /*!
     * \brief Get the angular velocity of the mesh about the z-axis.
     * \param[in] val_iZone - Number for the current zone in the mesh (each zone has independent motion).
     * \return Angular velocity of the mesh about the z-axis.
     */
    double GetRotation_Rate_Z(unsigned short val_iZone);
    
    /*!
     * \brief Get the angular frequency of a mesh pitching about the x-axis.
     * \param[in] val_iZone - Number for the current zone in the mesh (each zone has independent motion).
     * \return Angular frequency of a mesh pitching about the x-axis.
     */
    double GetPitching_Omega_X(unsigned short val_iZone);
    
    /*!
     * \brief Get the angular frequency of a mesh pitching about the y-axis.
     * \param[in] val_iZone - Number for the current zone in the mesh (each zone has independent motion).
     * \return Angular frequency of a mesh pitching about the y-axis.
     */
    double GetPitching_Omega_Y(unsigned short val_iZone);
    
    /*!
     * \brief Get the angular frequency of a mesh pitching about the z-axis.
     * \param[in] val_iZone - Number for the current zone in the mesh (each zone has independent motion).
     * \return Angular frequency of a mesh pitching about the z-axis.
     */
    double GetPitching_Omega_Z(unsigned short val_iZone);
    
    /*!
     * \brief Get the pitching amplitude about the x-axis.
     * \param[in] val_iZone - Number for the current zone in the mesh (each zone has independent motion).
     * \return Pitching amplitude about the x-axis.
     */
    double GetPitching_Ampl_X(unsigned short val_iZone);
    
    /*!
     * \brief Get the pitching amplitude about the y-axis.
     * \param[in] val_iZone - Number for the current zone in the mesh (each zone has independent motion).
     * \return Pitching amplitude about the y-axis.
     */
    double GetPitching_Ampl_Y(unsigned short val_iZone);
    
    /*!
     * \brief Get the pitching amplitude about the z-axis.
     * \param[in] val_iZone - Number for the current zone in the mesh (each zone has independent motion).
     * \return Pitching amplitude about the z-axis.
     */
    double GetPitching_Ampl_Z(unsigned short val_iZone);
    
    /*!
     * \brief Get the pitching phase offset about the x-axis.
     * \param[in] val_iZone - Number for the current zone in the mesh (each zone has independent motion).
     * \return Pitching phase offset about the x-axis.
     */
    double GetPitching_Phase_X(unsigned short val_iZone);
    
    /*!
     * \brief Get the pitching phase offset about the y-axis.
     * \param[in] val_iZone - Number for the current zone in the mesh (each zone has independent motion).
     * \return Pitching phase offset about the y-axis.
     */
    double GetPitching_Phase_Y(unsigned short val_iZone);
    
    /*!
     * \brief Get the pitching phase offset about the z-axis.
     * \param[in] val_iZone - Number for the current zone in the mesh (each zone has independent motion).
     * \return Pitching phase offset about the z-axis.
     */
    double GetPitching_Phase_Z(unsigned short val_iZone);
    
    /*!
     * \brief Get the angular frequency of a mesh plunging in the x-direction.
     * \param[in] val_iZone - Number for the current zone in the mesh (each zone has independent motion).
     * \return Angular frequency of a mesh plunging in the x-direction.
     */
    double GetPlunging_Omega_X(unsigned short val_iZone);
    
    /*!
     * \brief Get the angular frequency of a mesh plunging in the y-direction.
     * \param[in] val_iZone - Number for the current zone in the mesh (each zone has independent motion).
     * \return Angular frequency of a mesh plunging in the y-direction.
     */
    double GetPlunging_Omega_Y(unsigned short val_iZone);
    
    /*!
     * \brief Get the angular frequency of a mesh plunging in the z-direction.
     * \param[in] val_iZone - Number for the current zone in the mesh (each zone has independent motion).
     * \return Angular frequency of a mesh plunging in the z-direction.
     */
    double GetPlunging_Omega_Z(unsigned short val_iZone);
    
    /*!
     * \brief Get the plunging amplitude in the x-direction.
     * \param[in] val_iZone - Number for the current zone in the mesh (each zone has independent motion).
     * \return Plunging amplitude in the x-direction.
     */
    double GetPlunging_Ampl_X(unsigned short val_iZone);
    
    /*!
     * \brief Get the plunging amplitude in the y-direction.
     * \param[in] val_iZone - Number for the current zone in the mesh (each zone has independent motion).
     * \return Plunging amplitude in the y-direction.
     */
    double GetPlunging_Ampl_Y(unsigned short val_iZone);
    
    /*!
     * \brief Get the plunging amplitude in the z-direction.
     * \param[in] val_iZone - Number for the current zone in the mesh (each zone has independent motion).
     * \return Plunging amplitude in the z-direction.
     */
    double GetPlunging_Ampl_Z(unsigned short val_iZone);
    
    /*!
     * \brief Get if we should update the motion origin.
     * \param[in] val_marker - Value of the marker in which we are interested.
     * \return yes or no to update motion origin.
     */
    unsigned short GetMoveMotion_Origin(unsigned short val_marker);
    
    /*!
     * \brief Get the minimum value of Beta for Roe-Turkel preconditioner
     * \return the minimum value of Beta for Roe-Turkel preconditioner
     */
    double GetminTurkelBeta();
    
    /*!
     * \brief Get the minimum value of Beta for Roe-Turkel preconditioner
     * \return the minimum value of Beta for Roe-Turkel preconditioner
     */
    double GetmaxTurkelBeta();
    
    /*!
     * \brief Get information about the adibatic wall condition
     * \return <code>TRUE</code> if it is a adiabatic wall condition; otherwise <code>FALSE</code>.
     */
    //bool GetAdiabaticWall(void);
    
    /*!
     * \brief Get information about the isothermal wall condition
     * \return <code>TRUE</code> if it is a isothermal wall condition; otherwise <code>FALSE</code>.
     */
    //bool GetIsothermalWall(void);
    
    /*!
     * \brief Get information about the catalytic wall condition
     * \return <code>TRUE</code> if it is a catalytic wall condition; otherwise <code>FALSE</code>.
     */
    //bool GetCatalyticWall(void);
    
    /*!
     * \brief Get information about the Low Mach Preconditioning
     * \return <code>TRUE</code> if we are using low Mach preconditioner; otherwise <code>FALSE</code>.
     */
    bool Low_Mach_Preconditioning(void);
    
    /*!
     * \brief Get information about the poisson solver condition
     * \return <code>TRUE</code> if it is a poisson solver condition; otherwise <code>FALSE</code>.
     */
    bool GetPoissonSolver(void);
    
    /*!
     * \brief Get information about the gravity force.
     * \return <code>TRUE</code> if it uses the gravity force; otherwise <code>FALSE</code>.
     */
    bool GetGravityForce(void);
    
    /*!
     * \brief Get information about the rotational frame.
     * \return <code>TRUE</code> if there is a rotational frame; otherwise <code>FALSE</code>.
     */
    bool GetRotating_Frame(void);
    
    /*!
     * \brief Get information about the axisymmetric frame.
     * \return <code>TRUE</code> if there is a rotational frame; otherwise <code>FALSE</code>.
     */
    bool GetAxisymmetric(void);
    
    /*!
     * \brief Get information about the axisymmetric frame.
     * \return <code>TRUE</code> if there is a rotational frame; otherwise <code>FALSE</code>.
     */
    bool GetDebugMode(void);
    
    /*!
     * \brief Get information about there is a smoothing of the grid coordinates.
     * \return <code>TRUE</code> if there is smoothing of the grid coordinates; otherwise <code>FALSE</code>.
     */
    bool GetAdaptBoundary(void);
    
    /*!
     * \brief Get information about there is a smoothing of the grid coordinates.
     * \return <code>TRUE</code> if there is smoothing of the grid coordinates; otherwise <code>FALSE</code>.
     */
    bool GetSmoothNumGrid(void);
    
    /*!
     * \brief Set information about there is a smoothing of the grid coordinates.
     * \param[in] val_smoothnumgrid - <code>TRUE</code> if there is smoothing of the grid coordinates; otherwise <code>FALSE</code>.
     */
    void SetSmoothNumGrid(bool val_smoothnumgrid);
    
    /*!
     * \brief Subtract one to the index of the finest grid (full multigrid strategy).
     * \return Change the index of the finest grid.
     */
    void SubtractFinestMesh(void);
    
    /*!
     * \brief Obtain the kind of design variable.
     * \param[in] val_dv - Number of the design variable that we want to read.
     * \return Design variable identification.
     */
    unsigned short GetDesign_Variable(unsigned short val_dv);
    
    /*!
     * \brief Obtain the kind of convergence criteria to establish the convergence of the CFD code.
     * \return Kind of convergence criteria.
     */
    unsigned short GetConvCriteria(void);
    
    /*!
     * \brief Get the index in the config information of the marker <i>val_marker</i>.
     * \note When we read the config file, it stores the markers in a particular vector.
     * \return Index in the config information of the marker <i>val_marker</i>.
     */
    unsigned short GetMarker_CfgFile_TagBound(string val_marker);
    
    /*!
     * \brief Get the name in the config information of the marker number <i>val_marker</i>.
     * \note When we read the config file, it stores the markers in a particular vector.
     * \return Name of the marker in the config information of the marker <i>val_marker</i>.
     */
    string GetMarker_CfgFile_TagBound(unsigned short val_marker);
    
    /*!
     * \brief Get the boundary information (kind of boundary) in the config information of the marker <i>val_marker</i>.
     * \return Kind of boundary in the config information of the marker <i>val_marker</i>.
     */
    unsigned short GetMarker_CfgFile_KindBC(string val_marker);
    
    /*!
     * \brief Get the monitoring information from the config definition for the marker <i>val_marker</i>.
     * \return Monitoring information of the boundary in the config information for the marker <i>val_marker</i>.
     */
    unsigned short GetMarker_CfgFile_Monitoring(string val_marker);
    
    /*!
     * \brief Get the monitoring information from the config definition for the marker <i>val_marker</i>.
     * \return Monitoring information of the boundary in the config information for the marker <i>val_marker</i>.
     */
    unsigned short GetMarker_CfgFile_GeoEval(string val_marker);
    
    /*!
     * \brief Get the monitoring information from the config definition for the marker <i>val_marker</i>.
     * \return Monitoring information of the boundary in the config information for the marker <i>val_marker</i>.
     */
    unsigned short GetMarker_CfgFile_Designing(string val_marker);
    
    /*!
     * \brief Get the plotting information from the config definition for the marker <i>val_marker</i>.
     * \return Plotting information of the boundary in the config information for the marker <i>val_marker</i>.
     */
    unsigned short GetMarker_CfgFile_Plotting(string val_marker);
    
    /*!
     * \brief Get the 1-D output (ie, averaged pressure) information from the config definition for the marker <i>val_marker</i>.
     * \return 1D output information of the boundary in the config information for the marker <i>val_marker</i>.
     */
    unsigned short GetMarker_CfgFile_Out_1D(string val_marker);
    
    /*!
     * \brief Get the DV information from the config definition for the marker <i>val_marker</i>.
     * \return DV information of the boundary in the config information for the marker <i>val_marker</i>.
     */
    unsigned short GetMarker_CfgFile_DV(string val_marker);
    
    /*!
     * \brief Get the motion information from the config definition for the marker <i>val_marker</i>.
     * \return Motion information of the boundary in the config information for the marker <i>val_marker</i>.
     */
    unsigned short GetMarker_CfgFile_Moving(string val_marker);
    
    /*!
     * \brief Get the periodic information from the config definition of the marker <i>val_marker</i>.
     * \return Periodic information of the boundary in the config information of the marker <i>val_marker</i>.
     */
    unsigned short GetMarker_CfgFile_PerBound(string val_marker);
    
    /*!
     * \brief Determines if problem is adjoint
     * \return true if Adjoint
     */
    bool GetAdjoint(void);
    
    /*!
     * \brief Determines if problem is viscous
     * \return true if Viscous
     */
    bool GetViscous(void);
    
    /*!
     * \brief Provides the index of the solution in the container.
     * \param[in] val_eqsystem - Equation that is being solved.
     * \return Index on the solution container.
     */
    unsigned short GetContainerPosition(unsigned short val_eqsystem);
    
    /*!
     * \brief Value of the order of magnitude reduction of the residual.
     * \return Value of the order of magnitude reduction of the residual.
     */
    double GetOrderMagResidual(void);
    
    /*!
     * \brief Value of the minimum residual value (log10 scale).
     * \return Value of the minimum residual value (log10 scale).
     */
    double GetMinLogResidual(void);
    
    /*!
     * \brief Value of the damping factor for the engine inlet bc.
     * \return Value of the damping factor.
     */
    double GetDamp_Engine_Inflow(void);
    
    /*!
     * \brief Value of the damping factor for the engine bleed inlet bc.
     * \return Value of the damping factor.
     */
    double GetDamp_Engine_Bleed(void);
    
    /*!
     * \brief Value of the damping factor for the engine exhaust inlet bc.
     * \return Value of the damping factor.
     */
    double GetDamp_Engine_Exhaust(void);
    
    /*!
     * \brief Value of the damping factor for the residual restriction.
     * \return Value of the damping factor.
     */
    double GetDamp_Res_Restric(void);
    
    /*!
     * \brief Value of the damping factor for the correction prolongation.
     * \return Value of the damping factor.
     */
    double GetDamp_Correc_Prolong(void);
    
    /*!
     * \brief Value of the position of the Near Field (y coordinate for 2D, and z coordinate for 3D).
     * \return Value of the Near Field position.
     */
    double GetPosition_Plane(void);
    
    /*!
     * \brief Value of the weight of the drag coefficient in the Sonic Boom optimization.
     * \return Value of the weight of the drag coefficient in the Sonic Boom optimization.
     */
    double GetWeightCd(void);
    
    /*!
     * \brief Value of the azimuthal line to fix due to a misalignments of the nearfield.
     * \return Azimuthal line to fix due to a misalignments of the nearfield.
     */
    double GetFixAzimuthalLine(void);
    
    /*!
     * \brief Set the global parameters of each simulation for each runtime system.
     * \param[in] val_solver - Solver of the simulation.
     * \param[in] val_system - Runtime system that we are solving.
     */
    void SetGlobalParam(unsigned short val_solver, unsigned short val_system, unsigned long val_extiter);
    
    /*!
     * \brief Center of rotation for a rotational periodic boundary.
     */
    double *GetPeriodicRotCenter(string val_marker);
    
    /*!
     * \brief Angles of rotation for a rotational periodic boundary.
     */
    double *GetPeriodicRotAngles(string val_marker);
    
    /*!
     * \brief Translation vector for a rotational periodic boundary.
     */
    double *GetPeriodicTranslation(string val_marker);
    
    /*!
     * \brief Get the rotationally periodic donor marker for boundary <i>val_marker</i>.
     * \return Periodic donor marker from the config information for the marker <i>val_marker</i>.
     */
    unsigned short GetMarker_Periodic_Donor(string val_marker);
    
    /*!
     * \brief Get the origin of the actuator disk.
     */
    double* GetActDisk_Origin(string val_marker);
    
    /*!
     * \brief Get the root radius of the actuator disk.
     */
    double GetActDisk_RootRadius(string val_marker);
    
    /*!
     * \brief Get the tip radius of th actuator disk.
     */
    double GetActDisk_TipRadius(string val_marker);
    
    /*!
     * \brief Get the thurst corffient of the actuator disk.
     */
    double GetActDisk_PressJump(string val_marker);
    
    /*!
     * \brief Get the thurst corffient of the actuator disk.
     */
    double GetActDisk_TempJump(string val_marker);
    
    /*!
     * \brief Get the rev / min of the actuator disk.
     */
    double GetActDisk_Omega(string val_marker);
    
    /*!
     * \brief Get the rev / min of the actuator disk.
     */
    unsigned short GetActDisk_Distribution(string val_marker);
    
    /*!
     * \brief Get Actuator Disk Outlet for boundary <i>val_marker</i> (actuator disk inlet).
     * \return Actuator Disk Outlet from the config information for the marker <i>val_marker</i>.
     */
    unsigned short GetMarker_ActDisk_Outlet(string val_marker);
    
    /*!
     * \brief Get the internal index for a moving boundary <i>val_marker</i>.
     * \return Internal index for a moving boundary <i>val_marker</i>.
     */
    unsigned short GetMarker_Moving(string val_marker);
    
    /*!
     * \brief Get the name of the surface defined in the geometry file.
     * \param[in] val_marker - Value of the marker in which we are interested.
     * \return Name that is in the geometry file for the surface that
     *         has the marker <i>val_marker</i>.
     */
    string GetMarker_Moving(unsigned short val_marker);
    
    /*!
     * \brief Set the total number of SEND_RECEIVE periodic transformations.
     * \param[in] val_index - Total number of transformations.
     */
    void SetnPeriodicIndex(unsigned short val_index);
    
    /*!
     * \brief Get the total number of SEND_RECEIVE periodic transformations.
     * \return Total number of transformations.
     */
    unsigned short GetnPeriodicIndex(void);
    
    /*!
     * \brief Set the rotation center for a periodic transformation.
     * \param[in] val_index - Index corresponding to the periodic transformation.
     * \param[in] center - Pointer to a vector containing the coordinate of the center.
     */
    void SetPeriodicCenter(unsigned short val_index, double* center);
    
    /*!
     * \brief Get the rotation center for a periodic transformation.
     * \param[in] val_index - Index corresponding to the periodic transformation.
     * \return A vector containing coordinates of the center point.
     */
    double* GetPeriodicCenter(unsigned short val_index);
    
    /*!
     * \brief Set the rotation angles for a periodic transformation.
     * \param[in] val_index - Index corresponding to the periodic transformation.
     * \param[in] rotation - Pointer to a vector containing the rotation angles.
     */
    void SetPeriodicRotation(unsigned short val_index, double* rotation);
    
    /*!
     * \brief Get the rotation angles for a periodic transformation.
     * \param[in] val_index - Index corresponding to the periodic transformation.
     * \return A vector containing the angles of rotation.
     */
    double* GetPeriodicRotation(unsigned short val_index);
    
    /*!
     * \brief Set the translation vector for a periodic transformation.
     * \param[in] val_index - Index corresponding to the periodic transformation.
     * \param[in] translate - Pointer to a vector containing the coordinate of the center.
     */
    void SetPeriodicTranslate(unsigned short val_index, double* translate);
    
    /*!
     * \brief Get the translation vector for a periodic transformation.
     * \param[in] val_index - Index corresponding to the periodic transformation.
     * \return The translation vector.
     */
    double* GetPeriodicTranslate(unsigned short val_index);
    
    /*!
     * \brief Get the total temperature at a nacelle boundary.
     * \param[in] val_index - Index corresponding to the inlet boundary.
     * \return The total temperature.
     */
    double GetExhaust_Temperature_Target(string val_index);
    
    /*!
     * \brief Get the total temperature at an inlet boundary.
     * \param[in] val_index - Index corresponding to the inlet boundary.
     * \return The total temperature.
     */
    double GetInlet_Ttotal(string val_index);
    
    /*!
     * \brief Get the temperature at a supersonic inlet boundary.
     * \param[in] val_index - Index corresponding to the inlet boundary.
     * \return The inlet density.
     */
    double GetInlet_Temperature(string val_index);
    
    /*!
     * \brief Get the pressure at a supersonic inlet boundary.
     * \param[in] val_index - Index corresponding to the inlet boundary.
     * \return The inlet pressure.
     */
    double GetInlet_Pressure(string val_index);
    
    /*!
     * \brief Get the velocity vector at a supersonic inlet boundary.
     * \param[in] val_index - Index corresponding to the inlet boundary.
     * \return The inlet velocity vector.
     */
    double* GetInlet_Velocity(string val_index);
    
    /*!
     * \brief Get the fixed value at the Dirichlet boundary.
     * \param[in] val_index - Index corresponding to the Dirichlet boundary.
     * \return The total temperature.
     */
    double GetDirichlet_Value(string val_index);
    
    /*!
     * \brief Get whether this is a Dirichlet or a Neumann boundary.
     * \param[in] val_index - Index corresponding to the Dirichlet boundary.
     * \return Yes or No.
     */
    bool GetDirichlet_Boundary(string val_index);
    
    /*!
     * \brief Get the total pressure at an inlet boundary.
     * \param[in] val_index - Index corresponding to the inlet boundary.
     * \return The total pressure.
     */
    double GetInlet_Ptotal(string val_index);
    
    /*!
     * \brief Get the total pressure at an nacelle boundary.
     * \param[in] val_index - Index corresponding to the inlet boundary.
     * \return The total pressure.
     */
    double GetExhaust_Pressure_Target(string val_index);
    
    /*!
     * \brief If inlet and outlet conditions are defined for multi species
     * \return true/false
     */
    bool GetInletConditionsDefined();
    
    /*!
     * \brief Get the temperature at an inlet boundary.
     * \param[in] iSpecies - Index of the species
     * \return The total temperature.
     */
    //double GetInlet_Species_Temperature(unsigned short iSpecies);
    
    /*!
     * \brief Get the temperature at an outlet boundary.
     * \param[in] iSpecies - Index of the species
     * \return The total temperature.
     */
    //double GetOutlet_Species_Temperature(unsigned short iSpecies);
    
    /*!
     * \brief Get the pressure at an inlet boundary.
     * \param[in] iSpecies - Index of the species
     * \return The total temperature.
     */
    //double GetInlet_Species_Pressure(unsigned short iSpecies);
    
    /*!
     * \brief Get the pressure at an outlet boundary.
     * \param[in] iSpecies - Index of the species
     * \return The total temperature.
     */
    //double GetOutlet_Species_Pressure(unsigned short iSpecies);
    
    /*!
     * \brief Get the velocity at an inlet boundary.
     * \param[in] iSpecies - Index of the species
     * \return The total temperature.
     */
    //double GetInlet_Species_Velocity(unsigned short iSpecies);
    
    /*!
     * \brief Get the velocity at an outlet boundary.
     * \param[in] iSpecies - Index of the species
     * \return The total temperature.
     */
    //double GetOutlet_Species_Velocity(unsigned short iSpecies);
    
    /*!
     * \brief Value of the CFL reduction in LevelSet problems.
     * \return Value of the CFL reduction in LevelSet problems.
     */
    double GetCFLRedCoeff_Turb(void);
    
    /*!
     * \brief Get the flow direction unit vector at an inlet boundary.
     * \param[in] val_index - Index corresponding to the inlet boundary.
     * \return The flow direction vector.
     */
    double* GetInlet_FlowDir(string val_index);
    
    /*!
     * \brief Get the back pressure (static) at an outlet boundary.
     * \param[in] val_index - Index corresponding to the outlet boundary.
     * \return The outlet pressure.
     */
    double GetOutlet_Pressure(string val_index);
    
    /*!
     * \brief Get the var 1 at Riemann boundary.
     * \param[in] val_marker - Index corresponding to the Riemann boundary.
     * \return The var1
     */
    double GetRiemann_Var1(string val_marker);
    
    /*!
     * \brief Get the var 2 at Riemann boundary.
     * \param[in] val_marker - Index corresponding to the Riemann boundary.
     * \return The var2
     */
    
    double GetRiemann_Var2(string val_marker);
    
    /*!
     * \brief Get the Flowdir at Riemann boundary.
     * \param[in] val_marker - Index corresponding to the Riemann boundary.
     * \return The Flowdir
     */
    double* GetRiemann_FlowDir(string val_marker);
    
    /*!
     * \brief Get Kind Data of Riemann boundary.
     * \param[in] val_marker - Index corresponding to the Riemann boundary.
     * \return Kind data
     */
    unsigned short GetKind_Data_Riemann(string val_marker);
    
    /*!
     * \brief Get the wall temperature (static) at an isothermal boundary.
     * \param[in] val_index - Index corresponding to the isothermal boundary.
     * \return The wall temperature.
     */
    double GetIsothermal_Temperature(string val_index);
    
    /*!
     * \brief Get the wall heat flux on a constant heat flux boundary.
     * \param[in] val_index - Index corresponding to the constant heat flux boundary.
     * \return The heat flux.
     */
    double GetWall_HeatFlux(string val_index);
    
    /*!
     * \brief Get the wall heat flux on a constant heat flux boundary.
     * \return The heat flux.
     */
    double *GetWall_Catalycity(void);
    
    /*!
     * \brief Get the back pressure (static) at an outlet boundary.
     * \param[in] val_index - Index corresponding to the outlet boundary.
     * \return The outlet pressure.
     */
    double GetInflow_Mach_Target(string val_marker);
    
    /*!
     * \brief Get the back pressure (static) at an outlet boundary.
     * \param[in] val_index - Index corresponding to the outlet boundary.
     * \return The outlet pressure.
     */
    double GetInflow_Mach(string val_marker);
    
    /*!
     * \brief Get the back pressure (static) at an outlet boundary.
     * \param[in] val_index - Index corresponding to the outlet boundary.
     * \return The outlet pressure.
     */
    void SetInflow_Mach(unsigned short val_imarker, double val_fanface_mach);
    
    /*!
     * \brief Get the back pressure (static) at an outlet boundary.
     * \param[in] val_index - Index corresponding to the outlet boundary.
     * \return The outlet pressure.
     */
    double GetInflow_Pressure(string val_marker);
    
    /*!
     * \brief Get the back pressure (static) at an outlet boundary.
     * \param[in] val_index - Index corresponding to the outlet boundary.
     * \return The outlet pressure.
     */
    void SetInflow_Pressure(unsigned short val_imarker, double val_fanface_pressure);
    
    /*!
     * \brief Get the back pressure (static) at an outlet boundary.
     * \param[in] val_index - Index corresponding to the outlet boundary.
     * \return The outlet pressure.
     */
    double GetBleed_Temperature_Target(string val_marker);
    
    /*!
     * \brief Get the back pressure (static) at an outlet boundary.
     * \param[in] val_index - Index corresponding to the outlet boundary.
     * \return The outlet pressure.
     */
    double GetBleed_Temperature(string val_marker);
    
    /*!
     * \brief Get the back pressure (static) at an outlet boundary.
     * \param[in] val_index - Index corresponding to the outlet boundary.
     * \return The outlet pressure.
     */
    void SetBleed_Temperature(unsigned short val_imarker, double val_bleed_temp);
    
    /*!
     * \brief Get the back pressure (static) at an outlet boundary.
     * \param[in] val_index - Index corresponding to the outlet boundary.
     * \return The outlet pressure.
     */
    void SetExhaust_Temperature(unsigned short val_imarker, double val_exhaust_temp);
    
    /*!
     * \brief Get the back pressure (static) at an outlet boundary.
     * \param[in] val_index - Index corresponding to the outlet boundary.
     * \return The outlet pressure.
     */
    double GetExhaust_Temperature(string val_marker);
    
    /*!
     * \brief Get the back pressure (static) at an outlet boundary.
     * \param[in] val_index - Index corresponding to the outlet boundary.
     * \return The outlet pressure.
     */
    double GetBleed_MassFlow_Target(string val_marker);
    
    /*!
     * \brief Get the back pressure (static) at an outlet boundary.
     * \param[in] val_index - Index corresponding to the outlet boundary.
     * \return The outlet pressure.
     */
    double GetBleed_MassFlow(string val_marker);
    
    /*!
     * \brief Get the back pressure (static) at an outlet boundary.
     * \param[in] val_index - Index corresponding to the outlet boundary.
     * \return The outlet pressure.
     */
    void SetBleed_MassFlow(unsigned short val_imarker, double val_bleed_massflow);
    
    /*!
     * \brief Get the back pressure (static) at an outlet boundary.
     * \param[in] val_index - Index corresponding to the outlet boundary.
     * \return The outlet pressure.
     */
    double GetBleed_Pressure(string val_marker);
    
    /*!
     * \brief Get the back pressure (static) at an outlet boundary.
     * \param[in] val_index - Index corresponding to the outlet boundary.
     * \return The outlet pressure.
     */
    double GetExhaust_Pressure(string val_marker);
    
    /*!
     * \brief Get the back pressure (static) at an outlet boundary.
     * \param[in] val_index - Index corresponding to the outlet boundary.
     * \return The outlet pressure.
     */
    void SetBleed_Pressure(unsigned short val_imarker, double val_bleed_pressure);
    
    /*!
     * \brief Get the back pressure (static) at an outlet boundary.
     * \param[in] val_index - Index corresponding to the outlet boundary.
     * \return The outlet pressure.
     */
    void SetExhaust_Pressure(unsigned short val_imarker, double val_exhaust_pressure);
    
    /*!
     * \brief Get the displacement value at an displacement boundary.
     * \param[in] val_index - Index corresponding to the displacement boundary.
     * \return The displacement value.
     */
    double GetDispl_Value(string val_index);
    
    /*!
     * \brief Get the force value at an load boundary.
     * \param[in] val_index - Index corresponding to the load boundary.
     * \return The load value.
     */
    double GetLoad_Value(string val_index);
    
    /*!
     * \brief Get the force value at an load boundary.
     * \param[in] val_index - Index corresponding to the load boundary.
     * \return The load value.
     */
    double GetFlowLoad_Value(string val_index);
    
    /*!
     * \brief Cyclic pitch amplitude for rotor blades.
     * \return The specified cyclic pitch amplitude.
     */
    double GetCyclic_Pitch(void);
    
    /*!
     * \brief Collective pitch setting for rotor blades.
     * \return The specified collective pitch setting.
     */
    double GetCollective_Pitch(void);
    
    /*!
     * \brief Get name of the arbitrary mesh motion input file.
     * \return File name of the arbitrary mesh motion input file.
     */
    string GetMotion_FileName(void);
    
    /*!
     * \brief Set the config options.
     */
    void SetConfig_Options(unsigned short val_iZone, unsigned short val_nZone);
    
    /*!
     * \brief Set the config options.
     */
    void SetRunTime_Options(void);
    
    /*!
     * \brief Set the config file parsing.
     */
    void SetConfig_Parsing(char case_filename[MAX_STRING_SIZE]);
    
    /*!
     * \brief Set the config file parsing.
     */
    bool SetRunTime_Parsing(char case_filename[MAX_STRING_SIZE]);
    
    /*!
     * \brief Config file postprocessing.
     */
    void SetPostprocessing(unsigned short val_software, unsigned short val_izone, unsigned short val_nDim);
    
    /*!
     * \brief Config file markers processing.
     */
    void SetMarkers(unsigned short val_software);
    
    /*!
     * \brief Config file output.
     */
    void SetOutput(unsigned short val_software, unsigned short val_izone);
    
    /*!
     * \brief Value of Aeroelastic solution coordinate at time n+1.
     */
    vector<vector<double> > GetAeroelastic_np1(unsigned short iMarker);
    
    /*!
     * \brief Value of Aeroelastic solution coordinate at time n.
     */
    vector<vector<double> > GetAeroelastic_n(unsigned short iMarker);
    
    /*!
     * \brief Value of Aeroelastic solution coordinate at time n-1.
     */
    vector<vector<double> > GetAeroelastic_n1(unsigned short iMarker);
    
    /*!
     * \brief Value of Aeroelastic solution coordinate at time n+1.
     */
    void SetAeroelastic_np1(unsigned short iMarker, vector<vector<double> > solution);
    
    /*!
     * \brief Value of Aeroelastic solution coordinate at time n from time n+1.
     */
    void SetAeroelastic_n(void);
    
    /*!
     * \brief Value of Aeroelastic solution coordinate at time n-1 from time n.
     */
    void SetAeroelastic_n1(void);
    
    /*!
     * \brief Uncoupled Aeroelastic Frequency Plunge.
     */
    double GetAeroelastic_Frequency_Plunge(void);
    
    /*!
     * \brief Uncoupled Aeroelastic Frequency Pitch.
     */
    double GetAeroelastic_Frequency_Pitch(void);
    
    /*!
     * \brief Value of plunging coordinate.
     * \param[in] val_marker - the marker we are monitoring.
     * \return Value of plunging coordinate.
     */
    double GetAeroelastic_plunge(unsigned short val_marker);
    
    /*!
     * \brief Value of pitching coordinate.
     * \param[in] val_marker - the marker we are monitoring.
     * \return Value of pitching coordinate.
     */
    double GetAeroelastic_pitch(unsigned short val_marker);
    
    /*!
     * \brief Value of plunging coordinate.
     * \param[in] val_marker - the marker we are monitoring.
     * \param[in] val - value of plunging coordinate.
     */
    void SetAeroelastic_plunge(unsigned short val_marker, double val);
    
    /*!
     * \brief Value of pitching coordinate.
     * \param[in] val_marker - the marker we are monitoring.
     * \param[in] val - value of pitching coordinate.
     */
    void SetAeroelastic_pitch(unsigned short val_marker, double val);
    
    /*!
     * \brief Get information about the aeroelastic simulation.
     * \return <code>TRUE</code> if it is an aeroelastic case; otherwise <code>FALSE</code>.
     */
    bool GetAeroelastic_Simulation(void);
    
    /*!
     * \brief Get information about the wind gust.
     * \return <code>TRUE</code> if there is a wind gust; otherwise <code>FALSE</code>.
     */
    bool GetWind_Gust(void);
    
    /*!
     * \brief Get the type of gust to simulate.
     * \return type of gust to use for the simulation.
     */
    unsigned short GetGust_Type(void);
    
    /*!
     * \brief Get the gust direction.
     * \return the gust direction.
     */
    unsigned short GetGust_Dir(void);
    
    /*!
     * \brief Value of the gust wavelength.
     */
    double GetGust_WaveLength(void);
    
    /*!
     * \brief Value of the number of gust periods.
     */
    double GetGust_Periods(void);
    
    /*!
     * \brief Value of the gust amplitude.
     */
    double GetGust_Ampl(void);
    
    /*!
     * \brief Value of the time at which to begin the gust.
     */
    double GetGust_Begin_Time(void);
    
    /*!
     * \brief Value of the location ath which the gust begins.
     */
    double GetGust_Begin_Loc(void);
    
    /*!
     * \brief Value of the time at which to begin the gust.
     */
    unsigned short GetnFFD_Iter(void);
    
    /*!
     * \brief Value of the location ath which the gust begins.
     */
    double GetFFD_Tol(void);
    
    /*!
     * \brief Get the node number of the CV to visualize.
     * \return Node number of the CV to visualize.
     */
    long GetVisualize_CV(void);
    
    /*!
     * \brief Get information about whether to use fixed CL mode.
     * \return <code>TRUE</code> if fixed CL mode is active; otherwise <code>FALSE</code>.
     */
    bool GetFixed_CL_Mode(void);
    
    /*!
     * \brief Get the value specified for the target CL.
     * \return Value of the target CL.
     */
    double GetTarget_CL(void);
    
    /*!
     * \brief Get the value of the damping coefficient for fixed CL mode.
     * \return Damping coefficient for fixed CL mode.
     */
    double GetDamp_Fixed_CL(void);
    
    /*!
     * \brief Get the value of iterations to re-evaluate the angle of attack.
     * \return Number of iterations.
     */
    unsigned long GetIter_Fixed_CL(void);
    
    /*!
     * \brief Set the value of the boolean for updating AoA in fixed lift mode.
     * \param[in] val_update - the bool for whether to update the AoA.
     */
    void SetUpdate_AoA(bool val_update);
    
    /*!
     * \brief Get information about whether to update the AoA for fixed lift mode.
     * \return <code>TRUE</code> if we should update the AoA for fixed lift mode; otherwise <code>FALSE</code>.
     */
    bool GetUpdate_AoA(void);
    
    /*!
     * \brief Set the current number of non-physical nodes in the solution.
     * \param[in] val_nonphys_points - current number of non-physical points.
     */
    void SetNonphysical_Points(unsigned long val_nonphys_points);
    
    /*!
     * \brief Get the current number of non-physical nodes in the solution.
     * \return Current number of non-physical points.
     */
    unsigned long GetNonphysical_Points(void);
    
    /*!
     * \brief Set the current number of non-physical reconstructions for 2nd-order upwinding.
     * \param[in] val_nonphys_reconstr - current number of non-physical reconstructions for 2nd-order upwinding.
     */
    void SetNonphysical_Reconstr(unsigned long val_nonphys_reconstr);
    
    /*!
     * \brief Get the current number of non-physical reconstructions for 2nd-order upwinding.
     * \return Current number of non-physical reconstructions for 2nd-order upwinding.
     */
    unsigned long GetNonphysical_Reconstr(void);
    
    /*!
     * \brief Given arrays x[1..n] and y[1..n] containing a tabulated function, i.e., yi = f(xi), with
     x1 < x2 < . . . < xN , and given values yp1 and ypn for the first derivative of the interpolating
     function at points 1 and n, respectively, this routine returns an array y2[1..n] that contains
     the second derivatives of the interpolating function at the tabulated points xi. If yp1 and/or
     ypn are equal to 1 × 1030 or larger, the routine is signaled to set the corresponding boundary
     condition for a natural spline, with zero second derivative on that boundary.
     Numerical Recipes: The Art of Scientific Computing, Third Edition in C++.
     */
    void SetSpline(vector<double> &x, vector<double> &y, unsigned long n, double yp1, double ypn, vector<double> &y2);
    
    /*!
     * \brief Given the arrays xa[1..n] and ya[1..n], which tabulate a function (with the xai’s in order),
     and given the array y2a[1..n], which is the output from spline above, and given a value of
     x, this routine returns a cubic-spline interpolated value y.
     Numerical Recipes: The Art of Scientific Computing, Third Edition in C++.
     * \returns The interpolated value of for x.
     */
    double GetSpline(vector<double> &xa, vector<double> &ya, vector<double> &y2a, unsigned long n, double x);
    
    /*!
     * \brief Get the verbosity level of the console output.
     * \return Verbosity level for the console output.
     */
    unsigned short GetConsole_Output_Verb(void);
    
};



/* transport_model.hpp------------------------------------------------------------
 *
 *
 *
 */

/*!
 * \class CViscosityModel
 * \brief Main class for defining the Transport-Physical Model
 * a child class for each particular Model (Power law, Sutherland, Chung, etc.)
 * \author S.Vitale, M.Pini
 * \version 1.0
 */
class CViscosityModel {
protected:
    double   	 Mu,			/*!< \brief Dynamic viscosity. */
			 dmudrho_T, 	/*!< \brief DmuDrho_T. */
			 dmudT_rho; 	/*!< \brief DmuDT_rho. */
public:
    
    /*!
     * \brief Constructor of the class.
     */
    CViscosityModel(void);
    
    /*!
     * \brief Destructor of the class.
     */
    virtual ~CViscosityModel(void);
    
    /*!
     * \brief return viscosity value.
     */
    double GetViscosity(void);
    
    /*!
     * \brief return viscosity partial derivative value.
     */
    double Getdmudrho_T(void);
    
    /*!
     * \brief return viscosity partial derivative value.
     */
    double GetdmudT_rho(void);
    
    /*!
     * \brief Set Viscosity.
     */
    virtual	 void SetViscosity(double T, double rho);
    
    /*!
     * \brief Set Viscosity Derivatives.
     */
    virtual	 void SetDerViscosity(double T, double rho);
    
};


/*!
 * \class CConstantViscosity
 * \brief this class defines a constant viscosity
 * a child class for each particular Model (Power law, Sutherland, Chung, etc.)
 * \author S.Vitale, M.Pini
 * \version 1.0
 */
class CConstantViscosity : public CViscosityModel {
    
public:
    
    /*!
     * \brief Constructor of the class.
     */
    CConstantViscosity(void);
    
    /*!
     * \brief Constructor of the class.
     */
    CConstantViscosity(double mu_const);
    
    /*!
     * \brief Destructor of the class.
     */
    virtual ~CConstantViscosity(void);
    
    
};


/*!
 * \class CSutherland
 * \brief this class defines a constant viscosity
 * a child class for each particular Model (Power law, Sutherland, Chung, etc.)
 * \author S.Vitale, M.Pini
 * \version 1.0
 */
class CSutherland : public CViscosityModel {
protected:
    double   	 Mu_ref,		/*!< \brief Internal Energy. */
    T_ref, 		/*!< \brief DpDd_e. */
    S; 			/*!< \brief DpDe_d. */
    
public:
    
    /*!
     * \brief Constructor of the class.
     */
    CSutherland(void);
    
    /*!
     * \brief Constructor of the class.
     */
    CSutherland(double mu_ref, double t_ref, double s);
    
    /*!
     * \brief Destructor of the class.
     */
    virtual ~CSutherland(void);
    
    /*!
     * \brief Set Viscosity.
     */
    void SetViscosity(double T, double rho);
    
    /*!
     * \brief Set Viscosity Derivatives.
     */
    void SetDerViscosity(double T, double rho);
    
};


/*!
 * \class CThermalConductivityModel
 * \brief Main class for defining the Transport-Physical Model
 * a child class for each particular Model (Prandtl-based, etc.)
 * \author S. Vitale, M. Pini
 * \version 1.0
 */
class CConductivityModel {
protected:
    double   	 Kt,			/*!< \brief Thermal conductivity. */
			 dktdrho_T, 	/*!< \brief DktDrho_T. */
			 dktdT_rho; 	/*!< \brief DktDT_rho. */
public:
    
    /*!
     * \brief Constructor of the class.
     */
    CConductivityModel(void);
    
    /*!
     * \brief Destructor of the class.
     */
    virtual ~CConductivityModel(void);
    
    /*!
     * \brief return viscosity value.
     */
    double GetConductivity(void);
    
    /*!
     * \brief return viscosity partial derivative value.
     */
    double Getdktdrho_T(void);
    
    /*!
     * \brief return viscosity partial derivative value.
     */
    double GetdktdT_rho(void);
    
    /*!
     * \brief Set Thermal conductivity.
     */
    virtual	 void SetConductivity(double T, double rho, double mu, double cp);
    
    /*!
     * \brief Set Thermal conductivity derivatives.
     */
    virtual	 void SetDerConductivity(double T, double rho, double dmudrho_T, double dmudT_rho, double cp);
    
};


/*!
 * \class CConstantPrandtl
 * \brief this class defines a constant thermal conductivity using a constant Prandtl's number
 * \author S.Vitale, M.Pini
 * \version 1.0
 */
class CConstantConductivity : public CConductivityModel {
    
public:
    
    /*!
     * \brief Constructor of the class.
     */
    CConstantConductivity(void);
    
    /*!
     * \brief Constructor of the class.
     */
    CConstantConductivity(double kt_const);
    
    /*!
     * \brief Destructor of the class.
     */
    virtual ~CConstantConductivity(void);
    
};


/*!
 * \class CConstantPrandtl
 * \brief this class defines a non-constant thermal conductivity using a constant Prandtl's number
 * \author S.Vitale, M.Pini
 * \version 1.0
 */
class CConstantPrandtl : public CConductivityModel {
protected:
    double   	 Pr_const;		/*!< \brief Prandtl's number. */
    
public:
    
    /*!
     * \brief Constructor of the class.
     */
    CConstantPrandtl(void);
    
    /*!
     * \brief Destructor of the class.
     */
    virtual ~CConstantPrandtl(void);
    
    /*!
     * \brief Constructor of the class.
     */
    CConstantPrandtl(double pr_const);
    
    /*!
     * \brief Set Thermal conductivity.
     * \brief par1 -> Cp.
     * \brief par2 -> Mu.
     */
    void SetConductivity(double T, double rho, double mu, double cp);
    
    /*!
     * \brief Set Thermal conductivity derivatives.
     */
    void SetDerConductivity(double T, double rho, double dmudrho_T, double dmudT_rho, double cp);
    
};



/* fluid_model.hpp------------------------------------------------------------
 *
 *
 *
 */

/*!
 * \class CFluidModel
 * \brief Main class for defining the Thermo-Physical Model
 * a child class for each particular Model (Ideal-Gas, Van der Waals, etc.)
 * \author: S.Vitale, G.Gori, M.Pini
 * \version 3.2.9 "eagle"
 */
class CFluidModel {
protected:
    double   	 StaticEnergy,			/*!< \brief Internal Energy. */
			 Entropy,  				/*!< \brief Entropy. */
			 Density,  				/*!< \brief Density. */
			 Pressure, 				/*!< \brief Pressure. */
			 SoundSpeed2, 			/*!< \brief SpeedSound. */
			 Temperature,			/*!< \brief Temperature. */
			 dPdrho_e, 				/*!< \brief DpDd_e. */
			 dPde_rho, 				/*!< \brief DpDe_d. */
			 dTdrho_e, 				/*!< \brief DTDd_e. */
			 dTde_rho, 				/*!< \brief DTDe_d. */
    Cp,                    /*!< \brief Specific Heat Capacity at constant pressure. */
			 Mu,					/*!< \brief Specific Heat Capacity at constant pressure. */
    dmudrho_T, 			/*!< \brief Specific Heat Capacity at constant pressure. */
    dmudT_rho,				/*!< \brief Specific Heat Capacity at constant pressure. */
    Kt,					/*!< \brief Specific Heat Capacity at constant pressure. */
    dktdrho_T, 			/*!< \brief Specific Heat Capacity at constant pressure. */
    dktdT_rho;				/*!< \brief Specific Heat Capacity at constant pressure. */
    
    CViscosityModel *LaminarViscosity;	          /*!< \brief Laminar Viscosity Model */
    CConductivityModel *ThermalConductivity;	  /*!< \brief Thermal Conductivity Model */
    
public:
    
    /*!
     * \brief Constructor of the class.
     */
    CFluidModel(void);
    
    /*!
     * \brief Destructor of the class.
     */
    virtual ~CFluidModel(void);
    
    /*!
     * \brief Get fluid pressure.
     */
    double GetPressure ();
    
    /*!
     * \brief Get fluid temperature.
     */
    double GetTemperature ();
    
    /*!
     * \brief Get fluid entropy.
     */
    double GetEntropy ();
    
    /*!
     * \brief Get fluid internal energy.
     */
    double GetStaticEnergy ();
    
    /*!
     * \brief Get fluid density.
     */
    double GetDensity ();
    
    /*!
     * \brief Get fluid speed of sound.
     */
    double GetSoundSpeed ();
    
    /*!
     * \brief Get fluid speed of sound squared.
     */
    double GetSoundSpeed2 ();
    
    /*!
     * \brief Get fluid specific heat at constant pressure.
     */
    double GetCp ();
    
    /*!
     * \brief Get fluid dynamic viscosity
     */
    
    double GetLaminarViscosity ();
    
    /*!
     * \brief Get fluid thermal conductivity
     */
    
    double GetThermalConductivity ();
    
    /*!
     * \brief Get fluid pressure partial derivative.
     */
    double GetdPdrho_e ();
    
    /*!
     * \brief Get fluid pressure partial derivative.
     */
    double GetdPde_rho ();
    
    /*!
     * \brief Get fluid temperature partial derivative.
     */
    double GetdTdrho_e ();
    
    /*!
     * \brief Get fluid temperature partial derivative.
     */
    double GetdTde_rho ();
    
    /*!
     * \brief Get fluid dynamic viscosity partial derivative.
     */
    double Getdmudrho_T ();
    
    /*!
     * \brief Get fluid dynamic viscosity partial derivative.
     */
    double GetdmudT_rho ();
    
    /*!
     * \brief Get fluid thermal conductivity partial derivative.
     */
    double Getdktdrho_T ();
    
    /*!
     * \brief Get fluid thermal conductivity partial derivative.
     */
    double GetdktdT_rho ();
    
    /*!
     * \brief Set viscosity model.
     */
    void SetLaminarViscosityModel (CConfig *config);
    
    /*!
     * \brief Set thermal conductivity model.
     */
    void SetThermalConductivityModel (CConfig *config);
    
    /*!
     * \brief virtual member that would be different for each gas model implemented
     * \param[in] InputSpec - Input pair for FLP calls ("e, rho").
     * \param[in] rho - first thermodynamic variable.
     * \param[in] e - second thermodynamic variable.
     */
    
    virtual void SetTDState_rhoe (double rho, double e );
    
    /*!
     * \brief virtual member that would be different for each gas model implemented
     * \param[in] InputSpec - Input pair for FLP calls ("PT").
     * \param[in] th1 - first thermodynamic variable (P).
     * \param[in] th2 - second thermodynamic variable (T).
     */
    
    virtual void SetTDState_PT (double P, double T );
    
    /*!
     * \brief virtual member that would be different for each gas model implemented
     * \param[in] InputSpec - Input pair for FLP calls ("Pv").
     * \param[in] th1 - first thermodynamic variable (P).
     * \param[in] th2 - second thermodynamic variable (v).
     */
    
    virtual void SetTDState_Prho (double P, double rho );
    
    /*!
     * \brief virtual member that would be different for each gas model implemented
     * \param[in] InputSpec - Input pair for FLP calls ("Pv").
     * \param[in] th1 - first thermodynamic variable (P).
     * \param[in] th2 - second thermodynamic variable (v).
     *
     */
    
    virtual void SetEnergy_Prho (double P, double rho );
    
    /*!
     * \brief virtual member that would be different for each gas model implemented
     * \param[in] InputSpec - Input pair for FLP calls ("hs").
     * \param[in] th1 - first thermodynamic variable (h).
     * \param[in] th2 - second thermodynamic variable (s).
     *
     */
    virtual void SetTDState_hs (double h, double s );
    
    
    /*!
     * \brief virtual member that would be different for each gas model implemented
     * \param[in] InputSpec - Input pair for FLP calls ("rhoT").
     * \param[in] th1 - first thermodynamic variable (rho).
     * \param[in] th2 - second thermodynamic variable (T).
     *
     */
    virtual void SetTDState_rhoT (double rho, double T );
    
};


/*!
 * \class CIdealGas
 * \brief Child class for defining ideal gas model.
 * \author: S.Vitale, M.Pini.
 * \version 3.2.9 "eagle"
 */
class CIdealGas : public CFluidModel {
    
protected:
    double Gamma, 						/*!< \brief Heat Capacity Ratio. */
    Gamma_Minus_One, 			/*!< \brief Heat Capacity Ratio Minus One. */
    Gas_Constant;				/*!< \brief Gas Constant. */
    
    
public:
    
	   /*!
        * \brief Constructor of the class.
        */
    CIdealGas(void);
    
    /*!
     * \brief Constructor of the class.
     */
    CIdealGas(double gamma, double R);
    
    
    /*!
     * \brief Destructor of the class.
     */
    virtual ~CIdealGas(void);
    
    /*!
     * \brief virtual member that would be different for each gas model implemented
     * \param[in] InputSpec - Input pair for FLP calls ("e, rho").
     * \param[in] rho - first thermodynamic variable.
     * \param[in] e - second thermodynamic variable.
     */
    
    void SetTDState_rhoe (double rho, double e );
    
    /*!
     * \brief virtual member that would be different for each gas model implemented
     * \param[in] InputSpec - Input pair for FLP calls ("PT").
     * \param[in] P - first thermodynamic variable.
     * \param[in] T - second thermodynamic variable.
     */
    
    void SetTDState_PT (double P, double T );
    
    /*!
     * \brief virtual member that would be different for each gas model implemented
     * \param[in] InputSpec - Input pair for FLP calls ("Prho").
     * \param[in] P - first thermodynamic variable.
     * \param[in] rho - second thermodynamic variable.
     */
    
    void SetTDState_Prho (double P, double rho );
    
    /*!
     * \brief virtual member that would be different for each gas model implemented
     * \param[in] InputSpec - Input pair for FLP calls ("Prho").
     * \param[in] P - first thermodynamic variable.
     * \param[in] rho - second thermodynamic variable.
     */
    
    void SetEnergy_Prho (double P, double rho );
    
    /*!
     * \brief virtual member that would be different for each gas model implemented
     * \param[in] InputSpec - Input pair for FLP calls ("hs").
     * \param[in] th1 - first thermodynamic variable (h).
     * \param[in] th2 - second thermodynamic variable (s).
     *
     */
    void SetTDState_hs (double h, double s );
    
    
    /*!
     * \brief virtual member that would be different for each gas model implemented
     * \param[in] InputSpec - Input pair for FLP calls ("rhoT").
     * \param[in] th1 - first thermodynamic variable (rho).
     * \param[in] th2 - second thermodynamic variable (T).
     *
     */
    void SetTDState_rhoT (double rho, double T );
};


/*!
 * derived class CVanDerWaalsGas
 * \brief Child class for defining the Van der Waals model.
 * \author: S.Vitale, M.Pini
 * \version 3.2.9 "eagle"
 */
class CVanDerWaalsGas : public CIdealGas {
    
protected:
    double
    a, b, Zed;   					/*!< \brief Parameters for the Dimensionless Equation. */
    
public:
    
	   /*!
        * \brief Constructor of the class.
        */
    CVanDerWaalsGas(void);
    
    /*!
     * \brief Constructor of the class.
     */
    CVanDerWaalsGas(double gamma, double R, double Pstar, double Tstar);
    
    
    /*!
     * \brief Destructor of the class.
     */
    virtual ~CVanDerWaalsGas(void);
    
    /*!
     * \brief Set the Dimensionless State using Density and Internal Energy
     * \param[in] rho - first thermodynamic variable.
     * \param[in] e - second thermodynamic variable.
     */
    void SetTDState_rhoe (double rho, double e );
    
    /*!
     * \brief Set the Dimensionless State using Pressure and Temperature
     * \param[in] P - first thermodynamic variable.
     * \param[in] T - second thermodynamic variable.
     */
    void SetTDState_PT (double P, double T );
    
    /*!
     * \brief Set the Dimensionless State using Pressure and Density
     * \param[in] P - first thermodynamic variable.
     * \param[in] rho - second thermodynamic variable.
     */
    void SetTDState_Prho (double P, double rho );
    
    /*!
     * \brief Set the Dimensionless Energy using Pressure and Density
     * \param[in] P - first thermodynamic variable.
     * \param[in] rho - second thermodynamic variable.
     */
    void SetEnergy_Prho (double P, double rho );
    
    /*!
     * \brief virtual member that would be different for each gas model implemented
     * \param[in] h - first thermodynamic variable (h).
     * \param[in] s - second thermodynamic variable (s).
     *
     */
    void SetTDState_hs (double h, double s );
    
    
    /*!
     * \brief virtual member that would be different for each gas model implemented
     * \param[in] rho - first thermodynamic variable (rho).
     * \param[in] T - second thermodynamic variable (T).
     *
     */
    void SetTDState_rhoT (double rho, double T );
    
};


/*!
 * \derived class CPengRobinson
 * \brief Child class for defining the Peng-Robinson model.
 * \author: S.Vitale, G. Gori
 * \version 3.2.9 "eagle"
 */
class CPengRobinson : public CIdealGas {
    
protected:
    double  a, 						/*!< \brief model parameter. */
    b, 						/*!< \brief model parameter. */
    k, 						/*!< \brief model parameter (computed with acentric factor). */
    Zed, 						/*!< \brief compressibility factor. */
    TstarCrit;				/*!< \brief Critical temperature. */
    
private:
    
    /*!
	    * \brief Internal model parameter.
	    */
    double  alpha2 (double T);
    
    
	   /*!
        * \brief Internal model parameter.
        */
    double  T_v_h (double v, double h);
    
public:
    
    /*!
     * \brief Constructor of the class.
     */
    CPengRobinson(void);
    
    /*!
     * \brief Constructor of the class.
     */
    CPengRobinson(double gamma, double R, double Pstar, double Tstar, double w);
    
    /*!
     * \brief Destructor of the class.
     */
    virtual ~CPengRobinson(void);
    
    /*!
     * \brief Set the Dimensionless State using Density and Internal Energy
     * \param[in] rho - first thermodynamic variable.
     * \param[in] e - second thermodynamic variable.
     */
    void SetTDState_rhoe (double rho, double e );
    
    /*!
     * \brief Set the Dimensionless State using Pressure and Temperature
     * \param[in] P - first thermodynamic variable.
     * \param[in] T - second thermodynamic variable.
     */
    void SetTDState_PT (double P, double T );
    
    /*!
     * \brief Set the Dimensionless State using Pressure and Density
     * \param[in] P - first thermodynamic variable.
     * \param[in] rho - second thermodynamic variable.
     */
    void SetTDState_Prho (double P, double rho );
    
    /*!
     * \brief Set the Dimensionless Energy using Pressure and Density
     * \param[in] P - first thermodynamic variable.
     * \param[in] rho - second thermodynamic variable.
     */
    void SetEnergy_Prho (double P, double rho );
    /*!
     * \brief virtual member that would be different for each gas model implemented
     * \param[in] InputSpec - Input pair for FLP calls ("hs").
     * \param[in] th1 - first thermodynamic variable (h).
     * \param[in] th2 - second thermodynamic variable (s).
     *
     */
    void SetTDState_hs (double h, double s );
    
    /*!
     * \brief virtual member that would be different for each gas model implemented
     * \param[in] InputSpec - Input pair for FLP calls ("rhoT").
     * \param[in] th1 - first thermodynamic variable (rho).
     * \param[in] th2 - second thermodynamic variable (T).
     *
     */
    void SetTDState_rhoT (double rho, double T );
    
};



/* vector_structure.hpp------------------------------------------------------------
 *
 *
 *
 */

/*!
 * \class CSysVector
 * \brief Class for holding and manipulating vectors needed by linear solvers
 * \author J. Hicken.
 * \version 3.2.9 "eagle"
 *
 * We could use the STL vector as a base class here, but this gives us
 * more flexibility with the underlying data (e.g. we may decide to
 * use a block storage scheme rather than a continuous storage
 * scheme).
 */
class CSysVector {
    
private:
    
    unsigned long nElm; /*!< \brief total number of elements (or number elements on this processor) */
    unsigned long nElmDomain; /*!< \brief total number of elements (or number elements on this processor without Ghost cells) */
    unsigned long nElmGlobal; /*!< \brief total number of elements over all processors */
    unsigned short nVar; /*!< \brief number of elements in a block */
    unsigned long nBlk; /*!< \brief number of blocks (or number of blocks on this processor) */
    unsigned long nBlkDomain; /*!< \brief number of blocks (or number of blocks on this processor without Ghost cells) */
    double* vec_val; /*!< \brief storage for the element values */
    
public:
    
    /*!
     * \brief default constructor of the class.
     */
    CSysVector(void);
    
    /*!
     * \brief constructor of the class.
     * \param[in] size - number of elements locally
     * \param[in] val - default value for elements
     */
    CSysVector(const unsigned long & size, const double & val = 0.0);
    
    /*!
     * \brief constructor of the class.
     * \param[in] numBlk - number of blocks locally
     * \param[in] numVar - number of variables in each block
     * \param[in] val - default value for elements
     */
    CSysVector(const unsigned long & numBlk, const unsigned long & numBlkDomain, const unsigned short & numVar, const double & val = 0.0);
    
    /*!
     * \brief copy constructor of the class.
     * \param[in] u - CSysVector that is being copied
     */
    CSysVector(const CSysVector & u);
    
    /*!
     * \brief Sets to zero all the entries of the vector.
     */
    void SetValZero(void);
    
    /*!
     * \brief constructor from array
     * \param[in] size - number of elements locally
     * \param[in] u_array - vector stored as array being copied
     */
    explicit CSysVector(const unsigned long & size, const double* u_array);
    
    /*!
     * \brief constructor from array
     * \param[in] numBlk - number of blocks locally
     * \param[in] numBlkDomain - number of blocks locally (without g cells)
     * \param[in] numVar - number of variables in each block
     * \param[in] u_array - vector stored as array being copied
     */
    explicit CSysVector(const unsigned long & numBlk, const unsigned long & numBlkDomain, const unsigned short & numVar,
                        const double* u_array);
    
    /*!
     * \brief class destructor
     */
    virtual ~CSysVector();
    
    /*!
     * \brief Initialize the class.
     * \param[in] numBlk - number of blocks locally
     * \param[in] numVar - number of variables in each block
     * \param[in] val - default value for elements
     */
    void Initialize(const unsigned long & numBlk, const unsigned long & numBlkDomain, const unsigned short & numVar, const double & val = 0.0);
    
    /*!
     * \brief return the number of local elements in the CSysVector
     */
    unsigned long GetLocSize() const;
    
    /*!
     * \brief return the size of the CSysVector (over all processors)
     */
    unsigned long GetSize() const;
    
    /*!
     * \brief return the number of variables at each block (typically number per node)
     */
    unsigned short GetNVar() const;
    
    /*!
     * \brief return the number of blocks (typically number of nodes locally)
     */
    unsigned long GetNBlk() const;
    
    /*!
     * \brief return the number of blocks (typically number of nodes locally)
     */
    unsigned long GetNBlkDomain() const;
    
    /*!
     * \brief set calling CSysVector to scaling of another CSysVector
     * \param[in] a - scalar factor for x
     * \param[in] x - CSysVector that is being scaled
     */
    void Equals_AX(const double & a, CSysVector & x);
    
    /*!
     * \brief adds a scaled CSysVector to calling CSysVector
     * \param[in] a - scalar factor for x
     * \param[in] x - CSysVector that is being scaled
     */
    void Plus_AX(const double & a, CSysVector & x);
    
    /*!
     * \brief general linear combination of two CSysVectors
     * \param[in] a - scalar factor for x
     * \param[in] x - first CSysVector in linear combination
     * \param[in] b - scalar factor for y
     * \param[in] y - second CSysVector in linear combination
     */
    void Equals_AX_Plus_BY(const double & a, CSysVector & x, const double & b, CSysVector & y);
    
    /*!
     * \brief assignment operator with deep copy
     * \param[in] u - CSysVector whose values are being assigned
     */
    CSysVector & operator=(const CSysVector & u);
    
    /*!
     * \brief CSysVector=double assignment operator
     * \param[in] val - value assigned to each element of CSysVector
     */
    CSysVector & operator=(const double & val);
    
    /*!
     * \brief addition operator
     * \param[in] u - CSysVector being added to *this
     */
    CSysVector operator+(const CSysVector & u) const;
    
    /*!
     * \brief compound addition-assignment operator
     * \param[in] u - CSysVector being added to calling object
     */
    CSysVector & operator+=(const CSysVector & u);
    
    /*!
     * \brief subtraction operator
     * \param[in] u - CSysVector being subtracted from *this
     */
    CSysVector operator-(const CSysVector & u) const;
    
    /*!
     * \brief compound subtraction-assignment operator
     * \param[in] u - CSysVector being subtracted from calling object
     */
    CSysVector & operator-=(const CSysVector & u);
    
    /*!
     * \brief vector * scalar multiplication operator
     * \param[in] val - value to multiply *this by
     */
    CSysVector operator*(const double & val) const;
    
    /*!
     * \brief scalar * vector multiplication operator
     * \param[in] val - scalar value to multiply by
     * \param[in] u - CSysVector having its elements scaled
     */
    friend CSysVector operator*(const double & val, const CSysVector & u);
    
    /*!
     * \brief compound scalar multiplication-assignment operator
     * \param[in] val - value to multiply calling object by
     */
    CSysVector & operator*=(const double & val);
    
    /*!
     * \brief vector-scalar division operator (no scalar/vector operator)
     * \param[in] val - value to divide elements of *this by
     */
    CSysVector operator/(const double & val) const;
    
    /*!
     * \brief compound scalar division-assignment operator
     * \param[in] val - value to divide elements of calling object by
     */
    CSysVector & operator/=(const double & val);
    
    /*!
     * \brief indexing operator with assignment permitted
     * \param[in] i = local index to access
     */
    double & operator[](const unsigned long & i);
    
    /*!
     * \brief indexing operator with assignment not permitted
     * \param[in] i = local index to access
     */
    const double & operator[](const unsigned long & i) const;
    
    /*!
     * \brief the L2 norm of the CSysVector
     * \result the L2 norm
     */
    double norm() const;
    
    /*!
     * \brief copies the contents of the calling CSysVector into an array
     * \param[out] u_array - array into which information is being copied
     * \pre u_array must be allocated and have the same size as CSysVector
     */
    void CopyToArray(double* u_array);
    
    /*!
     * \brief Subtract val_residual to the residual.
     * \param[in] val_ipoint - index of the point where subtract the residual.
     * \param[in] val_residual - Value to subtract to the residual.
     */
    void SubtractBlock(unsigned long val_ipoint, double *val_residual);
    
    /*!
     * \brief Add val_residual to the residual.
     * \param[in] val_ipoint - index of the point where add the residual.
     * \param[in] val_residual - Value to add to the residual.
     */
    void AddBlock(unsigned long val_ipoint, double *val_residual);
    
    /*!
     * \brief Set val_residual to the residual.
     * \param[in] val_ipoint - index of the point where set the residual.
     * \param[in] val_var - inde of the residual to be set.
     * \param[in] val_residual - Value to set to the residual.
     */
    void SetBlock(unsigned long val_ipoint, unsigned short val_var, double val_residual);
    
    /*!
     * \brief Set val_residual to the residual.
     * \param[in] val_ipoint - index of the point where set the residual.
     * \param[in] val_residual - Value to set to the residual.
     */
    void SetBlock(unsigned long val_ipoint, double *val_residual);
    
    /*!
     * \brief Set the residual to zero.
     * \param[in] val_ipoint - index of the point where set the residual.
     */
    void SetBlock_Zero(unsigned long val_ipoint);
    
    /*!
     * \brief Set the velocity residual to zero.
     * \param[in] val_ipoint - index of the point where set the residual.
     */
    void SetBlock_Zero(unsigned long val_ipoint, unsigned short val_var);
    
    /*!
     * \brief Get the value of the residual.
     * \param[in] val_ipoint - index of the point where set the residual.
     * \return Pointer to the residual.
     */
    double *GetBlock(unsigned long val_ipoint);
    
    /*!
     * \brief Get the value of the residual.
     * \param[in] val_ipoint - index of the point where set the residual.
     * \param[in] val_var - inde of the residual to be set.
     * \return Value of the residual.
     */
    double GetBlock(unsigned long val_ipoint, unsigned short val_var);
    
    
    /*!
     * \brief dot-product between two CSysVectors
     * \param[in] u - first CSysVector in dot product
     * \param[in] v - second CSysVector in dot product
     */
    friend double dotProd(const CSysVector & u, const CSysVector & v);
    
};

/*!
 * \class CMatrixVectorProduct
 * \brief abstract base class for defining matrix-vector products
 * \author J. Hicken.
 * \version 3.2.9 "eagle"
 *
 * The Krylov-subspace solvers require only matrix-vector products and
 * not the actual matrix/Jacobian.  We need some way to indicate which
 * function will perform the product.  However, sometimes the
 * functions that define the product will require different numbers
 * and types of inputs.  For example, the forward-difference
 * approximation to a Jacobian-vector product requires the vector that
 * defines the Jacobian and a perturbation parameter.  The
 * CMatrixVectorProduct class is used to derive child classes that can
 * handle the different types of matrix-vector products and still be
 * passed to a single implementation of the Krylov solvers.
 */
class CMatrixVectorProduct {
public:
    virtual ~CMatrixVectorProduct() = 0; ///< class destructor
    virtual void operator()(const CSysVector & u, CSysVector & v)
    const = 0; ///< matrix-vector product operation
};
inline CMatrixVectorProduct::~CMatrixVectorProduct() {}

/*!
 * \class CPreconditioner
 * \brief abstract base class for defining preconditioning operation
 * \author J. Hicken.
 * \version 3.2.9 "eagle"
 *
 * See the remarks regarding the CMatrixVectorProduct class.  The same
 * idea applies here to the preconditioning operation.
 */
class CPreconditioner {
public:
    virtual ~CPreconditioner() = 0; ///< class destructor
    virtual void operator()(const CSysVector & u, CSysVector & v)
    const = 0; ///< preconditioning operation
};
inline CPreconditioner::~CPreconditioner() {}


/* vdual_grid_structure.hpp------------------------------------------------------------
 *
 *
 *
 */
/*!
 * \class CDualGrid
 * \brief Class for controlling the dual volume definition. The dual volume is compose by
 *        three main elements: points, edges, and vertices.
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CDualGrid{
protected:
    static unsigned short nDim; /*!< \brief Number of dimensions of the problem. */
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     */
    CDualGrid(unsigned short val_nDim);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CDualGrid(void);
    
    /*!
     * \brief A pure virtual member.
     */
    virtual double *GetCoord(void) = 0;
    
    /*!
     * \brief A pure virtual member.
     * \param[in] val_coord - Coordinate of the point.
     */
    virtual void SetCoord(double *val_coord) = 0;
    
    /*!
     * \brief A pure virtual member.
     * \param[in] val_coord_Edge_CG - Coordinates of the centre of gravity of the edge.
     * \param[in] val_coord_FaceElem_CG - Coordinates of the centre of gravity of the face of an element.
     * \param[in] val_coord_Elem_CG - Coordinates of the centre of gravity of the element.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void SetNodes_Coord(double *val_coord_Edge_CG, double *val_coord_FaceElem_CG, double *val_coord_Elem_CG) = 0;
    
    /*!
     * \overload
     * \param[in] val_coord_Edge_CG - Coordinates of the centre of gravity of the edge.
     * \param[in] val_coord_Elem_CG - Coordinates of the centre of gravity of the element.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void SetNodes_Coord(double *val_coord_Edge_CG, double *val_coord_Elem_CG) = 0;
    
    /*!
     * \brief A pure virtual member.
     * \param[in] val_normal - Coordinates of the normal.
     */
    virtual void GetNormal(double *val_normal) = 0;
    
    /*!
     * \brief A pure virtual member.
     */
    virtual double *GetNormal(void) = 0;
    
    /*!
     * \brief A pure virtual member.
     * \param[in] val_face_normal - Coordinates of the normal.
     */
    virtual void SetNormal(double *val_face_normal) = 0;
    
    /*!
     * \brief A pure virtual member.
     */
    virtual unsigned short GetnNodes(void) = 0;
    
    /*!
     * \brief A pure virtual member.
     */
    virtual void SetZeroValues(void) = 0;
    
    /*!
     * \brief A pure virtual member.
     * \param[in] val_face_normal - Normal vector to be added.
     */
    virtual void AddNormal(double *val_face_normal) = 0;
};

/*!
 * \class CPoint
 * \brief Class for point definition (including control volume definition).
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CPoint : public CDualGrid {
private:
    unsigned short nElem,	/*!< \brief Number of elements that set up the control volume. */
    nPoint;					/*!< \brief Number of points that set up the control volume  */
    vector<long> Elem;		/*!< \brief Elements that set up a control volume around a node. */
    vector<unsigned long> Point;	/*!< \brief Points surrounding the central node of the control volume. */
    vector<long> Edge;		/*!< \brief Edges that set up a control volume. */
    double *Volume;	/*!< \brief Volume or Area of the control volume in 3D and 2D. */
    bool Domain,		/*!< \brief Indicates if a point must be computed or belong to another boundary */
    Boundary,       /*!< \brief To see if a point belong to the boundary (including MPI). */
    PhysicalBoundary,			/*!< \brief To see if a point belong to the physical boundary (without includin MPI). */
    SolidBoundary;			/*!< \brief To see if a point belong to the physical boundary (without includin MPI). */
    long *vertex; /*!< \brief Index of the vertex that correspond which the control volume (we need one for each marker in the same node). */
    double *coord,	/*!< \brief vector with the coordinates of the node. */
    *Coord_old,		/*!< \brief Old coordinates vector for geometry smoothing. */
    *Coord_sum,		/*!< \brief Sum of coordinates vector for geometry smoothing. */
    *Coord_n,		/*!< \brief Coordinates at time n for use with dynamic meshes. */
    *Coord_n1,		/*!< \brief Coordinates at time n-1 for use with dynamic meshes. */
    *Coord_p1;		/*!< \brief Coordinates at time n+1 for use with dynamic meshes. */
    double *GridVel;	/*!< \brief Velocity of the grid for dynamic mesh cases. */
    double **GridVel_Grad;  /*!< \brief Gradient of the grid velocity for dynamic meshes. */
    unsigned long Parent_CV;			/*!< \brief Index of the parent control volume in the agglomeration process. */
    unsigned short nChildren_CV;		/*!< \brief Number of children in the agglomeration process. */
    vector<unsigned long> Children_CV;		/*!< \brief Index of the children control volumes in the agglomeration process. */
    bool Agglomerate_Indirect;					/*!< \brief This flag indicates if the indirect points can be agglomerated. */
    bool Agglomerate;					/*!< \brief This flag indicates if the element has been agglomerated. */
    bool Move;					/*!< \brief This flag indicates if the point is going to be move in the grid deformation process. */
    unsigned short color;	/*!< \brief Color of the point in the partitioning strategy. */
    double Wall_Distance;	/*!< \brief Distance to the nearest wall. */
    double SharpEdge_Distance;	/*!< \brief Distance to a sharp edge. */
    double Curvature;	/*!< \brief Value of the surface curvature (SU2_GEO). */
    unsigned long GlobalIndex;	/*!< \brief Global index in the parallel simulation. */
    unsigned short nNeighbor;	/*!< \brief Color of the point in the partitioning strategy. */
    bool Flip_Orientation;	/*!< \brief Flip the orientation of the normal. */
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_globalindex Global index in the parallel simulation.
     * \param[in] config - Definition of the particular problem.
     */
    CPoint(unsigned short val_nDim, unsigned long val_globalindex, CConfig *config);
    
    /*!
     * \overload
     * \param[in] val_coord_0 First coordinate of the point.
     * \param[in] val_coord_1 Second coordinate of the point.
     * \param[in] val_globalindex Global index in the parallel simulation.
     * \param[in] config - Definition of the particular problem.
     */
    CPoint(double val_coord_0, double val_coord_1, unsigned long val_globalindex, CConfig *config);
    
    /*!
     * \overload
     * \param[in] val_coord_0 First coordinate of the point.
     * \param[in] val_coord_1 Second coordinate of the point.
     * \param[in] val_coord_2 Third coordinate of the point.
     * \param[in] val_globalindex Global index in the parallel simulation.
     * \param[in] config - Definition of the particular problem.
     */
    CPoint(double val_coord_0, double val_coord_1, double val_coord_2, unsigned long val_globalindex, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CPoint(void);
    
    /*!
     * \brief For parallel computation, its indicates if a point must be computed or not.
     * \param[in] val_domain - <code>TRUE</code> if the point belong to the domain; otherwise <code>FALSE</code>.
     */
    void SetDomain(bool val_domain);
    
    /*!
     * \brief For parallel computation, its indicates if a point must be computed or not.
     * \return <code>TRUE</code> if the node belong to the physical domain; otherwise <code>FALSE</code>.
     */
    bool GetDomain(void);
    
    /*!
     * \brief Set the value of the distance to the nearest wall.
     * \param[in] val_distance - Value of the distance.
     */
    void SetWall_Distance(double val_distance);
    
    /*!
     * \brief Set the value of the distance to a sharp edge.
     * \param[in] val_distance - Value of the distance.
     */
    void SetSharpEdge_Distance(double val_distance);
    
    /*!
     * \brief Get the value of the distance to the nearest wall.
     * \return Value of the distance to the nearest wall.
     */
    double GetWall_Distance(void);
    
    /*!
     * \brief Set the value of the curvature at a surface node.
     * \param[in] val_distance - Value of the curvature.
     */
    void SetCurvature(double val_curvature);
    
    /*!
     * \brief Get the value of the curvature at a surface node.
     * \return Value of the curvature.
     */
    double GetCurvature(void);
    
    /*!
     * \brief Get the value of the distance to a sharp edge
     * \return Value of the distance to the nearest wall.
     */
    double GetSharpEdge_Distance(void);
    
    /*!
     * \brief Set the number of elements that compose the control volume.
     * \param[in] val_nElem - Number of elements that make the control volume around a node.
     */
    void SetnElem(unsigned short val_nElem);
    
    /*!
     * \brief Set the number of points that compose the control volume.
     * \param[in] val_nPoint - Number of points that compose the control volume (points surrounding points).
     */
    void SetnPoint(unsigned short val_nPoint);
    
    /*!
     * \brief Get the coordinates dor the control volume.
     * \param[in] val_dim - Number of dimensions of the problem.
     * \return Coordinate that correspond with <i>val_dim</i>.
     */
    double GetCoord(unsigned short val_dim);
    
    /*!
     * \brief Get the coordinates of the control volume.
     * \return pointer to the coordinate of the point.
     */
    double *GetCoord(void);
    
    /*!
     * \brief Set the coordinates for the control volume.
     * \param[in] val_dim - Position to store the coordinate.
     * \param[in] val_coord - Coordinate for val_dim.
     */
    void SetCoord(unsigned short val_dim, double val_coord);
    
    /*!
     * \brief Get the coordinates of the control volume.
     * \return pointer to the coordinate of the point.
     */
    bool GetFlip_Orientation(void);
    
    /*!
     * \brief Set the coordinates for the control volume.
     * \param[in] val_dim - Position to store the coordinate.
     * \param[in] val_coord - Coordinate for val_dim.
     */
    void SetFlip_Orientation(void);
    
    /*!
     * \brief Set the coordinates for the control volume.
     * \param[in] val_dim - Position to store the coordinate.
     * \param[in] val_coord - Coordinate for val_dim.
     */
    void AddCoord(unsigned short val_dim, double val_coord);
    
    /*!
     * \overload
     * \param[in] val_coord - Coordinate of the point.
     */
    void SetCoord(double *val_coord);
    
    /*!
     * \brief Get the number of elements that compose the control volume.
     * \return Number of elements that compose the control volume.
     */
    unsigned short GetnElem(void);
    
    /*!
     * \brief Get the number of points that compose the control volume.
     * \return Number of points that compose the control volume.
     */
    unsigned short GetnPoint(void);
    
    /*!
     * \brief Set the elements that set the control volume.
     * \param[in] val_elem - Element to be added.
     */
    void SetElem(unsigned long val_elem);
    
    /*!
     * \brief Reset the elements of a control volume.
     */
    void ResetElem(void);
    
    /*!
     * \brief Reset the points that compose the control volume.
     */
    void ResetPoint(void);
    
    /*!
     * \brief Set the points that compose the control volume.
     * \param[in] val_point - Point to be added.
     */
    void SetPoint(unsigned long val_point);
    
    /*!
     * \brief Set the edges that compose the control volume.
     * \param[in] val_edge - Edge to be added.
     * \param[in] val_nEdge - Position in which is going to be stored the edge for each control volume.
     */
    void SetEdge(long val_edge, unsigned short val_nEdge);
    
    /*!
     * \brief Set the boundary vertex that compose the control volume.
     * \param[in] val_vertex - Vertex to be added.
     * \param[in] val_nMarker - Marker of the vertex to be added (position where is going to be stored).
     */
    void SetVertex(long val_vertex, unsigned short val_nMarker);
    
    /*!
     * \brief Get all the elements that compose the control volume.
     * \param[in] val_elem - Position where the element is stored.
     * \return Index of the element.
     */
    unsigned long GetElem(unsigned short val_elem);
    
    /*!
     * \brief Get all the points that compose the control volume.
     * \param[in] val_point - Position where the point is stored.
     * \return Index of the point.
     */
    unsigned long GetPoint(unsigned short val_point);
    
    /*!
     * \brief Get all the edges that compose the control volume.
     * \param[in] val_edge - Position where the edge is stored.
     * \return Index of the edge.
     */
    long GetEdge(unsigned short val_edge);
    
    /*!
     * \brief Get the vertex that compose the control volume for a marker.
     * \param[in] val_marker - Position where the vertex is stored.
     * \return Index of the vertex.
     */
    long GetVertex(unsigned short val_marker);
    
    /*!
     * \brief Adds some area or volume of the CV.
     * \param[in] val_Volume - Local volume to be added to the total one.
     */
    void AddVolume(double val_Volume);
    
    /*!
     * \brief Get area or volume of the control volume.
     * \return Area or volume of the control volume.
     */
    double GetVolume(void);
    
    /*!
     * \brief Get information about the movement of the node.
     * \return <code>TRUE</code> if the point is going to be moved; otherwise <code>FALSE</code>.
     */
    bool GetMove(void);
    
    /*!
     * \brief Set if a point belong to the boundary.
     * \note It also create the structure to store the vertex.
     * \param[in] val_nmarker - Max number of marker.
     */
    void SetBoundary(unsigned short val_nmarker);
    
    /*!
     * \brief Reset the boundary of a control volume.
     */
    void ResetBoundary(void);
    
    /*!
     * \overload
     * \param[in] val_boundary - <code>TRUE</code> if the point belong to the boundary; otherwise <code>FALSE</code>.
     */
    void SetBoundary(bool val_boundary);
    
    /*!
     * \brief Provides information about if a point belong to the boundaries.
     * \return <code>TRUE</code> if the point belong to the boundary; otherwise <code>FALSE</code>.
     */
    bool GetBoundary(void);
    
    /*!
     * \brief Set if a point belong to the boundary.
     * \param[in] val_boundary - <code>TRUE</code> if the point belong to the physical boundary; otherwise <code>FALSE</code>.
     */
    void SetPhysicalBoundary(bool val_boundary);
    
    /*!
     * \brief Set if a point belong to the boundary.
     * \param[in] val_boundary - <code>TRUE</code> if the point belong to the physical boundary; otherwise <code>FALSE</code>.
     */
    void SetSolidBoundary(bool val_boundary);
    
    /*!
     * \brief Provides information about if a point belong to the physical boundaries (without MPI).
     * \return <code>TRUE</code> if the point belong to the boundary; otherwise <code>FALSE</code>.
     */
    bool GetPhysicalBoundary(void);
    
    /*!
     * \brief Provides information about if a point belong to the physical boundaries (without MPI).
     * \return <code>TRUE</code> if the point belong to the boundary; otherwise <code>FALSE</code>.
     */
    bool GetSolidBoundary(void);
    
    /*!
     * \brief Set a color to the point that comes from the grid partitioning.
     * \note Each domain has a different color.
     * \param[in] val_color - Color of the point.
     */
    void SetColor(unsigned short val_color);
    
    /*!
     * \brief Set the number of neighbor (artificial dissipation).
     * \param[in] val_nneighbor - Number of neighbors.
     */
    void SetnNeighbor(unsigned short val_nneighbor);
    
    /*!
     * \brief Get the number of neighbor of a point.
     * \return Number of neighbors.
     */
    unsigned short GetnNeighbor(void);
    
    /*!
     * \brief Get the color of a point, the color indicates to which subdomain the point belong to.
     * \return Color of the point.
     */
    unsigned short GetColor(void);
    
    /*!
     * \brief Get the global index in a parallel computation.
     * \return Global index in a parallel computation.
     */
    unsigned long GetGlobalIndex(void);
    
    /*!
     * \brief Set the global index in a parallel computation.
     * \return Global index in a parallel computation.
     */
    void SetGlobalIndex(unsigned long val_globalindex);
    
    /*!
     * \brief Get the volume of the control volume at time n.
     * \return Volume of the control volume at time n
     */
    double GetVolume_n(void);
    
    /*!
     * \brief Get the volume of the control volume at time n+1.
     * \return Volume of the control volume at time n+1
     */
    double GetVolume_nM1(void);
    
    /*!
     * \brief Set the volume of the control volume at time n.
     */
    void SetVolume_n(void);
    
    /*!
     * \brief Set the volume of the control volume at time n+1.
     */
    void SetVolume_nM1(void);
    
    /*!
     * \brief Get the coordinates of the control volume at time n.
     * \return Coordinates of the control volume at time n.
     */
    double* GetCoord_n(void);
    
    /*!
     * \brief Get the coordinates of the control volume at time n-1.
     * \return Volume of the control volume at time n-1
     */
    double* GetCoord_n1(void);
    
    /*!
     * \brief Get the coordinates of the control volume at time n+1.
     * \return Volume of the control volume at time n+1
     */
    double* GetCoord_p1(void);
    
    /*!
     * \brief Set the coordinates of the control volume at time n.
     */
    void SetCoord_n(void);
    
    /*!
     * \brief Set the coordinates of the control volume at time n-1.
     */
    void SetCoord_n1(void);
    
    /*!
     * \brief Set the coordinates of the control volume at time n+1.
     * \param[in] val_coord - Value of the grid coordinates at time n+1.
     */
    void SetCoord_p1(double *val_coord);
    
    /*!
     * \brief Set the volume of the control volume.
     * \param[in] val_Volume - Value of the volume.
     */
    void SetVolume(double val_Volume);
    
    /*!
     * \brief Set if a element is going to be moved on the deformation process.
     * \param[in] val_move - true or false depending if the point will be moved.
     */
    void SetMove(bool val_move);
    
    /*!
     * \brief Set the parent control volume of an agglomerated control volume.
     * \param[in] val_parent_CV - Index of the parent control volume.
     */
    void SetParent_CV(unsigned long val_parent_CV);
    
    /*!
     * \brief Set the children control volumes of an agglomerated control volume.
     * \param[in] val_nchildren_CV - Number of children.
     * \param[in] val_children_CV - Index of the children control volume.
     */
    void SetChildren_CV(unsigned short val_nchildren_CV, unsigned long val_children_CV);
    
    /*!
     * \brief Get the parent control volume of an agglomerated control volume.
     * \return Index of the parent control volume.
     */
    unsigned long GetParent_CV(void);
    
    /*!
     * \brief Get the children control volume of an agglomerated control volume.
     * \param[in] val_nchildren_CV - Number of the children.
     * \return Index of the parent control volume.
     */
    unsigned long GetChildren_CV(unsigned short val_nchildren_CV);
    
    /*!
     * \brief Get information about if a control volume has been agglomerated.
     * \return <code>TRUE</code> if the point has been agglomerated; otherwise <code>FALSE</code>.
     */
    bool GetAgglomerate(void);
    
    /*!
     * \brief Get information about if the indirect neighbors can be agglomerated.
     * \return <code>TRUE</code> if the indirect neigbors can be agglomerated; otherwise <code>FALSE</code>.
     */
    bool GetAgglomerate_Indirect(void);
    
    /*!
     * \brief Set information about if the indirect neighbors can be agglomerated.
     * \param[in] val_agglomerate - The indirect neigbors can be agglomerated.
     */
    void SetAgglomerate_Indirect(bool val_agglomerate);
    
    /*!
     * \brief Get the number of children of an agglomerated control volume.
     * \return Number of children control volume.
     */
    unsigned short GetnChildren_CV(void);
    
    /*!
     * \brief Set the number of children of an agglomerated control volume.
     * \param[in] val_nchildren_CV - Number of children of the control volume.
     */
    void SetnChildren_CV(unsigned short val_nchildren_CV);
    
    /*!
     * \brief Get the value of the summed coordinates for implicit smoothing.
     * \return Sum of coordinates at a point.
     */
    double *GetCoord_Sum(void);
    
    /*!
     * \brief Get the value of the old coordinates for implicit smoothing.
     * \return Old coordinates at a point.
     */
    double *GetCoord_Old(void);
    
    /*!
     * \brief Get the value of the grid velocity at the point.
     * \return Grid velocity at the point.
     */
    double *GetGridVel(void);
    
    /*!
     * \brief Get the value of the grid velocity gradient at the point.
     * \return Grid velocity gradient at the point.
     */
    double **GetGridVel_Grad(void);
    
    /*!
     * \brief Add the value of the coordinates to the <i>Coord_sum</i> vector for implicit smoothing.
     * \param[in] val_coord_sum - Value of the coordinates to add.
     */
    void AddCoord_Sum(double *val_coord_sum);
    
    /*!
     * \brief Initialize the vector <i>Coord_sum</i>.
     */
    void SetCoord_SumZero(void);
    
    /*!
     * \brief Set the value of the vector <i>Coord_old</i> for implicit smoothing.
     * \param[in] val_coord_old - Value of the coordinates.
     */
    void SetCoord_Old(double *val_coord_old);
    
    /*!
     * \brief Set the value of the grid velocity at the point.
     * \param[in] val_dim - Index of the coordinate.
     * \param[in] val_gridvel - Value of the grid velocity.
     */
    void SetGridVel(unsigned short val_dim, double val_gridvel);
    
    /*!
     * \overload
     * \param[in] val_gridvel - Value of the grid velocity.
     */
    void SetGridVel(double *val_gridvel);
    
    /*!
     * \brief Set the gradient of the grid velocity.
     * \param[in] val_var - Index of the variable.
     * \param[in] val_dim - Index of the dimension.
     * \param[in] val_value - Value of the gradient.
     */
    void SetGridVel_Grad(unsigned short val_var, unsigned short val_dim, double val_value);
    
    /*!
     * \brief This function does nothing (it comes from a pure virtual function, that implies the
     *        definition of the function in all the derived classes).
     */
    void SetNodes_Coord(double *val_coord_Edge_CG, double *val_coord_FaceElem_CG, double *val_coord_Elem_CG);
    
    /*!
     * \brief This function does nothing (it comes from a pure virtual function, that implies the
     *        definition of the function in all the derived classes).
     */
    void SetNodes_Coord(double *val_coord_Edge_CG, double *val_coord_Elem_CG);
    
    /*!
     * \brief This function does nothing (it comes from a pure virtual function, that implies the
     *        definition of the function in all the derived classes).
     */
    void GetNormal(double *val_normal);
    
    /*!
     * \brief This function does nothing (it comes from a pure virtual function, that implies the
     *		  definition of the function in all the derived classes).
     */
    double *GetNormal(void);
    
    /*!
     * \brief This function does nothing (it comes from a pure virtual function, that implies the
     *        definition of the function in all the derived classes).
     */
    void SetNormal(double *val_face_normal);
    
    /*!
     * \brief This function does nothing (it comes from a pure virtual function, that implies the
     *        definition of the function in all the derived classes).
     */
    unsigned short GetnNodes(void);
    
    /*!
     * \brief This function does nothing (it comes from a pure virtual function, that implies the
     *        definition of the function in all the derived classes).
     */
    void SetZeroValues(void);
    
    /*!
     * \brief This function does nothing (it comes from a pure virtual function, that implies the
     *        definition of the function in all the derived classes).
     */
    void AddNormal(double *val_face_normal);
};

/*!
 * \class CEdge
 * \brief Class for defining an edge.
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CEdge : public CDualGrid {
private:
    double *Coord_CG;			/*!< \brief Center-of-gravity of the element. */
    unsigned long *Nodes;		/*!< \brief Vector to store the global nodes of an element. */
    double *Normal;				/*!< \brief Normal al elemento y coordenadas de su centro de gravedad. */
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_iPoint - First node of the edge.
     * \param[in] val_jPoint - Second node of the edge.
     * \param[in] val_nDim - Number of dimensions of the problem.
     */
    CEdge(unsigned long val_iPoint, unsigned long val_jPoint, unsigned short val_nDim);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CEdge(void);
    
    /*!
     * \brief Set the center of gravity of the edge.
     * \param[in] val_coord - Coordinates of all the nodes needed for computing the centre of gravity of an edge.
     */
    void SetCG(double **val_coord);
    
    /*!
     * \brief Obtain the centre of gravity of the edge.
     * \param[in] val_dim - Position to read the coordinate.
     * \return Coordinate <i>val_dim</i> of the centre of gravity.
     */
    double GetCG(unsigned short val_dim);
    
    /*!
     * \brief Get the nodes of the edge.
     * \param[in] val_node - Position of the node that makes the edge.
     * \return Index of the node that compose the edge.
     */
    
    unsigned long GetNode(unsigned short val_node);
    
    /*!
     * \brief Get the number of nodes of an element.
     * \return Number of nodes that set an edge (2).
     */
    unsigned short GetnNodes(void);
    
    /*!
     * \brief Compute Volume associated to each edge.
     * \param[in] val_coord_Edge_CG - Coordinates of the centre of gravity of the edge.
     * \param[in] val_coord_FaceElem_CG - Coordinates of the centre of gravity of the face of an element.
     * \param[in] val_coord_Elem_CG - Coordinates of the centre of gravity of the element.
     * \param[in] val_coord_Point - Coordinates of the point that form the control volume.
     * \return Local volume associated to the edge.
     */
    double GetVolume(double *val_coord_Edge_CG, double *val_coord_FaceElem_CG, double *val_coord_Elem_CG, double *val_coord_Point);
    
    /*!
     * \overload
     * \param[in] val_coord_Edge_CG - Coordinates of the centre of gravity of the edge.
     * \param[in] val_coord_Elem_CG - Coordinates of the centre of gravity of the element.
     * \param[in] val_coord_Point - Coordinates of the point that form the control volume.
     * \return Local volume associated to the edge.
     */
    double GetVolume(double *val_coord_Edge_CG, double *val_coord_Elem_CG, double *val_coord_Point);
    
    /*!
     * \brief Set the face that correspond to an edge.
     * \param[in] val_coord_Edge_CG - Coordinates of the centre of gravity of the edge.
     * \param[in] val_coord_FaceElem_CG - Coordinates of the centre of gravity of the face of an element.
     * \param[in] val_coord_Elem_CG - Coordinates of the centre of gravity of the element.
     * \param[in] config - Definition of the particular problem.
     * \return Compute the normal (dimensional) to the face that makes the control volume boundaries.
     */
    void SetNodes_Coord(double *val_coord_Edge_CG, double *val_coord_FaceElem_CG, double *val_coord_Elem_CG);
    
    /*!
     * \overload
     * \brief Set the face that correspond to an edge.
     * \param[in] val_coord_Edge_CG - Coordinates of the centre of gravity of the edge.
     * \param[in] val_coord_Elem_CG - Coordinates of the centre of gravity of the element.
     * \param[in] config - Definition of the particular problem.
     * \return Compute the normal (dimensional) to the face that makes the contorl volume boundaries.
     */
    void SetNodes_Coord(double *val_coord_Edge_CG, double *val_coord_Elem_CG);
    
    /*!
     * \brief Copy the the normal vector of a face.
     * \param[in] val_normal - Vector where the subroutine is goint to copy the normal (dimensional).
     */
    void GetNormal(double *val_normal);
    
    /*!
     * \brief Get the normal to a face of the control volume asociated with an edge.
     * \return Dimensional normal vector, the modulus is the area of the face.
     */
    double *GetNormal(void);
    
    /*!
     * \brief Initialize normal vector.
     */
    void SetZeroValues(void);
    
    /*!
     * \brief Set the normal vector.
     * \param[in] val_face_normal - Vector to initialize the normal vector.
     * \return Value of the normal vector.
     */
    void SetNormal(double *val_face_normal);
    
    /*!
     * \brief Add a vector to the normal vector.
     * \param[in] val_face_normal - Vector to add to the normal vector.
     */
    void AddNormal(double *val_face_normal);
    
    /*!
     * \brief This function does nothing (it comes from a pure virtual function, that implies the
     *        definition of the function in all the derived classes).
     */
    double *GetCoord(void);
    
    /*!
     * \brief This function does nothing (it comes from a pure virtual function, that implies the
     *        definition of the function in all the derived classes).
     */
    void SetCoord(double *val_coord);
    
};

/*!
 * \class CVertex
 * \brief Class for vertex definition (equivalent to edges, but for the boundaries).
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CVertex : public CDualGrid {
private:
    unsigned long *Nodes;	/*!< \brief Vector to store the global nodes of an element. */
    double *Normal;			/*!< \brief Normal coordinates of the element and its center of gravity. */
    double Aux_Var;			/*!< \brief Auxiliar variable defined only on the surface. */
    double CartCoord[3];		/*!< \brief Vertex cartesians coordinates. */
    double VarCoord[3];		/*!< \brief Used for storing the coordinate variation due to a surface modification. */
    long PeriodicPoint[2];			/*!< \brief Store the periodic point of a boundary (iProcessor, iPoint) */
    short Rotation_Type;			/*!< \brief Type of rotation associated with the vertex (MPI and periodic) */
    unsigned long Normal_Neighbor; /*!< \brief Index of the closest neighbor. */
    unsigned long Donor_Elem;   /*!< \brief Store the donor element for interpolation across zones/ */
    double Basis_Function[3]; /*!< \brief Basis function values for interpolation across zones. */
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_point - Node of the vertex.
     * \param[in] val_nDim - Number of dimensions of the problem.
     */
    CVertex(unsigned long val_point, unsigned short val_nDim);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CVertex(void);
    
    /*!
     * \brief Get the number of nodes of a vertex.
     * \return Number of nodes that set a vertex (1).
     */
    unsigned short GetnNodes(void);
    
    /*!
     * \brief Get the node of the vertex.
     * \return Index of the node that compose the vertex.
     */
    unsigned long GetNode(void);
    
    /*!
     * \brief Set the face that correspond to a vertex.
     * \param[in] val_coord_Edge_CG - Coordinates of the centre of gravity of the edge.
     * \param[in] val_coord_FaceElem_CG - Coordinates of the centre of gravity of the face of an element.
     * \param[in] val_coord_Elem_CG - Coordinates of the centre of gravity of the element.
     * \return Compute the normal (dimensional) to the face that makes the vertex.
     */
    void SetNodes_Coord(double *val_coord_Edge_CG, double *val_coord_FaceElem_CG, double *val_coord_Elem_CG);
    
    /*!
     * \overload
     * \param[in] val_coord_Edge_CG - Coordinates of the centre of gravity of the edge.
     * \param[in] val_coord_Elem_CG - Coordinates of the centre of gravity of the element.
     * \return Compute the normal (dimensional) to the face that makes the vertex.
     */
    void SetNodes_Coord(double *val_coord_Edge_CG, double *val_coord_Elem_CG);
    
    /*!
     * \brief Copy the the normal vector of a face.
     * \param[in] val_normal - Vector where the subroutine is goint to copy the normal (dimensional).
     */
    void GetNormal(double *val_normal);
    
    /*!
     * \brief Get the normal to a face of the control volume asociated with a vertex.
     * \return Dimensional normal vector, the modulus is the area of the face.
     */
    double *GetNormal(void);
    
    /*!
     * \brief Initialize normal vector.
     */
    void SetZeroValues(void);
    
    /*!
     * \brief Set the value of an auxiliary variable for gradient computation.
     * \param[in] val_auxvar - Value of the auxiliar variable.
     */
    void SetAuxVar(double val_auxvar);
    
    /*!
     * \brief Get the value of an auxiliary variable for gradient computation.
     * \return Value of the auxiliar variable.
     */
    double GetAuxVar(void);
    
    /*!
     * \brief Add the value of an auxiliary variable for gradient computation.
     * \param[in] val_auxvar - Value of the auxiliar variable.
     */
    void AddAuxVar(double val_auxvar);
    
    /*!
     * \brief Set the normal vector.
     * \param[in] val_face_normal - Vector to initialize the normal vector.
     * \return Value of the normal vector.
     */
    void SetNormal(double *val_face_normal);
    
    /*!
     * \brief Add a vector to the normal vector.
     * \param[in] val_face_normal - Vector to add to the normal vector.
     */
    void AddNormal(double *val_face_normal);
    
    /*!
     * \brief Set the value of the coordinate variation due to a surface modification.
     * \param[in] val_varcoord - Variation of the coordinate.
     */
    void SetVarCoord(double *val_varcoord);
    
    /*!
     * \brief Add the value of the coordinate variation due to a surface modification.
     * \param[in] val_varcoord - Variation of the coordinate.
     */
    void AddVarCoord(double *val_varcoord);
    
    /*!
     * \brief Get the value of the coordinate variation due to a surface modification.
     * \return Variation of the coordinate.
     */
    double *GetVarCoord(void);
    
    /*!
     * \brief Set the value of the cartesian coordinate for the vertex.
     * \param[in] val_coord - Value of the cartesian coordinate.
     */
    void SetCoord(double *val_coord);
    
    /*!
     * \brief Get the value of the cartesian coordinate for the vertex.
     * \return Value of the cartesian coordinate of the vertex.
     */
    double *GetCoord(void);
    
    /*!
     * \brief Get the value of the cartesian coordinate for the vertex.
     * \param[in] val_dim - Variable of the dimension.
     * \return Value of the cartesian coordinate of the vertex.
     */
    double GetCoord(unsigned short val_dim);
    
    /*! 
     * \brief Set the type of rotation associated to the vertex.
     * \param[in] val_rotation_type - Value of the rotation that will be applied to the solution at the vertex
     */
    void SetRotation_Type(short val_rotation_type);
    
    /*! 
     * \brief Get the type of rotation associated to the vertex.
     * \return Value of the rotation that must be applied to the solution of the vertex
     */
    short GetRotation_Type(void);
    
    /*! 
     * \overload
     * \param[in] val_periodicpoint - Value of periodic point of the vertex.
     * \param[in] val_processor - Processor where the point belong.
     */
    void SetDonorPoint(long val_periodicpoint, long val_processor);
    
    /*! 
     * \brief Get the value of the periodic point of a vertex.
     * \return Value of the periodic point of a vertex.
     */
    long GetDonorPoint(void);
    
    /*!
     * \brief Get the value of the periodic point of a vertex.
     * \return Value of the periodic point of a vertex.
     */
    long GetDonorProcessor(void);
    
    /*! 
     * \brief Get the value of the periodic point of a vertex, and its somain
     * \return Value of the periodic point of a vertex, and the domain.
     */
    long *GetPeriodicPointDomain(void);	
    
    /*!
     * \brief Set the donor element of a vertex for interpolation across zones.
     * \param[in] val_donorelem - donor element index.
     */
    void SetDonorElem(long val_donorelem);
    
    /*!
     * \brief Get the donor element of a vertex for interpolation across zones.
     * \return Value of the donor element of a vertex.
     */
    long GetDonorElem(void);
    
    /*!
     * \brief Set the finite element basis functions needed for interpolation.
     * \param[in] val_node - a node index of the owner element.
     * \param[in] val_basis - basis function value for the node.
     */
    void SetBasisFunction(unsigned short val_node, double val_basis);
    
    /*!
     * \brief Get the finite element basis functions needed for interpolation.
     * \param[in] val_node - a node index of the owner element.
     * \return Value of the basis function for this node.
     */
    double GetBasisFunction(unsigned short val_node);
    
    /*! 
     * \brief Set the index of the closest neighbor to a point on the boundaries.
     * \param[in] val_Normal_Neighbor - Index of the closest neighbor.
     */
    void SetNormal_Neighbor(unsigned long val_Normal_Neighbor);
    
    /*! 
     * \brief Get the value of the closest neighbor.
     * \return Index of the closest neighbor.
     */
    unsigned long GetNormal_Neighbor(void);
    
};


/* Primal_grid_structure.hpp------------------------------------------------------------
 *
 *
 *
 */

/*!
 * \class CPrimalGrid
 * \brief Class to define the numerical primal grid.
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CPrimalGrid {
protected:
    unsigned long *Nodes;         /*!< \brief Vector to store the global nodes of an element. */
    long *Neighbor_Elements;      /*!< \brief Vector to store the elements surronding an element. */
    double *Coord_CG;             /*!< \brief Coordinates of the center-of-gravity of the element. */
    double **Coord_FaceElems_CG;	/*!< \brief Coordinates of the center-of-gravity of the face of the
                                     elements. */
    static unsigned short nDim;		/*!< \brief Dimension of the element (2D or 3D) useful for triangles,
                                     rectangles and edges. */
    unsigned long DomainElement;	/*!< \brief Only for boundaries, in this variable the 3D elements which
                                     correspond with a boundary element is stored. */
    bool Divide;                  /*!< \brief Marker used to know if we are going to divide this element
                                   in the adaptation proccess. */
    
public:
    
    /*!
     * \brief Constructor of the class.
     */
    CPrimalGrid(void);
    
    /*!
     * \overload
     * \param[in] val_nNodes - Number of nodes of the element.
     * \param[in] val_nFaces - Number of faces of the element.
     * \param[in] val_VTK_Type - Type of the element using the vtk nomenclature.
     */
    CPrimalGrid(unsigned short val_nNodes, unsigned short val_nFaces, unsigned short val_VTK_Type);
    
    /*!
     * \brief Destructor of the class.
     */
    virtual ~CPrimalGrid(void);
    
    /*!
     * \brief Get the elements that surround an element.
     * \param[in] val_face - Local index of the face.
     * \return Global index of the element.
     */
    long GetNeighbor_Elements(unsigned short val_face);
    
    /*!
     * \brief Set the elements that surround an element.
     * \param[in] val_elem - Global index of the element.
     * \param[in] val_face - Local index of the face.
     */
    void SetNeighbor_Elements(unsigned long val_elem, unsigned short val_face);
    
    /*!
     * \brief Set the center of gravity of an element (including edges).
     * \param[in] val_coord - Coordinates of the element.
     */
    void SetCG(double **val_coord);
    
    /*!
     * \brief Get the center of gravity of an element (including edges).
     * \param[in] val_dim - Coordinate of the center of gravity.
     * \return Coordinates of the center of gravity.
     */
    double GetCG(unsigned short val_dim);
    
    /*!
     * \brief Get the CG of a face of an element.
     * \param[in] val_face - Local index of the face.
     * \param[in] val_dim - Coordinate of the center of gravity.
     * \return Coordinates of the center of gravity.
     */
    double GetFaceCG(unsigned short val_face, unsigned short val_dim);
    
    /*!
     * \brief Get all the neighbors of an element.
     * \return List of all the neighbor of an element.
     */
    void GetAllNeighbor_Elements(void);
    
    /*!
     * \brief Set that an element must be divided in the adaptation stage.
     * \param[in] val_divide - <code>TRUE</code> if the element must be divided; otherwise <code>FALSE</code>.
     */
    void SetDivide(bool val_divide);
    
    /*!
     * \brief Get if an element must be divided in the adaptation stage.
     * \return <code>TRUE</code> if the element must be divided; otherwise <code>FALSE</code>.
     */
    bool GetDivide(void);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_domainelement Index of the domain element which has a face shared by this boundary element.
     */
    virtual void SetDomainElement(unsigned long val_domainelement);
    
    /*!
     * \brief A virtual member.
     * \return Relate the boundary element which a face of a domain element.
     */
    virtual unsigned long GetDomainElement(void);
    
    /*!
     * \brief A pure virtual member.
     */
    virtual void Change_Orientation(void) = 0;
    
    /*!
     * \brief A pure virtual member.
     * \return Kind of element using the vtk nomenclature.
     */
    virtual unsigned short GetVTK_Type(void) = 0;
    
    /*!
     * \brief A pure virtual member.
     * \return Type of the element using VTK nomenclature.
     */
    virtual unsigned short GetRotation_Type(void);
    
    /*!
     * \brief A pure virtual member.
     * \param[in] val_rotation_type - Kind of rotation/traslation that must be applied.
     */
    virtual void SetRotation_Type(unsigned short val_rotation_type);
    
    /*!
     * \brief A pure virtual member.
     * \param[in] val_node - Local index of the node.
     * \return Number of neighbors nodes of a node in the element.
     */
    virtual unsigned short GetnNeighbor_Nodes(unsigned short val_node) = 0;
    
    /*!
     * \brief A pure virtual member.
     * \return Number of neighbors elements of a element.
     */
    virtual unsigned short GetnNeighbor_Elements(void) = 0;
    
    /*!
     * \brief A pure virtual member.
     * \return Number of nodes of an element.
     */
    virtual unsigned short GetnNodes(void) = 0;
    
    /*!
     * \brief A pure virtual member.
     * \return Number of faces of an element.
     */
    virtual unsigned short GetnFaces(void) = 0;
    
    /*!
     * \brief A pure virtual member.
     * \param[in] val_face - Local index of a face.
     * \return Local index of the nodes that compose a face.
     */
    virtual unsigned short GetnNodesFace(unsigned short val_face) = 0;
    
    /*!
     * \brief A pure virtual member.
     * \return Maximum number of nodes that compose a face.
     */
    virtual unsigned short GetMaxNodesFace(void) = 0;
    
    /*!
     * \brief A pure virtual member.
     * \param[in] val_node - Local index of a node.
     * \return Global index of the node.
     */
    virtual unsigned long GetNode(unsigned short val_node) = 0;
    
    
    /*!
     * \brief A pure virtual member.
     * \param[in] val_node - Local index of a node.
     * \param[in] val_point - Point associated to the node.
     */
    virtual void SetNode(unsigned short val_node, unsigned long val_point);
    
    /*!
     * \brief A pure virtual member.
     * \param[in] val_face - Local index of the face.
     * \param[in] val_index - Local index of the nodes that compose the face.
     * \return - Local index of the nodes that compose the face.
     */
    virtual unsigned short GetFaces(unsigned short val_face, unsigned short val_index) = 0;
    
    /*!
     * \brief A pure virtual member.
     * \param[in] val_node - Local index of a node.
     * \param[in] val_index - Local (to the neighbor nodes of <i>val_node</i>) index of the nodes that
     are neighbor to val_node.
     * \return Local index of the nodes that are neighbor to <i>val_node</i>.
     */
    virtual unsigned short GetNeighbor_Nodes(unsigned short val_node, unsigned short val_index) = 0;
};

/*!
 * \class CVertexMPI
 * \brief Class for vertex element definition. This kind
 *        of element is used in the parallelization stuff.
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CVertexMPI : public CPrimalGrid {
private:
    static unsigned short nFaces;				/*!< \brief Number of faces of the element. */
    static unsigned short nNodes;				/*!< \brief Number of nodes of the element. */
    static unsigned short VTK_Type;				/*!< \brief Type of element using VTK nomenclature. */
    unsigned short Rotation_Type;			/*!< \brief Definition of the rotation, traslation of the
                                             solution at the vertex. */
    static unsigned short maxNodesFace;			/*!< \brief Maximum number of nodes for a face. */
    static unsigned short nNeighbor_Elements;	/*!< \brief Number of Neighbor_Elements. */
    
public:
    
    /*!
     * \brief Constructor using the nodes and index.
     * \param[in] val_point - Index of the 1st triangle point read from the grid file.
     * \param[in] val_nDim - Number of dimension of the problem (2D or 3D).
     */
    CVertexMPI(unsigned long val_point, unsigned short val_nDim);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CVertexMPI(void);
    
    /*!
     * \brief Get the nodes shared by the line.
     * \param[in] val_node - Local (to the line) index of the node (a line has 2 nodes).
     * \return Global index of the line node.
     */
    unsigned long GetNode(unsigned short val_node);
    
    /*!
     * \brief Set the point associated at a node.
     * \param[in] val_node - Local index of a node.
     * \param[in] val_point - Point associated to the node.
     */
    void SetNode(unsigned short val_node, unsigned long val_point);
    
    /*!
     * \brief Get the number of nodes of an element.
     * \return Number of nodes that composes an element.
     */
    unsigned short GetnNodes(void);
    
    /*!
     * \brief Get the type of the element using VTK nomenclature.
     * \return Type of the element using VTK nomenclature.
     */
    unsigned short GetVTK_Type(void);
    
    /*!
     * \brief Get the type of rotation/traslation that must be applied.
     * \return Type of the element using VTK nomenclature.
     */
    unsigned short GetRotation_Type(void);
    
    /*!
     * \brief Set the type of rotation/traslation that must be applied.
     * \param[in] val_rotation_type - Kind of rotation/traslation that must be applied.
     */
    void SetRotation_Type(unsigned short val_rotation_type);
    
    /*!
     * \brief This function does nothing (it comes from a pure virtual function, that implies the
     *        definition of the function in all the derived classes).
     */
    void Change_Orientation(void);
    
    /*!
     * \brief This function does nothing (it comes from a pure virtual function, that implies the
     *        definition of the function in all the derived classes).
     */
    unsigned short GetnNeighbor_Elements(void);
    
    /*!
     * \brief This function does nothing (it comes from a pure virtual function, that implies the
     *        definition of the function in all the derived classes).
     */
    unsigned short GetnNeighbor_Nodes(unsigned short val_node);
    
    /*!
     * \brief This function does nothing (it comes from a pure virtual function, that implies the
     *        definition of the function in all the derived classes).
     */
    unsigned short GetnFaces(void);
    
    /*!
     * \brief This function does nothing (it comes from a pure virtual function, that implies the
     *        definition of the function in all the derived classes).
     */
    unsigned short GetnNodesFace(unsigned short val_face);
    
    /*!
     * \brief This function does nothing (it comes from a pure virtual function, that implies the
     *        definition of the function in all the derived classes).
     */
    unsigned short GetMaxNodesFace(void);
    
    /*!
     * \brief This function does nothing (it comes from a pure virtual function, that implies the
     *        definition of the function in all the derived classes).
     */
    unsigned short GetFaces(unsigned short val_face, unsigned short val_index);
    
    /*!
     * \brief This function does nothing (it comes from a pure virtual function, that implies the
     *        definition of the function in all the derived classes).
     */
    unsigned short GetNeighbor_Nodes(unsigned short val_node, unsigned short val_index);
};

/*!
 * \class CLine
 * \brief Class for line element definition.
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CLine : public CPrimalGrid {
private:
    static unsigned short Faces[1][2];			/*!< \brief Matrix to store the local nodes of all the faces. */
    static unsigned short Neighbor_Nodes[2][1]; /*!< \brief Neighbor to a nodes in the element. */
    static unsigned short nNodesFace[1];		/*!< \brief Number of nodes of each face of the element. */
    static unsigned short nNeighbor_Nodes[2];	/*!< \brief Number of Neighbor to a nodes in the element. */
    static unsigned short nFaces;				/*!< \brief Number of faces of the element. */
    static unsigned short nNodes;				/*!< \brief Number of nodes of the element. */
    static unsigned short VTK_Type;				/*!< \brief Type of element using VTK nomenclature. */
    static unsigned short maxNodesFace;			/*!< \brief Maximum number of nodes for a face. */
    static unsigned short nNeighbor_Elements;	/*!< \brief Number of Neighbor_Elements. */
    
public:
    
    /*!
     * \brief Constructor using the nodes and index.
     * \param[in] val_point_0 - Index of the 1st triangle point read from the grid file.
     * \param[in] val_point_1 - Index of the 2nd triangle point read from the grid file.
     * \param[in] val_nDim - Number of dimension of the problem (2D or 3D).
     */
    CLine(unsigned long val_point_0, unsigned long val_point_1, unsigned short val_nDim);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CLine(void);
    
    /*!
     * \brief Get the nodes shared by the line.
     * \param[in] val_node - Local (to the line) index of the node (a line has 2 nodes).
     * \return Global index of the line node.
     */
    unsigned long GetNode(unsigned short val_node);
    
    /*!
     * \brief Set the point associated at a node.
     * \param[in] val_node - Local index of a node.
     * \param[in] val_point - Point associated to the node.
     */
    void SetNode(unsigned short val_node, unsigned long val_point);
    
    /*!
     * \brief Get the face index of and element.
     * \param[in] val_face - Local index of the face.
     * \param[in] val_index - Local (to the face) index of the nodes that compose the face.
     * \return Local (to the line) index of the nodes that compose the face.
     */
    unsigned short GetFaces(unsigned short val_face, unsigned short val_index);
    
    /*!
     * \brief Get the local index of the neighbors to a node (given the local index).
     * \param[in] val_node - Local (to the line) index of a node.
     * \param[in] val_index - Local (to the neighbor nodes of val_node) index of the nodes
     that are neighbor to val_node (each face is composed by 3 nodes).
     * \return Local (to the line) index of the nodes that are neighbor to val_node.
     */
    unsigned short GetNeighbor_Nodes(unsigned short val_node, unsigned short val_index);
    
    /*!
     * \brief Get the number of neighbors nodes of a node.
     * \param[in] val_node - Local (to the line) index of a node.
     * \return Number if neighbors of a node val_node.
     */
    unsigned short GetnNeighbor_Nodes(unsigned short val_node);
    
    /*!
     * \brief Get the number of nodes that composes a face of an element.
     * \param[in] val_face - Local index of the face.
     * \return Number of nodes that composes a face of an element.
     */
    unsigned short GetnNodesFace(unsigned short val_face);
    
    /*!
     * \brief Get the number of nodes of an element.
     * \return Number of nodes that composes an element.
     */
    unsigned short GetnNodes(void);
    
    /*!
     * \brief Get the number of faces of an element.
     * \return Number of faces of an element.
     */
    unsigned short GetnFaces(void);
    
    /*!
     * \brief Get the Maximum number of nodes of a face of an element.
     * \return Maximum number of nodes of a face of an element.
     */
    unsigned short GetMaxNodesFace(void);
    
    /*!
     * \brief Get the type of the element using VTK nomenclature.
     * \return Type of the element using VTK nomenclature.
     */
    unsigned short GetVTK_Type(void);
    
    /*!
     * \brief Get the number of element that are neighbor to this element.
     * \return Number of neighbor elements.
     */
    unsigned short GetnNeighbor_Elements(void);
    
    /*!
     * \brief Set the domain element which shares a face with the boundary element.
     * \param[in] val_domainelement - Global index of the element.
     */
    void SetDomainElement(unsigned long val_domainelement);
    
    /*!
     * \brief Get the domain element which shares a face with the boundary element.
     * \return Domain element which shares a face with the boundary element.
     */
    unsigned long GetDomainElement(void);
    
    /*!
     * \brief Change the orientation of an element.
     */
    void Change_Orientation(void);
};

/*!
 * \class CTriangle
 * \brief Class for triangle element definition.
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CTriangle : public CPrimalGrid {
private:
    static unsigned short Faces[3][2];			/*!< \brief Matrix to store the local nodes of all the faces. */
    static unsigned short Neighbor_Nodes[3][2];	/*!< \brief Neighbor to a nodes in the element. */
    static unsigned short nNodesFace[3];		/*!< \brief Number of nodes of each face of the element. */
    static unsigned short nNeighbor_Nodes[3];	/*!< \brief Number of Neighbor to a nodes in the element. */
    static unsigned short nFaces;				/*!< \brief Number of faces of the element. */
    static unsigned short nNodes;				/*!< \brief Number of nodes of the element. */
    static unsigned short VTK_Type;				/*!< \brief Type of element using VTK nomenclature. */
    static unsigned short maxNodesFace;			/*!< \brief Maximum number of nodes for a face. */
    static unsigned short nNeighbor_Elements;	/*!< \brief Number of Neighbor_Elements. */
    
public:
    
    /*!
     * \brief Constructor using the nodes and index.
     * \param[in] val_point_0 - Index of the 1st triangle point read from the grid file.
     * \param[in] val_point_1 - Index of the 2nd triangle point read from the grid file.
     * \param[in] val_point_2 - Index of the 3th triangle point read from the grid file.
     * \param[in] val_nDim - Number of dimension of the problem (2D or 3D), be careful a triangle could be 2D or 3D.
     */
    CTriangle(unsigned long val_point_0, unsigned long val_point_1,
              unsigned long val_point_2, unsigned short val_nDim);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CTriangle(void);
    
    /*!
     * \brief Get the nodes shared by the triangle.
     * \param[in] val_node - Local (to the triangle) index of the node (a triangle has 3 nodes).
     * \return Global index of the triangle node.
     */
    unsigned long GetNode(unsigned short val_node);
    
    /*!
     * \brief Set the point associated at a node.
     * \param[in] val_node - Local index of a node.
     * \param[in] val_point - Point associated to the node.
     */
    void SetNode(unsigned short val_node, unsigned long val_point);
    
    /*!
     * \brief Get the face index of and element.
     * \param[in] val_face - Local index of the face.
     * \param[in] val_index - Local (to the face) index of the nodes that compose the face.
     * \return Local (to the triangle) index of the nodes that compose the face.
     */
    unsigned short GetFaces(unsigned short val_face, unsigned short val_index);
    
    /*!
     * \brief Get the local index of the neighbors to a node (given the local index).
     * \param[in] val_node - Local (to the triangle) index of a node.
     * \param[in] val_index - Local (to the neighbor nodes of val_node) index of the nodes that
     are neighbor to val_node (each face is composed by 3 nodes).
     * \return Local (to the triangle) index of the nodes that are neighbor to val_node.
     */
    unsigned short GetNeighbor_Nodes(unsigned short val_node, unsigned short val_index);
    
    /*!
     * \brief Get the number of neighbors nodes of a node.
     * \param[in] val_node - Local (to the triangle) index of a node.
     * \return Number if neighbors of a node val_node.
     */
    unsigned short GetnNeighbor_Nodes(unsigned short val_node);
    
    /*!
     * \brief Get the number of nodes that composes a face of an element.
     * \param[in] val_face - Local index of the face.
     * \return Number of nodes that composes a face of an element.
     */
    unsigned short GetnNodesFace(unsigned short val_face);
    
    /*!
     * \brief Get the number of nodes of an element.
     * \return Number of nodes that composes an element.
     */
    unsigned short GetnNodes(void);
    
    /*!
     * \brief Get the number of faces of an element.
     * \return Number of faces of an element.
     */
    unsigned short GetnFaces(void);
    
    /*!
     * \brief Get the Maximum number of nodes of a face of an element.
     * \return Maximum number of nodes of a face of an element.
     */
    unsigned short GetMaxNodesFace(void);
    
    /*!
     * \brief Get the type of the element using VTK nomenclature.
     * \return Type of the element using VTK nomenclature.
     */
    unsigned short GetVTK_Type(void);
    
    /*!
     * \brief Get the number of element that are neighbor to this element.
     * \return Number of neighbor elements.
     */
    unsigned short GetnNeighbor_Elements(void);
    
    /*!
     * \brief Change the orientation of an element.
     */
    void Change_Orientation(void);
    
    /*!
     * \brief Set the domain element which shares a face with the boundary element.
     * \param[in] val_domainelement - Global index of the element.
     */
    void SetDomainElement(unsigned long val_domainelement);
    
    /*!
     * \brief Get the domain element which shares a face with the boundary element.
     * \return Domain element which shares a face with the boundary element.
     */
    unsigned long GetDomainElement(void);
};

/*!
 * \class CRectangle
 * \brief Class for rectangle element definition.
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CRectangle : public CPrimalGrid {
private:
    static unsigned short Faces[4][2];			/*!< \brief Matrix to store the local nodes of all the faces. */
    static unsigned short Neighbor_Nodes[4][2];	/*!< \brief Neighbor to a nodes in the element. */
    static unsigned short nNodesFace[4];		/*!< \brief Number of nodes of each face of the element. */
    static unsigned short nNeighbor_Nodes[4];	/*!< \brief Number of Neighbor to a nodes in the element. */
    static unsigned short nFaces;				/*!< \brief Number of faces of the element. */
    static unsigned short nNodes;				/*!< \brief Number of nodes of the element. */
    static unsigned short VTK_Type;				/*!< \brief Type of element using VTK nomenclature. */
    static unsigned short maxNodesFace;			/*!< \brief Maximum number of nodes for a face. */
    static unsigned short nNeighbor_Elements;	/*!< \brief Number of neighbor elements. */
    
public:
    
    /*!
     * \brief Constructor using the nodes and index.
     * \param[in] val_point_0 - Index of the 1st point read from the grid file.
     * \param[in] val_point_1 - Index of the 2nd point read from the grid file.
     * \param[in] val_point_2 - Index of the 3th point read from the grid file.
     * \param[in] val_point_3 - Index of the 4th point read from the grid file.
     * \param[in] val_nDim - Number of dimension of the problem (2D or 3D).
     */
    CRectangle(unsigned long val_point_0, unsigned long val_point_1,
               unsigned long val_point_2, unsigned long val_point_3, unsigned short val_nDim);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CRectangle(void);
    
    /*!
     * \brief Get the nodes shared by the triangle.
     * \param[in] val_node - Local (to the rectangle) index of the node (a rectangle has 4 nodes).
     * \return Global index of the triangle node.
     */
    unsigned long GetNode(unsigned short val_node);
    
    /*!
     * \brief Set the point associated at a node.
     * \param[in] val_node - Local index of a node.
     * \param[in] val_point - Point associated to the node.
     */
    void SetNode(unsigned short val_node, unsigned long val_point);
    
    /*!
     * \brief Get the face index of and element.
     * \param[in] val_face - Local index of the face.
     * \param[in] val_index - Local (to the face) index of the nodes that compose the face.
     * \return Local (to the rectangle) index of the nodes that compose the face.
     */
    unsigned short GetFaces(unsigned short val_face, unsigned short val_index);
    
    /*!
     * \brief Get the local index of the neighbors to a node (given the local index).
     * \param[in] val_node - Local (to the element) index of a node.
     * \param[in] val_index - Local (to the neighbor nodes of val_node) index of the nodes that are neighbor to val_node.
     * \return Local (to the rectangle) index of the nodes that are neighbor to val_node.
     */
    unsigned short GetNeighbor_Nodes(unsigned short val_node, unsigned short val_index);
    
    /*!
     * \brief Get the number of neighbors nodes of a node.
     * \param[in] val_node - Local (to the element) index of a node.
     * \return Number if neighbors of a node val_node.
     */
    unsigned short GetnNeighbor_Nodes(unsigned short val_node);
    
    /*!
     * \brief Get the number of nodes that composes a face of an element.
     * \param[in] val_face - Local index of the face.
     * \return Number of nodes that composes a face of an element.
     */
    unsigned short GetnNodesFace(unsigned short val_face);
    
    /*!
     * \brief Get the number of nodes of an element.
     * \return Number of nodes that composes an element.
     */
    unsigned short GetnNodes(void);
    
    /*!
     * \brief Get the number of faces of an element.
     * \return Number of faces of an element.
     */
    unsigned short GetnFaces(void);
    
    /*!
     * \brief Get the Maximum number of nodes of a face of an element.
     * \return Maximum number of nodes of a face of an element.
     */
    unsigned short GetMaxNodesFace(void);
    
    /*!
     * \brief Get the type of the element using VTK nomenclature.
     * \return Type of the element using VTK nomenclature.
     */
    unsigned short GetVTK_Type(void);
    
    /*!
     * \brief Get the number of element that are neighbor to this element.
     * \return Number of neighbor elements.
     */
    unsigned short GetnNeighbor_Elements(void);
    
    /*!
     * \brief Change the orientation of an element.
     */
    void Change_Orientation(void);
    
    /*!
     * \brief Set the domain element which shares a face with the boundary element.
     * \param[in] val_domainelement - Global index of the element.
     */
    void SetDomainElement(unsigned long val_domainelement);
    
    /*!
     * \brief Get the domain element which shares a face with the boundary element.
     * \return Domain element which shares a face with the boundary element.
     */
    unsigned long GetDomainElement(void);
};

/*!
 * \class CTetrahedron
 * \brief Class for tetrahedron element definition.
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CTetrahedron : public CPrimalGrid {
private:
    static unsigned short Faces[4][3];			/*!< \brief Matrix to store the local nodes of all the faces. */
    static unsigned short Neighbor_Nodes[4][3];	/*!< \brief Neighbor to a nodes in the element. */
    static unsigned short nNodesFace[4];		/*!< \brief Number of nodes of each face of the element. */
    static unsigned short nNeighbor_Nodes[4];	/*!< \brief Number of Neighbor to a nodes in the element. */
    static unsigned short nFaces;				/*!< \brief Number of faces of the element. */
    static unsigned short nNodes;				/*!< \brief Number of nodes of the element. */
    static unsigned short VTK_Type;				/*!< \brief Type of element using VTK nomenclature. */
    static unsigned short maxNodesFace;			/*!< \brief Maximum number of nodes for a face. */
    static unsigned short nNeighbor_Elements;	/*!< \brief Number of neighbor elements. */
    
public:
    
    /*!
     * \brief Constructor using the nodes and index.
     * \param[in] val_point_0 - Index of the 1st point read from the grid file.
     * \param[in] val_point_1 - Index of the 2nd point read from the grid file.
     * \param[in] val_point_2 - Index of the 3th point read from the grid file.
     * \param[in] val_point_3 - Index of the 4th point read from the grid file.
     */
    CTetrahedron(unsigned long val_point_0, unsigned long val_point_1,
                 unsigned long val_point_2, unsigned long val_point_3);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CTetrahedron(void);
    
    /*!
     * \brief Get the nodes shared by the tetrahedron.
     * \param[in] val_node - Local (to the tetrahedron) index of the node (a tetrahedron has 4 nodes).
     * \return Global index of the tetrahedron node.
     */
    unsigned long GetNode(unsigned short val_node);
    
    /*!
     * \brief Set the point associated at a node.
     * \param[in] val_node - Local index of a node.
     * \param[in] val_point - Point associated to the node.
     */
    void SetNode(unsigned short val_node, unsigned long val_point);
    
    /*!
     * \brief Get the face index of and element.
     * \param[in] val_face - Local index of the face.
     * \param[in] val_index - Local (to the face) index of the nodes that compose the face.
     * \return Local (to the element) index of the nodes that compose the face.
     */
    unsigned short GetFaces(unsigned short val_face, unsigned short val_index);
    
    /*!
     * \brief Get the local index of the neighbors to a node (given the local index).
     * \param[in] val_node - Local (to the element) index of a node.
     * \param[in] val_index - Local (to the neighbor nodes of val_node) index of the nodes that are neighbor to val_node.
     * \return Local (to the element) index of the nodes that are neighbor to val_node.
     */
    unsigned short GetNeighbor_Nodes(unsigned short val_node, unsigned short val_index);
    
    /*!
     * \brief Get the number of neighbors nodes of a node.
     * \param[in] val_node - Local (to the element) index of a node.
     * \return Number if neighbors of a node val_node.
     */
    unsigned short GetnNeighbor_Nodes(unsigned short val_node);
    
    /*!
     * \brief Get the number of nodes that composes a face of an element.
     * \param[in] val_face - Local index of the face.
     * \return Number of nodes that composes a face of an element.
     */
    unsigned short GetnNodesFace(unsigned short val_face);
    
    /*!
     * \brief Get the number of nodes of an element.
     * \return Number of nodes that composes an element.
     */
    unsigned short GetnNodes(void);
    
    /*!
     * \brief Get the number of faces of an element.
     * \return Number of faces of an element.
     */
    unsigned short GetnFaces(void);
    
    /*!
     * \brief Get the Maximum number of nodes of a face of an element.
     * \return Maximum number of nodes of a face of an element.
     */
    unsigned short GetMaxNodesFace(void);
    
    /*!
     * \brief Get the type of the element using VTK nomenclature.
     * \return Type of the element using VTK nomenclature.
     */
    unsigned short GetVTK_Type(void);
    
    /*!
     * \brief Get the number of element that are neighbor to this element.
     * \return Number of neighbor elements.
     */
    unsigned short GetnNeighbor_Elements(void);
    
    /*!
     * \brief Change the orientation of an element.
     */
    void Change_Orientation(void);
};

/*!
 * \class CHexahedron
 * \brief Class for hexahedron element definition.
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CHexahedron : public CPrimalGrid {
private:
    static unsigned short Faces[6][4];			/*!< \brief Matrix to store the local nodes of all the faces. */
    static unsigned short Neighbor_Nodes[8][3];	/*!< \brief Neighbor to a nodes in the element. */
    static unsigned short nNodesFace[6];		/*!< \brief Number of nodes of each face of the element. */
    static unsigned short nNeighbor_Nodes[8];	/*!< \brief Number of Neighbor to a nodes in the element. */
    static unsigned short nFaces;				/*!< \brief Number of faces of the element. */
    static unsigned short nNodes;				/*!< \brief Number of nodes of the element. */
    static unsigned short VTK_Type;				/*!< \brief Type of element using VTK nomenclature. */
    static unsigned short maxNodesFace;			/*!< \brief Maximum number of nodes for a face. */
    static unsigned short nNeighbor_Elements;	/*!< \brief Number of neighbor elements. */
    
public:
    
    /*!
     * \brief Constructor using the nodes and index.
     * \param[in] val_point_0 - Index of the 1st point read from the grid file.
     * \param[in] val_point_1 - Index of the 2nd point read from the grid file.
     * \param[in] val_point_2 - Index of the 3th point read from the grid file.
     * \param[in] val_point_3 - Index of the 4th point read from the grid file.
     * \param[in] val_point_4 - Index of the 5td point read from the grid file.
     * \param[in] val_point_5 - Index of the 6th point read from the grid file.
     * \param[in] val_point_6 - Index of the 7th point read from the grid file.
     * \param[in] val_point_7 - Index of the 8th point read from the grid file.
     */
    CHexahedron(unsigned long val_point_0, unsigned long val_point_1,
                unsigned long val_point_2, unsigned long val_point_3,
                unsigned long val_point_4, unsigned long val_point_5,
                unsigned long val_point_6, unsigned long val_point_7);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CHexahedron(void);
    
    /*!
     * \brief Get the nodes shared by the triangle.
     * \param[in] val_node - Local (to the triangle) index of the node (a triangle has 3 nodes).
     * \return Global index of the triangle node.
     */
    unsigned long GetNode(unsigned short val_node);
    
    /*!
     * \brief Set the point associated at a node.
     * \param[in] val_node - Local index of a node.
     * \param[in] val_point - Point associated to the node.
     */
    void SetNode(unsigned short val_node, unsigned long val_point);
    
    /*!
     * \brief Get the face index of and element.
     * \param[in] val_face - Local index of the face.
     * \param[in] val_index - Local (to the face) index of the nodes that compose the face.
     * \return Local (to the element) index of the nodes that compose the face.
     */
    unsigned short GetFaces(unsigned short val_face, unsigned short val_index);
    
    /*!
     * \brief Get the local index of the neighbors to a node (given the local index).
     * \param[in] val_node - Local (to the element) index of a node.
     * \param[in] val_index - Local (to the neighbor nodes of val_node) index of the nodes
     *            that are neighbor to val_node.
     * \return Local (to the element) index of the nodes that are neighbor to val_node.
     */
    unsigned short GetNeighbor_Nodes(unsigned short val_node, unsigned short val_index);
    
    /*!
     * \brief Get the number of neighbors nodes of a node.
     * \param[in] val_node - Local (to the element) index of a node.
     * \return Number if neighbors of a node val_node.
     */
    unsigned short GetnNeighbor_Nodes(unsigned short val_node);
    
    /*!
     * \brief Get the number of nodes that composes a face of an element.
     * \param[in] val_face - Local index of the face.
     * \return Number of nodes that composes a face of an element.
     */
    unsigned short GetnNodesFace(unsigned short val_face);
    
    /*!
     * \brief Get the number of nodes of an element.
     * \return Number of nodes that composes an element.
     */
    unsigned short GetnNodes(void);
    
    /*!
     * \brief Get the number of faces of an element.
     * \return Number of faces of an element.
     */
    unsigned short GetnFaces(void);
    
    /*!
     * \brief Get the Maximum number of nodes of a face of an element.
     * \return Maximum number of nodes of a face of an element.
     */
    unsigned short GetMaxNodesFace(void);
    
    /*!
     * \brief Get the type of the element using VTK nomenclature.
     * \return Type of the element using VTK nomenclature.
     */
    unsigned short GetVTK_Type(void);
    
    /*!
     * \brief Get the number of element that are neighbor to this element.
     * \return Number of neighbor elements.
     */
    unsigned short GetnNeighbor_Elements(void);
    
    /*!
     * \brief Change the orientation of an element.
     */
    void Change_Orientation(void);
};

/*!
 * \class CPrism
 * \brief Class for prism element definition.
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CPrism : public CPrimalGrid {
private:
    static unsigned short Faces[5][4];			/*!< \brief Matrix to store the local nodes of all the faces. */
    static unsigned short Neighbor_Nodes[6][3];	/*!< \brief Neighbor to a nodes in the element. */
    static unsigned short nNodesFace[5];		/*!< \brief Number of nodes of each face of the element. */
    static unsigned short nNeighbor_Nodes[6];	/*!< \brief Number of Neighbor to a nodes in the element. */
    static unsigned short nFaces;				/*!< \brief Number of faces of the element. */
    static unsigned short nNodes;				/*!< \brief Number of nodes of the element. */
    static unsigned short VTK_Type;				/*!< \brief Type of element using VTK nomenclature. */
    static unsigned short maxNodesFace;			/*!< \brief Maximum number of nodes for a face. */
    static unsigned short nNeighbor_Elements;	/*!< \brief Number of neighbor elements. */
    
public:
    
    /*!
     * \brief Constructor using the nodes and index.
     * \param[in] val_point_0 - Index of the 1st point read from the grid file.
     * \param[in] val_point_1 - Index of the 2nd point read from the grid file.
     * \param[in] val_point_2 - Index of the 3th point read from the grid file.
     * \param[in] val_point_3 - Index of the 4th point read from the grid file.
     * \param[in] val_point_4 - Index of the 5th point read from the grid file.
     * \param[in] val_point_5 - Index of the 6th point read from the grid file.
     */
    CPrism(unsigned long val_point_0, unsigned long val_point_1,
           unsigned long val_point_2, unsigned long val_point_3,
           unsigned long val_point_4, unsigned long val_point_5);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CPrism(void);
    
    /*!
     * \brief Get the nodes shared by the triangle.
     * \param[in] val_node - Local (to the triangle) index of the node (a prism has 6 nodes).
     * \return Global index of the prism node.
     */
    unsigned long GetNode(unsigned short val_node);
    
    /*!
     * \brief Set the point associated at a node.
     * \param[in] val_node - Local index of a node.
     * \param[in] val_point - Point associated to the node.
     */
    void SetNode(unsigned short val_node, unsigned long val_point);
    
    /*!
     * \brief Get the face index of and element.
     * \param[in] val_face - Local index of the face.
     * \param[in] val_index - Local (to the face) index of the nodes that compose the face.
     * \return Local (to the element) index of the nodes that compose the face.
     */
    unsigned short GetFaces(unsigned short val_face, unsigned short val_index);
    
    /*!
     * \brief Get the local index of the neighbors to a node (given the local index).
     * \param[in] val_node - Local (to the element) index of a node.
     * \param[in] val_index - Local (to the neighbor nodes of val_node) index of the nodes that are neighbor to val_node.
     * \return Local (to the element) index of the nodes that are neighbor to val_node.
     */
    unsigned short GetNeighbor_Nodes(unsigned short val_node, unsigned short val_index);
    
    /*!
     * \brief Get the number of neighbors nodes of a node.
     * \param[in] val_node - Local (to the element) index of a node.
     * \return Number if neighbors of a node val_node.
     */
    unsigned short GetnNeighbor_Nodes(unsigned short val_node);
    
    /*!
     * \brief Get the number of nodes that composes a face of an element.
     * \param[in] val_face - Local index of the face.
     * \return Number of nodes that composes a face of an element.
     */
    unsigned short GetnNodesFace(unsigned short val_face);
    
    /*!
     * \brief Get the number of nodes of an element.
     * \return Number of nodes that composes an element.
     */
    unsigned short GetnNodes(void);
    
    /*!
     * \brief Get the number of faces of an element.
     * \return Number of faces of an element.
     */
    unsigned short GetnFaces(void);
    
    /*!
     * \brief Get the Maximum number of nodes of a face of an element.
     * \return Maximum number of nodes of a face of an element.
     */
    unsigned short GetMaxNodesFace(void);
    
    /*!
     * \brief Get the type of the element using VTK nomenclature.
     * \return Type of the element using VTK nomenclature.
     */
    unsigned short GetVTK_Type(void);
    
    /*!
     * \brief Get the number of element that are neighbor to this element.
     * \return Number of neighbor elements.
     */
    unsigned short GetnNeighbor_Elements(void);
    
    /*!
     * \brief Change the orientation of an element.
     */
    void Change_Orientation(void);
};

/*!
 * \class CPyramid
 * \brief Class for pyramid element definition.
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CPyramid : public CPrimalGrid {
private:
    static unsigned short Faces[5][4];			/*!< \brief Matrix to store the local nodes of all the faces. */
    static unsigned short Neighbor_Nodes[5][4];	/*!< \brief Neighbor to a nodes in the element. */
    static unsigned short nNodesFace[5];		/*!< \brief Number of nodes of each face of the element. */
    static unsigned short nNeighbor_Nodes[5];	/*!< \brief Number of Neighbor to a nodes in the element. */
    static unsigned short nFaces;				/*!< \brief Number of faces of the element. */
    static unsigned short nNodes;				/*!< \brief Number of nodes of the element. */
    static unsigned short VTK_Type;				/*!< \brief Type of element using VTK nomenclature. */
    static unsigned short maxNodesFace;			/*!< \brief Maximum number of nodes for a face. */
    static unsigned short nNeighbor_Elements;	/*!< \brief Number of neighbor elements. */
    
public:
    
    /*!
     * \brief Constructor using the nodes and index.
     * \param[in] val_point_0 - Index of the 1st point read from the grid file.
     * \param[in] val_point_1 - Index of the 2nd point read from the grid file.
     * \param[in] val_point_2 - Index of the 3th point read from the grid file.
     * \param[in] val_point_3 - Index of the 4th point read from the grid file.
     * \param[in] val_point_4 - Index of the 5th point read from the grid file.
     */
    CPyramid(unsigned long val_point_0, unsigned long val_point_1,
             unsigned long val_point_2, unsigned long val_point_3,
             unsigned long val_point_4);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CPyramid(void);
    
    /*!
     * \brief Get the nodes shared by the pyramid.
     * \param[in] val_node - Local (to the pyramid) index of the node (a pyramid has 3 nodes).
     * \return Global index of the pyramid node.
     */
    unsigned long GetNode(unsigned short val_node);
    
    /*!
     * \brief Set the point associated at a node.
     * \param[in] val_node - Local index of a node.
     * \param[in] val_point - Point associated to the node.
     */
    void SetNode(unsigned short val_node, unsigned long val_point);
    
    /*!
     * \brief Get the face index of and element.
     * \param[in] val_face - Local index of the face.
     * \param[in] val_index - Local (to the face) index of the nodes that compose the face.
     * \return Local (to the element) index of the nodes that compose the face.
     */
    unsigned short GetFaces(unsigned short val_face, unsigned short val_index);
    
    /*!
     * \brief Get the local index of the neighbors to a node (given the local index).
     * \param[in] val_node - Local (to the element) index of a node.
     * \param[in] val_index - Local (to the neighbor nodes of val_node) index of the nodes that are neighbor to val_node.
     * \return Local (to the element) index of the nodes that are neighbor to val_node.
     */
    unsigned short GetNeighbor_Nodes(unsigned short val_node, unsigned short val_index);
    
    /*!
     * \brief Get the number of neighbors nodes of a node.
     * \param[in] val_node - Local (to the element) index of a node.
     * \return Number if neighbors of a node val_node.
     */
    unsigned short GetnNeighbor_Nodes(unsigned short val_node);
    
    /*!
     * \brief Get the number of nodes that composes a face of an element.
     * \param[in] val_face - Local index of the face.
     * \return Number of nodes that composes a face of an element.
     */
    unsigned short GetnNodesFace(unsigned short val_face);
    
    /*!
     * \brief Get the number of nodes of an element.
     * \return Number of nodes that composes an element.
     */
    unsigned short GetnNodes(void);
    
    /*!
     * \brief Get the number of faces of an element.
     * \return Number of faces of an element.
     */
    unsigned short GetnFaces(void);
    
    /*!
     * \brief Get the Maximum number of nodes of a face of an element.
     * \return Maximum number of nodes of a face of an element.
     */
    unsigned short GetMaxNodesFace(void);
    
    /*!
     * \brief Get the type of the element using VTK nomenclature.
     * \return Type of the element using VTK nomenclature.
     */
    unsigned short GetVTK_Type(void);
    
    /*!
     * \brief Get the number of element that are neighbor to this element.
     * \return Number of neighbor elements.
     */
    unsigned short GetnNeighbor_Elements(void);
    
    /*!
     * \brief Change the orientation of an element.
     */
    void Change_Orientation(void);
};

/* geometry_structure.hpp------------------------------------------------------------
 *
 *
 *
 */

/*!
 * \class CGeometry
 * \brief Parent class for defining the geometry of the problem (complete geometry,
 *        multigrid agglomerated geometry, only boundary geometry, etc..)
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CGeometry {
protected:
    unsigned long nPoint,	/*!< \brief Number of points of the mesh. */
    nPointDomain,						/*!< \brief Number of real points of the mesh. */
    nPointGhost,					/*!< \brief Number of ghost points of the mesh. */
    Global_nPoint,	/*!< \brief Total number of nodes in a simulation across all processors (including halos). */
    Global_nPointDomain,	/*!< \brief Total number of nodes in a simulation across all processors (excluding halos). */
    nElem,					/*!< \brief Number of elements of the mesh. */
    Global_nElem,	/*!< \brief Total number of elements in a simulation across all processors (all types). */
    nEdge,					/*!< \brief Number of edges of the mesh. */
    nFace,					/*!< \brief Number of faces of the mesh. */
    nelem_edge,             /*!< \brief Number of edges in the mesh. */
    Global_nelem_edge,      /*!< \brief Total number of edges in the mesh across all processors. */
    nelem_triangle,       /*!< \brief Number of triangles in the mesh. */
    Global_nelem_triangle,       /*!< \brief Total number of triangles in the mesh across all processors. */
    nelem_quad,           /*!< \brief Number of quadrangles in the mesh. */
    Global_nelem_quad,           /*!< \brief Total number of quadrangles in the mesh across all processors. */
    nelem_tetra,          /*!< \brief Number of tetrahedra in the mesh. */
    Global_nelem_tetra,          /*!< \brief Total number of tetrahedra in the mesh across all processors. */
    nelem_hexa,           /*!< \brief Number of hexahedra in the mesh. */
    Global_nelem_hexa,           /*!< \brief Total number of hexahedra in the mesh across all processors. */
    nelem_prism,          /*!< \brief Number of prisms in the mesh. */
    Global_nelem_prism,          /*!< \brief Total number of prisms in the mesh across all processors. */
    nelem_pyramid,        /*!< \brief Number of pyramids in the mesh. */
    Global_nelem_pyramid,        /*!< \brief Total number of pyramids in the mesh across all processors. */
    nelem_edge_bound,           /*!< \brief Number of edges on the mesh boundaries. */
    Global_nelem_edge_bound,           /*!< \brief Total number of edges on the mesh boundaries across all processors. */
    nelem_triangle_bound,          /*!< \brief Number of triangles on the mesh boundaries. */
    Global_nelem_triangle_bound,          /*!< \brief Total number of triangles on the mesh boundaries across all processors. */
    nelem_quad_bound,        /*!< \brief Number of quads on the mesh boundaries. */
    Global_nelem_quad_bound;        /*!< \brief Total number of quads on the mesh boundaries across all processors. */
    unsigned short nDim,	/*!< \brief Number of dimension of the problem. */
    nZone,								/*!< \brief Number of zones in the problem. */
    nMarker;				/*!< \brief Number of different markers of the mesh. */
    unsigned long Max_GlobalPoint;  /*!< \brief Greater global point in the domain local structure. */
    
public:
    unsigned long *nElem_Bound;			/*!< \brief Number of elements of the boundary. */
    string *Tag_to_Marker;	/*!< \brief If you know the index of the boundary (depend of the
                             grid definition), it gives you the maker (where the boundary
                             is stored from 0 to boundaries). */
    CPrimalGrid** elem;	/*!< \brief Element vector (primal grid information). */
    CPrimalGrid** face;			/*!< \brief Face vector (primal grid information). */
    CPrimalGrid*** bound;	/*!< \brief Boundary vector (primal grid information). */
    CPoint** node;			/*!< \brief Node vector (dual grid information). */
    CEdge** edge;			/*!< \brief Edge vector (dual grid information). */
    CVertex*** vertex;		/*!< \brief Boundary Vertex vector (dual grid information). */
    unsigned long *nVertex;	/*!< \brief Number of vertex for each marker. */
    unsigned short nCommLevel;		/*!< \brief Number of non-blocking communication levels. */
    vector<unsigned long> PeriodicPoint[MAX_NUMBER_PERIODIC][2];			/*!< \brief PeriodicPoint[Periodic bc] and return the point that
                                                                             must be sent [0], and the image point in the periodic bc[1]. */
    vector<unsigned long> PeriodicElem[MAX_NUMBER_PERIODIC];				/*!< \brief PeriodicElem[Periodic bc] and return the elements that
                                                                             must be sent. */
    
    short *Marker_All_SendRecv;
    
    /*--- Create vectors and distribute the values among the different planes queues ---*/
    vector<vector<double> > Xcoord_plane; /*!< \brief Vector containing x coordinates of new points appearing on a single plane */
    vector<vector<double> > Ycoord_plane; /*!< \brief Vector containing y coordinates of  new points appearing on a single plane */
    vector<vector<double> > Zcoord_plane; 	/*!< \brief Vector containing z coordinates of  new points appearing on a single plane */
    vector<vector<double> > FaceArea_plane; /*!< \brief Vector containing area/volume associated with  new points appearing on a single plane */
    vector<vector<unsigned long> > Plane_points; /*!< \brief Vector containing points appearing on a single plane */
    
    vector<double> XCoordList;	/*!< \brief Vector containing points appearing on a single plane */
    CPrimalGrid*** newBound;            /*!< \brief Boundary vector for new periodic elements (primal grid information). */
    unsigned long *nNewElem_Bound;			/*!< \brief Number of new periodic elements of the boundary. */
    
    //--------Parmetis variables-----
    unsigned long * adjacency;
    unsigned long * xadj;
    unsigned long local_node;
    unsigned long local_elem;
    unsigned long xadj_size;
    unsigned long adjacency_size;
    unsigned long *starting_node;
    unsigned long *ending_node;
    unsigned long *npoint_procs;
    unsigned long no_of_local_elements;
    long *Global_to_local_elem;
    
    /*!
     * \brief Constructor of the class.
     */
    CGeometry(void);
    
    /*!
     * \brief Destructor of the class.
     */
    virtual ~CGeometry(void);
    
    /*!
     * \brief Get number of coordinates.
     * \return Number of coordinates.
     */
    unsigned short GetnDim(void);
    
    /*!
     * \brief Get number of zones.
     * \return Number of zones.
     */
    unsigned short GetnZone(void);
    
    /*!
     * \brief Get number of points.
     * \return Number of points.
     */
    unsigned long GetnPoint(void);
    
    /*!
     * \brief Get number of real points (that belong to the domain).
     * \return Number of real points.
     */
    unsigned long GetnPointDomain(void);
    
    /*!
     * \brief Get number of elements.
     * \return Number of elements.
     */
    //unsigned long GetnLine(void);
    
    /*!
     * \brief Get number of elements.
     * \return Number of elements.
     */
    unsigned long GetnElem(void);
    
    /*!
     * \brief Get number of edges.
     * \return Number of edges.
     */
    unsigned long GetnEdge(void);
    
    /*!
     * \brief Get number of markers.
     * \return Number of markers.
     */
    unsigned short GetnMarker(void);
    
    /*!
     * \brief Get number of vertices.
     * \param[in] val_marker - Marker of the boundary.
     * \return Number of vertices.
     */
    unsigned long GetnVertex(unsigned short val_marker);
    
    /*!
     * \brief Get the edge index from using the nodes of the edge.
     * \param[in] first_point - First point of the edge.
     * \param[in] second_point - Second point of the edge.
     * \return Index of the edge.
     */
    long FindEdge(unsigned long first_point, unsigned long second_point);
    
    /*!
     * \brief Get the edge index from using the nodes of the edge.
     * \param[in] first_point - First point of the edge.
     * \param[in] second_point - Second point of the edge.
     * \return Index of the edge.
     */
    bool CheckEdge(unsigned long first_point, unsigned long second_point);
    
    /*!
     * \brief Get the distance between a plane (defined by three point) and a point.
     * \param[in] Coord - Coordinates of the point.
     * \param[in] iCoord - Coordinates of the first point that defines the plane.
     * \param[in] jCoord - Coordinates of the second point that defines the plane.
     * \param[in] kCoord - Coordinates of the third point that defines the plane.
     * \return Signed distance.
     */
    double Point2Plane_Distance(double *Coord, double *iCoord, double *jCoord, double *kCoord);
    
    /*!
     * \brief Create a file for testing the geometry.
     */
    void TestGeometry(void);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_nmarker - Number of markers.
     */
    void SetnMarker(unsigned short val_nmarker);
    
    /*!
     * \brief Set the number of dimensions of the problem.
     * \param[in] val_nDim - Number of dimensions.
     */
    void SetnDim(unsigned short val_nDim);
    
    /*!
     * \brief Get the index of a marker.
     * \param[in] val_marker - Marker of the boundary.
     * \return Index of the marker in the grid defintion.
     */
    string GetMarker_Tag(unsigned short val_marker);
    
    /*!
     * \brief Set index of a marker.
     * \param[in] val_marker - Marker of the boundary.
     * \param[in] val_index - Index of the marker.
     */
    void SetMarker_Tag(unsigned short val_marker, string val_index);
    
    /*!
     * \brief Set the number of boundary elements.
     * \param[in] val_marker - Marker of the boundary.
     * \param[in] val_nelem_bound - Number of boundary elements.
     */
    void SetnElem_Bound(unsigned short val_marker, unsigned long val_nelem_bound);
    
    /*!
     * \brief Set the number of grid points.
     * \param[in] val_npoint - Number of grid points.
     */
    void SetnPoint(unsigned long val_npoint);
    
    /*!
     * \brief Set the number of grid points in the domain.
     * \param[in] val_npoint - Number of grid points in the domain.
     */
    void SetnPointDomain(unsigned long val_npoint);
    
    /*!
     * \brief Set the number of grid elements.
     * \param[in] val_nelem - Number of grid elements.
     */
    void SetnElem(unsigned long val_nelem);
    
    /*!
     * \brief Get the number of boundary elements.
     * \param[in] val_marker - Marker of the boundary.
     */
    unsigned long GetnElem_Bound(unsigned short val_marker);
    
    /*!
     * \brief Get the number of elements in vtk fortmat.
     */
    unsigned long GetMax_GlobalPoint(void);
    
    /*!
     * \brief A virtual function.
     * \param[in] first_elem - Identification of the first element.
     * \param[in] second_elem - Identification of the second element.
     * \param[in] face_first_elem - Index of the common face for the first element.
     * \param[in] face_second_elem - Index of the common face for the second element.
     */
    virtual bool FindFace(unsigned long first_elem, unsigned long second_elem, unsigned short &face_first_elem,
                          unsigned short &face_second_elem);
    
    /*!
     * \brief A virtual member.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void ComputeWall_Distance(CConfig *config);
    
    /*!
     * \brief A virtual member.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void SetPositive_ZArea(CConfig *config);
    
    /*!
     * \brief A virtual member.
     */
    virtual void SetPoint_Connectivity(void);
    
    /*!
     * \brief A virtual member.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void SetRCM_Ordering(CConfig *config);
    
    /*!
     * \brief A virtual member.
     */
    virtual void SetElement_Connectivity(void);
    
    /*!
     * \brief A virtual member.
     */
    void SetEdges(void);
    
    /*!
     * \brief A virtual member.
     */
    void SetFaces(void);
    
    /*!
     * \brief A virtual member.
     */
    virtual void SetBoundVolume(void);
    
    /*!
     * \brief A virtual member.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void SetVertex(CConfig *config);
    
    /*!
     * \brief A virtual member.
     */
    virtual void SetVertex(void);
    
    /*!
     * \brief A virtual member.
     */
    virtual void SetCG(void);
    
    /*!
     * \brief A virtual member.
     * \param[in] config - Definition of the particular problem.
     * \param[in] action - Allocate or not the new elements.
     */
    virtual void SetControlVolume(CConfig *config, unsigned short action);
    
    /*!
     * \brief A virtual member.
     * \param[in] config - Definition of the particular problem.
     * \param[in] action - Allocate or not the new elements.
     */
    virtual void VisualizeControlVolume(CConfig *config, unsigned short action);
    
    /*!
     * \brief A virtual member.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void MatchNearField(CConfig *config);
    
    /*!
     * \brief A virtual member.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void MatchActuator_Disk(CConfig *config);
    
    /*!
     * \brief A virtual member.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void MatchInterface(CConfig *config);
    
    /*!
     * \brief A virtual member.
     * \param[in] config - Definition of the particular problem.
     * \param[in] geometry_donor - Geometry of the donor zone.
     * \param[in] config_donor - Definition of the donor problem.
     */
    virtual void MatchZone(CConfig *config, CGeometry *geometry_donor, CConfig *config_donor,
                           unsigned short val_iZone, unsigned short val_nZone);
    
    /*!
     * \brief A virtual member.
     * \param[in] config - Definition of the particular problem.
     * \param[in] action - Allocate or not the new elements.
     */
    virtual void SetBoundControlVolume(CConfig *config, unsigned short action);
    
    /*!
     * \brief A virtual member.
     * \param[in] config_filename - Name of the file where the tecplot information is going to be stored.
     */
    virtual void SetTecPlot(char config_filename[MAX_STRING_SIZE], bool new_file);
    
    /*!
     * \brief A virtual member.
     * \param[in] mesh_filename - Name of the file where the tecplot information is going to be stored.
     * \param[in] new_file - Boolean to decide if aopen a new file or add to a old one
     * \param[in] config - Definition of the particular problem.
     */
    virtual void SetBoundTecPlot(char mesh_filename[MAX_STRING_SIZE], bool new_file, CConfig *config);
    
    /*!
     * \brief A virtual member.
     * \param[in] mesh_filename - Name of the file where the tecplot information is going to be stored.
     * \param[in] new_file - Boolean to decide if aopen a new file or add to a old one
     * \param[in] config - Definition of the particular problem.
     */
    virtual void SetBoundSTL(char mesh_filename[MAX_STRING_SIZE], bool new_file, CConfig *config);
    
    
    /*!
     * \brief A virtual member.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void Check_IntElem_Orientation(CConfig *config);
    
    /*!
     * \brief A virtual member.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void Check_BoundElem_Orientation(CConfig *config);
    
    /*!
     * \brief A virtual member.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void SetColorGrid(CConfig *config);
    
    /*!
     * \brief A virtual member.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void SetColorGrid_Parallel(CConfig *config);
    
    /*!
     * \brief A virtual member.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void DivideConnectivity(CConfig *config, unsigned short Elem_Type);
    
    /*!
     * \brief A virtual member.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void SetPeriodicBoundary(CConfig *config);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_domain - Number of domains for parallelization purposes.
     */
    virtual void SetSendReceive(CConfig *config);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_domain - Number of domains for parallelization purposes.
     */
    virtual void SetBoundaries(CConfig *config);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     */
    virtual void SetCoord(CGeometry *geometry);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_nSmooth - Number of smoothing iterations.
     * \param[in] val_smooth_coeff - Relaxation factor.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void SetCoord_Smoothing(unsigned short val_nSmooth, double val_smooth_coeff, CConfig *config);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     */
    virtual void SetPoint_Connectivity(CGeometry *geometry);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void SetVertex(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief A virtual member.
     * \param[in] config - Definition of the particular problem.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] action - Allocate or not the new elements.
     */
    virtual void SetControlVolume(CConfig *config, CGeometry *geometry, unsigned short action);
    
    /*!
     * \brief A virtual member.
     * \param[in] config - Definition of the particular problem.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] action - Allocate or not the new elements.
     */
    virtual void SetBoundControlVolume(CConfig *config, CGeometry *geometry, unsigned short action);
    
    /*!
     * \brief A virtual member.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_mesh_out_filename - Name of the output file.
     */
    virtual void SetMeshFile(CConfig *config, string val_mesh_out_filename);
    
    /*!
     * \brief A virtual member.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_mesh_out_filename - Name of the output file.
     */
    virtual void SetMeshFile(CGeometry *geometry, CConfig *config, string val_mesh_out_filename);
    
    /*!
     * \brief A virtual member.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void SetBoundSensitivity(CConfig *config);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void SetPeriodicBoundary(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief A virtual member.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void SetRotationalVelocity(CConfig *config);
    
    /*!
     * \brief A virtual member.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iter - Current physical time step.
     */
    virtual void SetGridVelocity(CConfig *config, unsigned long iter);
    
    /*!
     * \brief A virtual member.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void Set_MPI_Coord(CConfig *config);
    
    /*!
     * \brief A virtual member.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void Set_MPI_GridVel(CConfig *config);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometry of the fine mesh.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void SetRestricted_GridVelocity(CGeometry *fine_mesh, CConfig *config);
    
    /*!
     * \brief Find and store all vertices on a sharp corner in the geometry.
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeSurf_Curvature(CConfig *config);
    
    /*!
     * \brief A virtual member.
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeAirfoil_Section(double *Plane_P0, double *Plane_Normal,
                                double MinXCoord, double MaxXCoord, double *FlowVariable,
                                vector<double> &Xcoord_Airfoil, vector<double> &Ycoord_Airfoil,
                                vector<double> &Zcoord_Airfoil, vector<double> &Variable_Airfoil,
                                bool original_surface, CConfig *config);
    
    /*!
     * \brief A virtual member.
     * \param[in] config - Definition of the particular problem.
     */
    virtual double Compute_MaxThickness(double *Plane_P0, double *Plane_Normal, unsigned short iSection, CConfig *config, vector<double> &Xcoord_Airfoil, vector<double> &Ycoord_Airfoil, vector<double> &Zcoord_Airfoil, bool original_surface);
    
    /*!
     * \brief A virtual member.
     * \param[in] config - Definition of the particular problem.
     */
    virtual double Compute_AoA(double *Plane_P0, double *Plane_Normal, unsigned short iSection, vector<double> &Xcoord_Airfoil, vector<double> &Ycoord_Airfoil, vector<double> &Zcoord_Airfoil, bool original_surface);
    
    /*!
     * \brief A virtual member.
     * \param[in] config - Definition of the particular problem.
     */
    virtual double Compute_Chord(double *Plane_P0, double *Plane_Normal, unsigned short iSection, vector<double> &Xcoord_Airfoil, vector<double> &Ycoord_Airfoil, vector<double> &Zcoord_Airfoil, bool original_surface);
    
    /*!
     * \brief A virtual member.
     * \param[in] config - Definition of the particular problem.
     * \param[in] original_surface - <code>TRUE</code> if this is the undeformed surface; otherwise <code>FALSE</code>.
     * \returns The minimum value of the airfoil thickness.
     */
    virtual double Compute_Thickness(double *Plane_P0, double *Plane_Normal, unsigned short iSection, double Location, CConfig *config, vector<double> &Xcoord_Airfoil, vector<double> &Ycoord_Airfoil, vector<double> &Zcoord_Airfoil, bool original_surface);
    
    /*!
     * \brief A virtual member.
     * \param[in] config - Definition of the particular problem.
     * \param[in] original_surface - <code>TRUE</code> if this is the undeformed surface; otherwise <code>FALSE</code>.
     * \returns The total volume of the airfoil.
     */
    virtual double Compute_Area(double *Plane_P0, double *Plane_Normal, unsigned short iSection, CConfig *config, vector<double> &Xcoord_Airfoil, vector<double> &Ycoord_Airfoil, vector<double> &Zcoord_Airfoil, bool original_surface);
    
    /*!
     * \brief A virtual member.
     * \param[in] config - Definition of the particular problem.
     * \param[in] original_surface - <code>TRUE</code> if this is the undeformed surface; otherwise <code>FALSE</code>.
     * \returns The total volume of the 3D body.
     */
    virtual double Compute_Volume(CConfig *config, bool original_surface);
    
    /*!
     * \brief A virtual member.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void FindNormal_Neighbor(CConfig *config);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_ipoint - Global point.
     * \returns Local index that correspond with the global index.
     */
    virtual long GetGlobal_to_Local_Point(long val_ipoint);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_ipoint - Global marker.
     * \returns Local marker that correspond with the global index.
     */
    virtual unsigned short GetGlobal_to_Local_Marker(unsigned short val_imarker);
    
    /*!
     * \brief A virtual member.
     * \returns Total number of nodes in a simulation across all processors (including halos).
     */
    virtual unsigned long GetGlobal_nPoint();
    
    /*!
     * \brief A virtual member.
     * \returns Total number of nodes in a simulation across all processors (excluding halos).
     */
    virtual unsigned long GetGlobal_nPointDomain();
    
    /*!
     * \brief A virtual member.
     * \returns Total number of elements in a simulation across all processors.
     */
    virtual unsigned long GetGlobal_nElem();
    
    /*!
     * \brief A virtual member.
     * \returns Total number of line elements in a simulation across all processors.
     */
    virtual unsigned long GetGlobal_nElemLine();
    
    /*!
     * \brief A virtual member.
     * \returns Total number of triangular elements in a simulation across all processors.
     */
    virtual unsigned long GetGlobal_nElemTria();
    
    /*!
     * \brief A virtual member.
     * \returns Total number of quadrilateral elements in a simulation across all processors.
     */
    virtual unsigned long GetGlobal_nElemQuad();
    
    /*!
     * \brief A virtual member.
     * \returns Total number of tetrahedral elements in a simulation across all processors.
     */
    virtual unsigned long GetGlobal_nElemTetr();
    
    /*!
     * \brief A virtual member.
     * \returns Total number of hexahedral elements in a simulation across all processors.
     */
    virtual unsigned long GetGlobal_nElemHexa();
    
    /*!
     * \brief A virtual member.
     * \returns Total number of prism elements in a simulation across all processors.
     */
    virtual unsigned long GetGlobal_nElemPris();
    
    /*!
     * \brief A virtual member.
     * \returns Total number of pyramid elements in a simulation across all processors.
     */
    virtual unsigned long GetGlobal_nElemPyra();
    
    /*!
     * \brief A virtual member.
     * \return Number of line elements.
     */
    virtual unsigned long GetnElemLine();
    
    /*!
     * \brief A virtual member.
     * \return Number of triangular elements.
     */
    virtual unsigned long GetnElemTria();
    
    /*!
     * \brief A virtual member.
     * \return Number of quadrilateral elements.
     */
    virtual unsigned long GetnElemQuad();
    
    /*!
     * \brief A virtual member.
     * \return Number of tetrahedral elements.
     */
    virtual unsigned long GetnElemTetr();
    
    /*!
     * \brief A virtual member.
     * \return Number of hexahedral elements.
     */
    virtual unsigned long GetnElemHexa();
    
    /*!
     * \brief A virtual member.
     * \return Number of prism elements.
     */
    virtual unsigned long GetnElemPris();
    
    /*!
     * \brief A virtual member.
     * \return Number of pyramid elements.
     */
    virtual unsigned long GetnElemPyra();
    
    /*!
     * \brief Indentify geometrical planes in the mesh
     */
    virtual void SetGeometryPlanes(CConfig *config);
    
    /*!
     * \brief Get geometrical planes in the mesh
     */
    virtual vector<double> GetGeometryPlanes();
    
    /*!
     * \brief Get x coords of geometrical planes in the mesh
     */
    virtual vector<vector<double> > GetXCoord();
    
    /*!
     * \brief Get y coords of geometrical planes in the mesh
     */
    virtual vector<vector<double> > GetYCoord();
    
    /*!
     * \brief Get z coords of geometrical planes in the mesh
     */
    virtual vector<vector<double> > GetZCoord();
    
    /*!
     * \brief Get all points on a geometrical plane in the mesh
     */
    virtual vector<vector<unsigned long> > GetPlanarPoints();
    
    /*!
     * \brief Given arrays x[1..n] and y[1..n] containing a tabulated function, i.e., yi = f(xi), with
     x1 < x2 < . . . < xN , and given values yp1 and ypn for the first derivative of the interpolating
     function at points 1 and n, respectively, this routine returns an array y2[1..n] that contains
     the second derivatives of the interpolating function at the tabulated points xi. If yp1 and/or
     ypn are equal to 1 × 1030 or larger, the routine is signaled to set the corresponding boundary
     condition for a natural spline, with zero second derivative on that boundary.
     Numerical Recipes: The Art of Scientific Computing, Third Edition in C++.
     */
    void SetSpline(vector<double> &x, vector<double> &y, unsigned long n, double yp1, double ypn, vector<double> &y2);
    
    /*!
     * \brief Given the arrays xa[1..n] and ya[1..n], which tabulate a function (with the xai’s in order),
     and given the array y2a[1..n], which is the output from spline above, and given a value of
     x, this routine returns a cubic-spline interpolated value y.
     Numerical Recipes: The Art of Scientific Computing, Third Edition in C++.
     * \returns The interpolated value of for x.
     */
    double GetSpline(vector<double> &xa, vector<double> &ya, vector<double> &y2a, unsigned long n, double x);
    
    /*!
     * \brief Compute the intersection between a segment and a plane.
     * \param[in] Segment_P0 - Definition of the particular problem.
     * \param[in] Segment_P1 - Definition of the particular problem.
     * \param[in] Plane_P0 - Definition of the particular problem.
     * \param[in] Plane_Normal - Definition of the particular problem.
     * \param[in] Intersection - Definition of the particular problem.
     * \returns If the intersection has has been successful.
     */
    bool SegmentIntersectsPlane(double *Segment_P0, double *Segment_P1, double Variable_P0, double Variable_P1,
                                double *Plane_P0, double *Plane_Normal, double *Intersection, double &Variable_Interp);
    
    /*!
     * \brief Ray Intersects Triangle (Moller and Trumbore algorithm)
     */
    bool RayIntersectsTriangle(double orig[3], double dir[3],
                               double vert0[3], double vert1[3], double vert2[3],
                               double *intersect);
    
    /*!
     * \brief Segment Intersects Triangle
     */
    bool SegmentIntersectsTriangle(double point0[3], double point1[3],
                                   double vert0[3], double vert1[3], double vert2[3]);
    
};

/*!
 * \class CPhysicalGeometry
 * \brief Class for reading a defining the primal grid which is read from the
 *        grid file in .su2 format.
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CPhysicalGeometry : public CGeometry {
    
    long *Global_to_Local_Point;				/*!< \brief Global-local indexation for the points. */
    long *Local_to_Global_Point;				/*!< \brief Local-global indexation for the points. */
    unsigned short *Local_to_Global_Marker;	/*!< \brief Local to Global marker. */
    unsigned short *Global_to_Local_Marker;	/*!< \brief Global to Local marker. */
    unsigned long *adj_counter; /*!< \brief Adjacency counter. */
    unsigned long **adjacent_elem; /*!< \brief Adjacency element list. */
    
public:
    
    /*!
     * \brief Constructor of the class.
     */
    CPhysicalGeometry(void);
    
    /*!
     * \overload
     * \brief Reads the geometry of the grid and adjust the boundary
     *        conditions with the configuration file.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_mesh_filename - Name of the file with the grid information.
     * \param[in] val_format - Format of the file with the grid information.
     * \param[in] val_iZone - Domain to be read from the grid file.
     * \param[in] val_nZone - Total number of domains in the grid file.
     */
    CPhysicalGeometry(CConfig *config, unsigned short val_iZone, unsigned short val_nZone);
    
    /*!
     * \overload
     * \brief Reads the geometry of the grid and adjust the boundary
     *        conditions with the configuration file.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_mesh_filename - Name of the file with the grid information.
     * \param[in] val_format - Format of the file with the grid information.
     * \param[in] val_iZone - Domain to be read from the grid file.
     * \param[in] val_nZone - Total number of domains in the grid file.
     */
    CPhysicalGeometry(CGeometry *geometry, CConfig *config);
    
    /*!
     * \overload
     * \brief Reads the geometry of the grid and adjust the boundary
     *        conditions with the configuration file for parmetis version.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_mesh_filename - Name of the file with the grid information.
     * \param[in] val_format - Format of the file with the grid information.
     * \param[in] val_iZone - Domain to be read from the grid file.
     * \param[in] val_nZone - Total number of domains in the grid file.
     */
    CPhysicalGeometry(CGeometry *geometry, CConfig *config, int options);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CPhysicalGeometry(void);
    
    /*!
     * \brief Set the send receive boundaries of the grid.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_domain - Number of domains for parallelization purposes.
     */
    void SetSendReceive(CConfig *config);
    
    /*!
     * \brief Set the send receive boundaries of the grid.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_domain - Number of domains for parallelization purposes.
     */
    void SetBoundaries(CConfig *config);
    
    /*!
     * \brief Get the local index that correspond with the global numbering index.
     * \param[in] val_ipoint - Global point.
     * \returns Local index that correspond with the global index.
     */
    long GetGlobal_to_Local_Point(long val_ipoint);
    
    /*!
     * \brief Get the local marker that correspond with the global marker.
     * \param[in] val_ipoint - Global marker.
     * \returns Local marker that correspond with the global index.
     */
    unsigned short GetGlobal_to_Local_Marker(unsigned short val_imarker);
    
    /*!
     * \brief Reads the geometry of the grid and adjust the boundary
     *        conditions with the configuration file in parallel (for parmetis).
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_mesh_filename - Name of the file with the grid information.
     * \param[in] val_format - Format of the file with the grid information.
     * \param[in] val_iZone - Domain to be read from the grid file.
     * \param[in] val_nZone - Total number of domains in the grid file.
     */
    void Read_SU2_Format_Parallel(CConfig *config, string val_mesh_filename, unsigned short val_iZone, unsigned short val_nZone);
    
    
    /*!
     * \brief Reads the geometry of the grid and adjust the boundary
     *        conditions with the configuration file in parallel (for parmetis).
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_mesh_filename - Name of the file with the grid information.
     * \param[in] val_format - Format of the file with the grid information.
     * \param[in] val_iZone - Domain to be read from the grid file.
     * \param[in] val_nZone - Total number of domains in the grid file.
     */
    void Read_CGNS_Format_Parallel(CConfig *config, string val_mesh_filename, unsigned short val_iZone, unsigned short val_nZone);
    
    /*!
     * \brief Find repeated nodes between two elements to identify the common face.
     * \param[in] first_elem - Identification of the first element.
     * \param[in] second_elem - Identification of the second element.
     * \param[in] face_first_elem - Index of the common face for the first element.
     * \param[in] face_second_elem - Index of the common face for the second element.
     * \return It provides 0 or 1 depending if there is a common face or not.
     */
    bool FindFace(unsigned long first_elem, unsigned long second_elem, unsigned short &face_first_elem,
                  unsigned short &face_second_elem);
    
    /*!
     * \brief Computes the distance to the nearest no-slip wall for each grid node.
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeWall_Distance(CConfig *config);
    
    /*!
     * \brief Compute surface area (positive z-direction) for force coefficient non-dimensionalization.
     * \param[in] config - Definition of the particular problem.
     */
    void SetPositive_ZArea(CConfig *config);
    
    /*!
     * \brief Set points which surround a point.
     */
    void SetPoint_Connectivity(void);
    
    /*!
     * \brief Set a renumbering using a Reverse Cuthill-McKee Algorithm
     * \param[in] config - Definition of the particular problem.
     */
    void SetRCM_Ordering(CConfig *config);
    
    /*!
     * \brief Function declaration to avoid partially overridden classes.
     * \param[in] geometry - Geometrical definition of the problem.
     */
    void SetPoint_Connectivity(CGeometry *geometry);
    
    /*!
     * \brief Set elements which surround an element.
     */
    void SetElement_Connectivity(void);
    
    /*!
     * \brief Set the volume element associated to each boundary element.
     */
    void SetBoundVolume(void);
    
    /*!
     * \brief Set boundary vertex.
     * \param[in] config - Definition of the particular problem.
     */
    void SetVertex(CConfig *config);
    
    /*!
     * \brief Set the center of gravity of the face, elements and edges.
     */
    void SetCG(void);
    
    /*!
     * \brief Set the edge structure of the control volume.
     * \param[in] config - Definition of the particular problem.
     * \param[in] action - Allocate or not the new elements.
     */
    void SetControlVolume(CConfig *config, unsigned short action);
    
    /*!
     * \brief Visualize the structure of the control volume(s).
     * \param[in] config - Definition of the particular problem.
     * \param[in] action - Allocate or not the new elements.
     */
    void VisualizeControlVolume(CConfig *config, unsigned short action);
    
    /*!
     * \brief Mach the near field boundary condition.
     * \param[in] config - Definition of the particular problem.
     */
    void MatchNearField(CConfig *config);
    
    /*!
     * \brief Mach the near field boundary condition.
     * \param[in] config - Definition of the particular problem.
     */
    void MatchActuator_Disk(CConfig *config);
    
    /*!
     * \brief Mach the interface boundary condition.
     * \param[in] config - Definition of the particular problem.
     */
    void MatchInterface(CConfig *config);
    
    /*!
     * \brief Mach the interface boundary condition.
     * \param[in] config - Definition of the particular problem.
     * \param[in] geometry_donor - Geometry of the donor zone.
     * \param[in] config_donor - Definition of the donor problem.
     */
    void MatchZone(CConfig *config, CGeometry *geometry_donor, CConfig *config_donor,
                   unsigned short val_iZone, unsigned short val_nZone);
    
    /*!
     * \brief Set boundary vertex structure of the control volume.
     * \param[in] config - Definition of the particular problem.
     * \param[in] action - Allocate or not the new elements.
     */
    void SetBoundControlVolume(CConfig *config, unsigned short action);
    
    /*!
     * \brief Set the Tecplot file.
     * \param[in] config_filename - Name of the file where the Tecplot
     *            information is going to be stored.
     * \param[in] new_file - Create a new file.
     */
    void SetTecPlot(char config_filename[MAX_STRING_SIZE], bool new_file);
    
    /*!
     * \brief Set the output file for boundaries in Tecplot
     * \param[in] config - Definition of the particular problem.
     * \param[in] mesh_filename - Name of the file where the Tecplot
     *            information is going to be stored.
     * \param[in] new_file - Create a new file.
     */
    void SetBoundTecPlot(char mesh_filename[MAX_STRING_SIZE], bool new_file, CConfig *config);
    
    /*!
     * \brief Set the output file for boundaries in STL CAD format
     * \param[in] config - Definition of the particular problem.
     * \param[in] mesh_filename - Name of the file where the STL
     *            information is going to be stored.
     * \param[in] new_file - Create a new file.
     */
    void SetBoundSTL(char mesh_filename[MAX_STRING_SIZE], bool new_file, CConfig *config) ;
    
    /*!
     * \brief Check the volume element orientation.
     * \param[in] config - Definition of the particular problem.
     */
    void Check_IntElem_Orientation(CConfig *config);
    
    /*!
     * \brief Check the volume element orientation.
     * \param[in] config - Definition of the particular problem.
     */
    void Check_BoundElem_Orientation(CConfig *config);
    
    /*!
     * \brief Set the domains for grid grid partitioning using METIS.
     * \param[in] config - Definition of the particular problem.
     */
    void SetColorGrid(CConfig *config);
    
    /*!
     * \brief Set the domains for grid grid partitioning using ParMETIS.
     * \param[in] config - Definition of the particular problem.
     */
    void SetColorGrid_Parallel(CConfig *config);
    
    /*!
     * \brief Set the rotational velocity at each node.
     * \param[in] config - Definition of the particular problem.
     */
    void SetRotationalVelocity(CConfig *config);
    
    /*!
     * \brief Set the grid velocity via finite differencing at each node.
     * \param[in] config - Definition of the particular problem.
     */
    void SetGridVelocity(CConfig *config, unsigned long iter);
    
    /*!
     * \brief Perform the MPI communication for the grid coordinates (dynamic meshes).
     * \param[in] config - Definition of the particular problem.
     */
    void Set_MPI_Coord(CConfig *config);
    
    /*!
     * \brief Perform the MPI communication for the grid velocities.
     * \param[in] config - Definition of the particular problem.
     */
    void Set_MPI_GridVel(CConfig *config);
    
    /*!
     * \brief Set the periodic boundary conditions.
     * \param[in] config - Definition of the particular problem.
     */
    void SetPeriodicBoundary(CConfig *config);
    
    /*!
     * \brief Do an implicit smoothing of the grid coordinates.
     * \param[in] val_nSmooth - Number of smoothing iterations.
     * \param[in] val_smooth_coeff - Relaxation factor.
     * \param[in] config - Definition of the particular problem.
     */
    void SetCoord_Smoothing(unsigned short val_nSmooth, double val_smooth_coeff, CConfig *config);
    
    /*!
     * \brief Write the .su2 file.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_mesh_out_filename - Name of the output file.
     */
    void SetMeshFile(CConfig *config, string val_mesh_out_filename);
    
    /*!
     * \brief Compute some parameters about the grid quality.
     * \param[out] statistics - Information about the grid quality, statistics[0] = (r/R)_min, statistics[1] = (r/R)_ave.
     */
    void GetQualityStatistics(double *statistics);
    
    /*!
     * \brief Find and store all vertices on a sharp corner in the geometry.
     * \param[in] config - Definition of the particular problem.
     */
    //void ComputeSurf_Curvature(CConfig *config);
    
    /*!
     * \brief Find and store the closest neighbor to a vertex.
     * \param[in] config - Definition of the particular problem.
     */
    void FindNormal_Neighbor(CConfig *config);
    
    /*!
     * \brief Retrieve total number of nodes in a simulation across all processors (including halos).
     * \returns Total number of nodes in a simulation across all processors (including halos).
     */
    unsigned long GetGlobal_nPoint();
    
    /*!
     * \brief Retrieve total number of nodes in a simulation across all processors (excluding halos).
     * \returns Total number of nodes in a simulation across all processors (excluding halos).
     */
    unsigned long GetGlobal_nPointDomain();
    
    /*!
     * \brief Retrieve total number of elements in a simulation across all processors.
     * \returns Total number of elements in a simulation across all processors.
     */
    unsigned long GetGlobal_nElem();
    
    /*!
     * \brief Retrieve total number of triangular elements in a simulation across all processors.
     * \returns Total number of line elements in a simulation across all processors.
     */
    unsigned long GetGlobal_nElemLine();
    
    /*!
     * \brief Retrieve total number of triangular elements in a simulation across all processors.
     * \returns Total number of triangular elements in a simulation across all processors.
     */
    unsigned long GetGlobal_nElemTria();
    
    /*!
     * \brief Retrieve total number of quadrilateral elements in a simulation across all processors.
     * \returns Total number of quadrilateral elements in a simulation across all processors.
     */
    unsigned long GetGlobal_nElemQuad();
    
    /*!
     * \brief Retrieve total number of tetrahedral elements in a simulation across all processors.
     * \returns Total number of tetrahedral elements in a simulation across all processors.
     */
    unsigned long GetGlobal_nElemTetr();
    
    /*!
     * \brief Retrieve total number of hexahedral elements in a simulation across all processors.
     * \returns Total number of hexahedral elements in a simulation across all processors.
     */
    unsigned long GetGlobal_nElemHexa();
    
    /*!
     * \brief Retrieve total number of prism elements in a simulation across all processors.
     * \returns Total number of prism elements in a simulation across all processors.
     */
    unsigned long GetGlobal_nElemPris();
    
    /*!
     * \brief Retrieve total number of pyramid elements in a simulation across all processors.
     * \returns Total number of pyramid elements in a simulation across all processors.
     */
    unsigned long GetGlobal_nElemPyra();
    
    /*!
     * \brief Get number of triangular elements.
     * \return Number of line elements.
     */
    unsigned long GetnElemLine();
    
    /*!
     * \brief Get number of triangular elements.
     * \return Number of triangular elements.
     */
    unsigned long GetnElemTria();
    
    /*!
     * \brief Get number of quadrilateral elements.
     * \return Number of quadrilateral elements.
     */
    unsigned long GetnElemQuad();
    
    /*!
     * \brief Get number of tetrahedral elements.
     * \return Number of tetrahedral elements.
     */
    unsigned long GetnElemTetr();
    
    /*!
     * \brief Get number of hexahedral elements.
     * \return Number of hexahedral elements.
     */
    unsigned long GetnElemHexa();
    
    /*!
     * \brief Get number of prism elements.
     * \return Number of prism elements.
     */
    unsigned long GetnElemPris();
    
    /*!
     * \brief Get number of pyramid elements.
     * \return Number of pyramid elements.
     */
    unsigned long GetnElemPyra();
    
    /*!
     * \brief Indentify geometrical planes in the mesh
     */
    void SetGeometryPlanes(CConfig *config);
    
    /*!
     * \brief Get geometrical planes in the mesh
     */
    vector<double> GetGeometryPlanes();
    
    /*!
     * \brief Get x coords of geometrical planes in the mesh
     */
    vector<vector<double> > GetXCoord();
    
    /*!
     * \brief Get y coords of geometrical planes in the mesh
     */
    vector<vector<double> > GetYCoord();
    
    /*!
     * \brief Get z coords of geometrical planes in the mesh
     */
    vector<vector<double> > GetZCoord();
    
    /*!
     * \brief Get all points on a geometrical plane in the mesh
     */
    vector<vector<unsigned long> > GetPlanarPoints();
    
    /*!
     * \brief Read the sensitivity from an input file.
     * \param[in] config - Definition of the particular problem.
     */
    void SetBoundSensitivity(CConfig *config);
    
    /*!
     * \brief Compute the sections of a wing.
     * \param[in] config - Definition of the particular problem.
     */
    double Compute_MaxThickness(double *Plane_P0, double *Plane_Normal, unsigned short iSection, CConfig *config, vector<double> &Xcoord_Airfoil, vector<double> &Ycoord_Airfoil, vector<double> &Zcoord_Airfoil, bool original_surface);
    
    /*!
     * \brief Compute the sections of a wing.
     * \param[in] config - Definition of the particular problem.
     */
    double Compute_AoA(double *Plane_P0, double *Plane_Normal, unsigned short iSection, vector<double> &Xcoord_Airfoil, vector<double> &Ycoord_Airfoil, vector<double> &Zcoord_Airfoil, bool original_surface);
    
    /*!
     * \brief Compute the sections of a wing.
     * \param[in] config - Definition of the particular problem.
     */
    double Compute_Chord(double *Plane_P0, double *Plane_Normal, unsigned short iSection, vector<double> &Xcoord_Airfoil, vector<double> &Ycoord_Airfoil, vector<double> &Zcoord_Airfoil, bool original_surface);
    
    /*!
     * \brief Find the minimum thickness of the airfoil.
     * \param[in] config - Definition of the particular problem.
     * \param[in] original_surface - <code>TRUE</code> if this is the undeformed surface; otherwise <code>FALSE</code>.
     * \returns The minimum value of the airfoil thickness.
     */
    double Compute_Thickness(double *Plane_P0, double *Plane_Normal, unsigned short iSection, double Location, CConfig *config, vector<double> &Xcoord_Airfoil, vector<double> &Ycoord_Airfoil, vector<double> &Zcoord_Airfoil, bool original_surface);
    
    /*!
     * \brief Find the total volume of the airfoil.
     * \param[in] config - Definition of the particular problem.
     * \param[in] original_surface - <code>TRUE</code> if this is the undeformed surface; otherwise <code>FALSE</code>.
     * \returns The total volume of the airfoil.
     */
    double Compute_Area(double *Plane_P0, double *Plane_Normal, unsigned short iSection, CConfig *config, vector<double> &Xcoord_Airfoil, vector<double> &Ycoord_Airfoil, vector<double> &Zcoord_Airfoil, bool original_surface);
    
    /*!
     * \brief Find the internal volume of the 3D body.
     * \param[in] config - Definition of the particular problem.
     * \param[in] original_surface - <code>TRUE</code> if this is the undeformed surface; otherwise <code>FALSE</code>.
     * \returns The total volume of the 3D body.
     */
    double Compute_Volume(CConfig *config, bool original_surface);
    
};

/*!
 * \class CMultiGridGeometry
 * \brief Class for defining the multigrid geometry, the main delicated part is the
 *        agglomeration stage, which is done in the declaration.
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CMultiGridGeometry : public CGeometry {
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Level of the multigrid.
     * \param[in] iZone - Current zone in the mesh.
     */
    CMultiGridGeometry(CGeometry ***geometry, CConfig **config_container, unsigned short iMesh, unsigned short iZone);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CMultiGridGeometry(void);
    
    /*!
     * \brief Determine if a CVPoint van be agglomerated, if it have the same marker point as the seed.
     * \param[in] CVPoint - Control volume to be agglomerated.
     * \param[in] marker_seed - Marker of the seed.
     * \param[in] fine_grid - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     * \return <code>TRUE</code> or <code>FALSE</code> depending if the control volume can be agglomerated.
     */
    bool SetBoundAgglomeration(unsigned long CVPoint, short marker_seed, CGeometry *fine_grid, CConfig *config);
    
    /*!
     * \brief Determine if a can be agglomerated using geometrical criteria.
     * \param[in] iPoint - Seed point.
     * \param[in] fine_grid - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    bool GeometricalCheck(unsigned long iPoint, CGeometry *fine_grid, CConfig *config);
    
    /*!
     * \brief Determine if a CVPoint van be agglomerated, if it have the same marker point as the seed.
     * \param[in] Suitable_Indirect_Neighbors - List of Indirect Neighbours that can be agglomerated.
     * \param[in] iPoint - Seed point.
     * \param[in] Index_CoarseCV - Index of agglomerated point.
     * \param[in] fine_grid - Geometrical definition of the problem.
     */
    void SetSuitableNeighbors(vector<unsigned long> *Suitable_Indirect_Neighbors, unsigned long iPoint,
                              unsigned long Index_CoarseCV, CGeometry *fine_grid);
    
    /*!
     * \brief Set boundary vertex.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void SetVertex(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Set points which surround a point.
     * \param[in] geometry - Geometrical definition of the problem.
     */
    void SetPoint_Connectivity(CGeometry *geometry);
    
    /*!
     * \brief Function declaration to avoid partially overridden classes.
     */
    void SetPoint_Connectivity(void);
    
    /*!
     * \brief Set the edge structure of the agglomerated control volume.
     * \param[in] config - Definition of the particular problem.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] action - Allocate or not the new elements.
     */
    void SetControlVolume(CConfig *config, CGeometry *geometry, unsigned short action);
    
    /*!
     * \brief Mach the near field boundary condition.
     * \param[in] config - Definition of the particular problem.
     */
    void MatchNearField(CConfig *config);
    
    /*!
     * \brief Mach the near field boundary condition.
     * \param[in] config - Definition of the particular problem.
     */
    void MatchActuator_Disk(CConfig *config);
    
    /*!
     * \brief Mach the interface boundary condition.
     * \param[in] config - Definition of the particular problem.
     */
    void MatchInterface(CConfig *config);
    
    /*!
     * \brief Set boundary vertex structure of the agglomerated control volume.
     * \param[in] config - Definition of the particular problem.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] action - Allocate or not the new elements.
     */
    void SetBoundControlVolume(CConfig *config, CGeometry *geometry, unsigned short action);
    
    /*!
     * \brief Set a representative coordinates of the agglomerated control volume.
     * \param[in] geometry - Geometrical definition of the problem.
     */
    void SetCoord(CGeometry *geometry);
    
    /*!
     * \brief Set the rotational velocity at each grid point on a coarse mesh.
     * \param[in] config - Definition of the particular problem.
     */
    void SetRotationalVelocity(CConfig *config);
    
    /*!
     * \brief Set the grid velocity at each node in the coarse mesh level.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iter - Current physical time step.
     */
    void SetGridVelocity(CConfig *config, unsigned long iter);
    
    /*!
     * \brief Set the grid velocity at each node in the coarse mesh level based
     *        on a restriction from a finer mesh.
     * \param[in] fine_mesh - Geometry container for the finer mesh level.
     * \param[in] config - Definition of the particular problem.
     */
    void SetRestricted_GridVelocity(CGeometry *fine_mesh, CConfig *config);
    
    /*!
     * \brief Find and store the closest neighbor to a vertex.
     * \param[in] config - Definition of the particular problem.
     */
    void FindNormal_Neighbor(CConfig *config);
    
    /*!
     * \brief Indentify geometrical planes in the mesh
     */
    void SetGeometryPlanes(CConfig *config);
    
    /*!
     * \brief Get geometrical planes in the mesh
     */
    vector<double> GetGeometryPlanes();
    
    /*!
     * \brief Get x coords of geometrical planes in the mesh
     */
    vector<vector<double> > GetXCoord();
    
    /*!
     * \brief Get y coords of geometrical planes in the mesh
     */
    vector<vector<double> > GetYCoord();
    
    /*!
     * \brief Get z coords of geometrical planes in the mesh
     */
    vector<vector<double> > GetZCoord();
    
    /*!
     * \brief Get all points on a geometrical plane in the mesh
     */
    vector<vector<unsigned long> > GetPlanarPoints();
    
};

/*!
 * \class CPeriodicGeometry
 * \brief Class for defining a periodic boundary condition.
 * \author T. Economon, F. Palacios
 * \version 3.2.9 "eagle"
 */
class CPeriodicGeometry : public CGeometry {
    CPrimalGrid*** newBoundPer;            /*!< \brief Boundary vector for new periodic elements (primal grid information). */
    unsigned long *nNewElem_BoundPer;			/*!< \brief Number of new periodic elements of the boundary. */
    
public:
    
    /*! 
     * \brief Constructor of the class.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CPeriodicGeometry(CGeometry *geometry, CConfig *config);
    
    /*! 
     * \brief Destructor of the class.
     */
    ~CPeriodicGeometry(void);
    
    /*! 
     * \brief Set the periodic boundaries of the grid.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void SetPeriodicBoundary(CGeometry *geometry, CConfig *config);
    
    /*! 
     * \brief Set the Tecplot file.
     * \param[in] config_filename - Name of the file where the Tecplot 
     *            information is going to be stored.
     */
    void SetTecPlot(char config_filename[MAX_STRING_SIZE], bool new_file);
    
    /*! 
     * \brief Write the .su2 file.
     * \param[in] config - Definition of the particular problem.		 
     * \param[in] val_mesh_out_filename - Name of the output file.
     */
    void SetMeshFile(CGeometry *geometry, CConfig *config, string val_mesh_out_filename);
};

/*! 
 * \struct CMultiGridQueue
 * \brief Class for a multigrid queue system
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 * \date Aug 12, 2012
 */
class CMultiGridQueue {
    vector<vector<unsigned long> > QueueCV; /*!< \brief Queue structure to choose the next control volume in the agglomeration process. */
    short *Priority;	/*!< \brief The priority is based on the number of pre-agglomerated neighbors. */
    bool *RightCV;	/*!< \brief In the lowest priority there are some CV that can not be agglomerated, this is the way to identify them */  
    unsigned long nPoint; /*!< \brief Total number of points. */  
    
public:
    
    /*! 
     * \brief Constructor of the class.
     * \param[in] val_npoint - Number of control volumes.
     */
    CMultiGridQueue(unsigned long val_npoint);
    
    /*! 
     * \brief Destructor of the class.
     */
    ~CMultiGridQueue(void);
    
    /*! 
     * \brief Add a new CV to the list.
     * \param[in] val_new_point - Index of the new point.
     * \param[in] val_number_neighbors - Number of neighbors of the new point.
     */
    void AddCV(unsigned long val_new_point, unsigned short val_number_neighbors);
    
    /*! 
     * \brief Remove a CV from the list.
     * \param[in] val_remove_point - Index of the control volume to be removed.
     */
    void RemoveCV(unsigned long val_remove_point);
    
    /*! 
     * \brief Change a CV from a list to a different list.
     * \param[in] val_move_point - Index of the control volume to be moved.
     * \param[in] val_number_neighbors - New number of neighbors of the control volume.
     */
    void MoveCV(unsigned long val_move_point, short val_number_neighbors);
    
    /*! 
     * \brief Increase the priority of the CV.
     * \param[in] val_incr_point - Index of the control volume.
     */
    void IncrPriorityCV(unsigned long val_incr_point);
    
    /*! 
     * \brief Increase the priority of the CV.
     * \param[in] val_red_point - Index of the control volume.
     */
    void RedPriorityCV(unsigned long val_red_point);
    
    /*! 
     * \brief Visualize the control volume queue.
     */
    void VisualizeQueue(void);
    
    /*! 
     * \brief Visualize the priority list.
     */
    void VisualizePriority(void);
    
    /*! 
     * \brief Find a new seed control volume.
     * \return Index of the new control volume.
     */
    long NextCV(void);
    
    /*! 
     * \brief Check if the queue is empty.
     * \return <code>TRUE</code> or <code>FALSE</code> depending if the queue is empty.
     */
    bool EmptyQueue(void);
    
    /*! 
     * \brief Total number of control volume in the queue.
     * \return Total number of control points.
     */
    unsigned long TotalCV(void);
    
    /*! 
     * \brief Update the queue with the new control volume (remove the CV and 
     increase the priority of the neighbors).
     * \param[in] val_update_point - Index of the new point.
     * \param[in] fine_grid - Fine grid geometry.
     */
    void Update(unsigned long val_update_point, CGeometry *fine_grid);
    
};


/* Matrix_structure.hpp------------------------------------------------------------
 *
 *
 *
 */

/*!
 * \class CSysMatrix
 * \brief Main class for defining sparse matrices-by-blocks
 with compressed row format.
 * \author A. Bueno, F. Palacios
 * \version 3.2.9 "eagle"
 */
class CSysMatrix {
private:
    unsigned long nPoint,   /*!< \brief Number of points in the grid. */
    nPointDomain,           /*!< \brief Number of points in the grid. */
    nVar,                   /*!< \brief Number of variables. */
    nEqn;                   /*!< \brief Number of equations. */
    double *matrix;            /*!< \brief Entries of the sparse matrix. */
    double *ILU_matrix;         /*!< \brief Entries of the ILU sparse matrix. */
    unsigned long *row_ptr;    /*!< \brief Pointers to the first element in each row. */
    unsigned long *col_ind;    /*!< \brief Column index for each of the elements in val(). */
    unsigned long nnz;         /*!< \brief Number of possible nonzero entries in the matrix. */
    double *block;             /*!< \brief Internal array to store a subblock of the matrix. */
    double *block_inverse;             /*!< \brief Internal array to store a subblock of the matrix. */
    double *block_weight;             /*!< \brief Internal array to store a subblock of the matrix. */
    double *prod_block_vector; /*!< \brief Internal array to store the product of a subblock with a vector. */
    double *prod_row_vector;   /*!< \brief Internal array to store the product of a matrix-by-blocks "row" with a vector. */
    double *aux_vector;         /*!< \brief Auxilar array to store intermediate results. */
    double *sum_vector;         /*!< \brief Auxilar array to store intermediate results. */
    double *invM;              /*!< \brief Inverse of (Jacobi) preconditioner. */
    bool *LineletBool;                          /*!< \brief Identify if a point belong to a linelet. */
    vector<unsigned long> *LineletPoint;        /*!< \brief Linelet structure. */
    unsigned long nLinelet;                     /*!< \brief Number of Linelets in the system. */
    double **UBlock, **invUBlock, **LBlock,
    **yVector, **zVector, **rVector, *LFBlock,
    *LyVector, *FzVector, *AuxVector;           /*!< \brief Arrays of the Linelet preconditioner methodology. */
    unsigned long max_nElem;
    
public:
    
    /*!
     * \brief Constructor of the class.
     */
    CSysMatrix(void);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CSysMatrix(void);
    
    
    /*!
     * \brief Initializes space matrix system.
     * \param[in] nVar - Number of variables.
     * \param[in] nEqn - Number of equations.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void Initialize(unsigned long nPoint, unsigned long nPointDomain, unsigned short nVar, unsigned short nEqn,
                    bool EdgeConnect, CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Assings values to the sparse-matrix structure.
     * \param[in] val_nPoint - Number of points in the nPoint x nPoint block structure
     * \param[in] val_nVar - Number of nVar x nVar variables in each subblock of the matrix-by-block structure.
     * \param[in] val_nEq - Number of nEqn x nVar variables in each subblock of the matrix-by-block structure.
     * \param[in] val_row_ptr - Pointers to the first element in each row.
     * \param[in] val_col_ind - Column index for each of the elements in val().
     * \param[in] val_nnz - Number of possible nonzero entries in the matrix.
     * \param[in] config - Definition of the particular problem.
     */
    void SetIndexes(unsigned long val_nPoint, unsigned long val_nPointDomain, unsigned short val_nVar, unsigned short val_nEq, unsigned long* val_row_ptr, unsigned long* val_col_ind, unsigned long val_nnz, CConfig *config);
    
    /*!
     * \brief Sets to zero all the entries of the sparse matrix.
     */
    void SetValZero(void);
    
    /*!
     * \brief Copies the block (i, j) of the matrix-by-blocks structure in the internal variable *block.
     * \param[in] block_i - Indexes of the block in the matrix-by-blocks structure.
     * \param[in] block_j - Indexes of the block in the matrix-by-blocks structure.
     */
    double *GetBlock(unsigned long block_i, unsigned long block_j);
    
    /*!
     * \brief Copies the block (i, j) of the matrix-by-blocks structure in the internal variable *block.
     * \param[in] block_i - Indexes of the block in the matrix-by-blocks structure.
     * \param[in] block_j - Indexes of the block in the matrix-by-blocks structure.
     */
    double GetBlock(unsigned long block_i, unsigned long block_j, unsigned short iVar, unsigned short jVar);
    
    /*!
     * \brief Set the value of a block in the sparse matrix.
     * \param[in] block_i - Indexes of the block in the matrix-by-blocks structure.
     * \param[in] block_j - Indexes of the block in the matrix-by-blocks structure.
     * \param[in] **val_block - Block to set to A(i, j).
     */
    void SetBlock(unsigned long block_i, unsigned long block_j, double **val_block);
    
    /*!
     * \brief Set the value of a block in the sparse matrix.
     * \param[in] block_i - Indexes of the block in the matrix-by-blocks structure.
     * \param[in] block_j - Indexes of the block in the matrix-by-blocks structure.
     * \param[in] **val_block - Block to set to A(i, j).
     */
    void SetBlock(unsigned long block_i, unsigned long block_j, double *val_block);
    
    /*!
     * \brief Adds the specified block to the sparse matrix.
     * \param[in] block_i - Indexes of the block in the matrix-by-blocks structure.
     * \param[in] block_j - Indexes of the block in the matrix-by-blocks structure.
     * \param[in] **val_block - Block to add to A(i, j).
     */
    void AddBlock(unsigned long block_i, unsigned long block_j, double **val_block);
    
    /*!
     * \brief Subtracts the specified block to the sparse matrix.
     * \param[in] block_i - Indexes of the block in the matrix-by-blocks structure.
     * \param[in] block_j - Indexes of the block in the matrix-by-blocks structure.
     * \param[in] **val_block - Block to subtract to A(i, j).
     */
    void SubtractBlock(unsigned long block_i, unsigned long block_j, double **val_block);
    
    /*!
     * \brief Copies the block (i, j) of the matrix-by-blocks structure in the internal variable *block.
     * \param[in] block_i - Indexes of the block in the matrix-by-blocks structure.
     * \param[in] block_j - Indexes of the block in the matrix-by-blocks structure.
     */
    double *GetBlock_ILUMatrix(unsigned long block_i, unsigned long block_j);
    
    /*!
     * \brief Set the value of a block in the sparse matrix.
     * \param[in] block_i - Indexes of the block in the matrix-by-blocks structure.
     * \param[in] block_j - Indexes of the block in the matrix-by-blocks structure.
     * \param[in] **val_block - Block to set to A(i, j).
     */
    void SetBlock_ILUMatrix(unsigned long block_i, unsigned long block_j, double *val_block);
    
    /*!
     * \brief Subtracts the specified block to the sparse matrix.
     * \param[in] block_i - Indexes of the block in the matrix-by-blocks structure.
     * \param[in] block_j - Indexes of the block in the matrix-by-blocks structure.
     * \param[in] **val_block - Block to subtract to A(i, j).
     */
    void SubtractBlock_ILUMatrix(unsigned long block_i, unsigned long block_j, double *val_block);
    
    /*!
     * \brief Adds the specified value to the diagonal of the (i, i) subblock
     *        of the matrix-by-blocks structure.
     * \param[in] block_i - Index of the block in the matrix-by-blocks structure.
     * \param[in] val_matrix - Value to add to the diagonal elements of A(i, i).
     */
    void AddVal2Diag(unsigned long block_i, double val_matrix);
    
    /*!
     * \brief Sets the specified value to the diagonal of the (i, i) subblock
     *        of the matrix-by-blocks structure.
     * \param[in] block_i - Index of the block in the matrix-by-blocks structure.
     * \param[in] val_matrix - Value to add to the diagonal elements of A(i, i).
     */
    void SetVal2Diag(unsigned long block_i, double val_matrix);
    
    /*!
     * \brief Calculates the matrix-vector product
     * \param[in] matrix
     * \param[in] vector
     * \param[out] product
     */
    void MatrixVectorProduct(double *matrix, double *vector, double *product);
    
    /*!
     * \brief Calculates the matrix-matrix product
     * \param[in] matrix_a
     * \param[in] matrix_b
     * \param[out] product
     */
    void MatrixMatrixProduct(double *matrix_a, double *matrix_b, double *product);
    
    /*!
     * \brief Deletes the values of the row i of the sparse matrix.
     * \param[in] i - Index of the row.
     */
    void DeleteValsRowi(unsigned long i);
    
    /*!
     * \brief Performs the Gauss Elimination algorithm to solve the linear subsystem of the (i, i) subblock and rhs.
     * \param[in] block_i - Index of the (i, i) subblock in the matrix-by-blocks structure.
     * \param[in] rhs - Right-hand-side of the linear system.
     * \return Solution of the linear system (overwritten on rhs).
     */
    void Gauss_Elimination(unsigned long block_i, double* rhs);
    
    /*!
     * \brief Performs the Gauss Elimination algorithm to solve the linear subsystem of the (i, i) subblock and rhs.
     * \param[in] Block - matrix-by-blocks structure.
     * \param[in] rhs - Right-hand-side of the linear system.
     * \return Solution of the linear system (overwritten on rhs).
     */
    void Gauss_Elimination(double* Block, double* rhs);
    
    /*!
     * \brief Performs the Gauss Elimination algorithm to solve the linear subsystem of the (i, i) subblock and rhs.
     * \param[in] block_i - Index of the (i, i) subblock in the matrix-by-blocks structure.
     * \param[in] rhs - Right-hand-side of the linear system.
     * \return Solution of the linear system (overwritten on rhs).
     */
    void Gauss_Elimination_ILUMatrix(unsigned long block_i, double* rhs);
    
    /*!
     * \fn void CSysMatrix::ProdBlockVector(unsigned long block_i, unsigned long block_j, double* vec);
     * \brief Performs the product of the block (i, j) by vector vec.
     * \param[in] block_i - Indexes of the block in the matrix-by-blocks structure.
     * \param[in] block_j - Indexes of the block in the matrix-by-blocks structure.
     * \param[in] vec - Vector to be multiplied by the block (i, j) of the sparse matrix A.
     * \return Product of A(i, j) by vector *vec (stored at *prod_block_vector).
     */
    void ProdBlockVector(unsigned long block_i, unsigned long block_j, const CSysVector & vec);
    
    /*!
     * \brief Performs the product of i-th row of the upper part of a sparse matrix by a vector.
     * \param[in] vec - Vector to be multiplied by the upper part of the sparse matrix A.
     * \param[in] row_i - Row of the matrix to be multiplied by vector vec.
     * \return prod Result of the product U(A)*vec (stored at *prod_row_vector).
     */
    void UpperProduct(CSysVector & vec, unsigned long row_i);
    
    /*!
     * \brief Performs the product of i-th row of the lower part of a sparse matrix by a vector.
     * \param[in] vec - Vector to be multiplied by the lower part of the sparse matrix A.
     * \param[in] row_i - Row of the matrix to be multiplied by vector vec.
     * \return prod Result of the product L(A)*vec (stored at *prod_row_vector).
     */
    void LowerProduct(CSysVector & vec, unsigned long row_i);
    
    /*!
     * \brief Performs the product of i-th row of the diagonal part of a sparse matrix by a vector.
     * \param[in] vec - Vector to be multiplied by the diagonal part of the sparse matrix A.
     * \param[in] row_i - Row of the matrix to be multiplied by vector vec.
     * \return prod Result of the product D(A)*vec (stored at *prod_row_vector).
     */
    void DiagonalProduct(CSysVector & vec, unsigned long row_i);
    
    /*!
     * \brief Send receive the solution using MPI.
     * \param[in] x - Solution..
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void SendReceive_Solution(CSysVector & x, CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Performs the product of i-th row of a sparse matrix by a vector.
     * \param[in] vec - Vector to be multiplied by the row of the sparse matrix A.
     * \param[in] row_i - Row of the matrix to be multiplied by vector vec.
     * \return Result of the product (stored at *prod_row_vector).
     */
    void RowProduct(const CSysVector & vec, unsigned long row_i);
    
    /*!
     * \brief Performs the product of a sparse matrix by a vector.
     * \param[in] vec - Vector to be multiplied by the sparse matrix A.
     * \param[out] prod - Result of the product.
     * \return Result of the product A*vec.
     */
    void MatrixVectorProduct(const CSysVector & vec, CSysVector & prod);
    
    /*!
     * \brief Performs the product of a sparse matrix by a CSysVector.
     * \param[in] vec - CSysVector to be multiplied by the sparse matrix A.
     * \param[out] prod - Result of the product.
     */
    void MatrixVectorProduct(const CSysVector & vec, CSysVector & prod, CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Performs the product of two block matrices.
     */
    void GetMultBlockBlock(double *c, double *a, double *b);
    
    /*!
     * \brief Performs the product of a block matrices by a vector.
     */
    void GetMultBlockVector(double *c, double *a, double *b);
    
    /*!
     * \brief Performs the subtraction of two matrices.
     */
    void GetSubsBlock(double *c, double *a, double *b);
    
    /*!
     * \brief Performs the subtraction of two vectors.
     */
    void GetSubsVector(double *c, double *a, double *b);
    
    /*!
     * \brief Inverse diagonal block.
     * \param[in] block_i - Indexes of the block in the matrix-by-blocks structure.
     * \param[out] invBlock - Inverse block.
     */
    void InverseDiagonalBlock(unsigned long block_i, double *invBlock);
    
    /*!
     * \brief Inverse diagonal block.
     * \param[in] block_i - Indexes of the block in the matrix-by-blocks structure.
     * \param[out] invBlock - Inverse block.
     */
    void InverseDiagonalBlock_ILUMatrix(unsigned long block_i, double *invBlock);
    
    /*!
     * \brief Inverse a block.
     * \param[in] Block - block matrix.
     * \param[out] invBlock - Inverse block.
     */
    void InverseBlock(double *Block, double *invBlock);
    
    /*!
     * \brief Build the Jacobi preconditioner.
     */
    void BuildJacobiPreconditioner(void);
    
    /*!
     * \brief Build the Jacobi preconditioner.
     */
    void BuildILUPreconditioner(void);
    
    /*!
     * \brief Build the Linelet preconditioner.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    unsigned short BuildLineletPreconditioner(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Multiply CSysVector by the preconditioner
     * \param[in] vec - CSysVector to be multiplied by the preconditioner.
     * \param[out] prod - Result of the product A*vec.
     */
    void ComputeJacobiPreconditioner(const CSysVector & vec, CSysVector & prod, CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Multiply CSysVector by the preconditioner
     * \param[in] vec - CSysVector to be multiplied by the preconditioner.
     * \param[out] prod - Result of the product A*vec.
     */
    void ComputeILUPreconditioner(const CSysVector & vec, CSysVector & prod, CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Multiply CSysVector by the preconditioner
     * \param[in] vec - CSysVector to be multiplied by the preconditioner.
     * \param[out] prod - Result of the product A*vec.
     */
    void ComputeLU_SGSPreconditioner(const CSysVector & vec, CSysVector & prod, CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Multiply CSysVector by the preconditioner
     * \param[in] vec - CSysVector to be multiplied by the preconditioner.
     * \param[out] prod - Result of the product A*vec.
     */
    void ComputeLineletPreconditioner(const CSysVector & vec, CSysVector & prod, CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Compute the residual Ax-b
     * \param[in] sol - CSysVector to be multiplied by the preconditioner.
     * \param[in] f - Result of the product A*vec.
     * \param[out] res - Result of the product A*vec.
     */
    void ComputeResidual(const CSysVector & sol, const CSysVector & f, CSysVector & res);
    
};

/*!
 * \class CSysMatrixVectorProduct
 * \brief specialization of matrix-vector product that uses CSysMatrix class
 */
class CSysMatrixVectorProduct : public CMatrixVectorProduct {
private:
    CSysMatrix* sparse_matrix; /*!< \brief pointer to matrix that defines the product. */
    CGeometry* geometry; /*!< \brief pointer to matrix that defines the geometry. */
    CConfig* config; /*!< \brief pointer to matrix that defines the config. */
    
public:
    
    /*!
     * \brief constructor of the class
     * \param[in] matrix_ref - matrix reference that will be used to define the products
     */
    CSysMatrixVectorProduct(CSysMatrix & matrix_ref, CGeometry *geometry_ref, CConfig *config_ref);
    
    /*!
     * \brief destructor of the class
     */
    ~CSysMatrixVectorProduct() {}
    
    /*!
     * \brief operator that defines the CSysMatrix-CSysVector product
     * \param[in] u - CSysVector that is being multiplied by the sparse matrix
     * \param[out] v - CSysVector that is the result of the product
     */
    void operator()(const CSysVector & u, CSysVector & v) const;
};

/*!
 * \class CJacobiPreconditioner
 * \brief specialization of preconditioner that uses CSysMatrix class
 */
class CJacobiPreconditioner : public CPreconditioner {
private:
    CSysMatrix* sparse_matrix; /*!< \brief pointer to matrix that defines the preconditioner. */
    CGeometry* geometry; /*!< \brief pointer to matrix that defines the geometry. */
    CConfig* config; /*!< \brief pointer to matrix that defines the config. */
    
public:
    
    /*!
     * \brief constructor of the class
     * \param[in] matrix_ref - matrix reference that will be used to define the preconditioner
     */
    CJacobiPreconditioner(CSysMatrix & matrix_ref, CGeometry *geometry_ref, CConfig *config_ref);
    
    /*!
     * \brief destructor of the class
     */
    ~CJacobiPreconditioner() {}
    
    /*!
     * \brief operator that defines the preconditioner operation
     * \param[in] u - CSysVector that is being preconditioned
     * \param[out] v - CSysVector that is the result of the preconditioning
     */
    void operator()(const CSysVector & u, CSysVector & v) const;
};


/*!
 * \class CILUPreconditioner
 * \brief specialization of preconditioner that uses CSysMatrix class
 */
class CILUPreconditioner : public CPreconditioner {
private:
    CSysMatrix* sparse_matrix; /*!< \brief pointer to matrix that defines the preconditioner. */
    CGeometry* geometry; /*!< \brief pointer to matrix that defines the geometry. */
    CConfig* config; /*!< \brief pointer to matrix that defines the config. */
    
public:
    
    /*!
     * \brief constructor of the class
     * \param[in] matrix_ref - matrix reference that will be used to define the preconditioner
     */
    CILUPreconditioner(CSysMatrix & matrix_ref, CGeometry *geometry_ref, CConfig *config_ref);
    
    /*!
     * \brief destructor of the class
     */
    ~CILUPreconditioner() {}
    
    /*!
     * \brief operator that defines the preconditioner operation
     * \param[in] u - CSysVector that is being preconditioned
     * \param[out] v - CSysVector that is the result of the preconditioning
     */
    void operator()(const CSysVector & u, CSysVector & v) const;
};

/*!
 * \class CLU_SGSPreconditioner
 * \brief specialization of preconditioner that uses CSysMatrix class
 */
class CLU_SGSPreconditioner : public CPreconditioner {
private:
    CSysMatrix* sparse_matrix; /*!< \brief pointer to matrix that defines the preconditioner. */
    CGeometry* geometry; /*!< \brief pointer to matrix that defines the geometry. */
    CConfig* config; /*!< \brief pointer to matrix that defines the config. */
    
public:
    
    /*!
     * \brief constructor of the class
     * \param[in] matrix_ref - matrix reference that will be used to define the preconditioner
     */
    CLU_SGSPreconditioner(CSysMatrix & matrix_ref, CGeometry *geometry_ref, CConfig *config_ref);
    
    /*!
     * \brief destructor of the class
     */
    ~CLU_SGSPreconditioner() {}
    
    /*!
     * \brief operator that defines the preconditioner operation
     * \param[in] u - CSysVector that is being preconditioned
     * \param[out] v - CSysVector that is the result of the preconditioning
     */
    void operator()(const CSysVector & u, CSysVector & v) const;
};

/*!
 * \class CLineletPreconditioner
 * \brief specialization of preconditioner that uses CSysMatrix class
 */
class CLineletPreconditioner : public CPreconditioner {
private:
    CSysMatrix* sparse_matrix; /*!< \brief pointer to matrix that defines the preconditioner. */
    CGeometry* geometry; /*!< \brief pointer to matrix that defines the geometry. */
    CConfig* config; /*!< \brief pointer to matrix that defines the config. */
    
public:
    
    /*!
     * \brief constructor of the class
     * \param[in] matrix_ref - matrix reference that will be used to define the preconditioner
     */
    CLineletPreconditioner(CSysMatrix & matrix_ref, CGeometry *geometry_ref, CConfig *config_ref);
    
    /*!
     * \brief destructor of the class
     */
    ~CLineletPreconditioner() {}
    
    /*!
     * \brief operator that defines the preconditioner operation
     * \param[in] u - CSysVector that is being preconditioned
     * \param[out] v - CSysVector that is the result of the preconditioning
     */
    void operator()(const CSysVector & u, CSysVector & v) const;
};


/* linear_solvers_structure.hpp------------------------------------------------------------
 *
 *
 *
 */

/*!
 * \class CSysSolve
 * \brief Class for solving linear systems using classical and Krylov-subspace iterative methods
 * \author J. Hicken.
 * \version 3.2.9 "eagle"
 *
 * The individual solvers could be stand-alone subroutines, but by
 * creating CSysSolve objects we can more easily assign different
 * matrix-vector products and preconditioners to different problems
 * that may arise in a hierarchical solver (i.e. multigrid).
 */
class CSysSolve {
    
private:
    
    /*!
     * \brief sign transfer function
     * \param[in] x - value having sign prescribed
     * \param[in] y - value that defined the sign
     *
     * this may already be defined as a global function somewhere, if
     * so, feel free to delete this and replace it as needed with the
     * appropriate global function
     */
    double Sign(const double & x, const double & y) const;
    
    /*!
     * \brief applys a Givens rotation to a 2-vector
     * \param[in] s - sine of the Givens rotation angle
     * \param[in] c - cosine of the Givens rotation angle
     * \param[in, out] h1 - first element of 2x1 vector being transformed
     * \param[in, out] h2 - second element of 2x1 vector being transformed
     */
    void ApplyGivens(const double & s, const double & c, double & h1, double & h2);
    
    /*!
     * \brief generates the Givens rotation matrix for a given 2-vector
     * \param[in, out] dx - element of 2x1 vector being transformed
     * \param[in, out] dy - element of 2x1 vector being set to zero
     * \param[in, out] s - sine of the Givens rotation angle
     * \param[in, out] c - cosine of the Givens rotation angle
     *
     * Based on givens() of SPARSKIT, which is based on p.202 of
     * "Matrix Computations" by Golub and van Loan.
     */
    void GenerateGivens(double & dx, double & dy, double & s, double & c);
    
    /*!
     * \brief finds the solution of the upper triangular system Hsbg*x = rhs
     *
     * \param[in] n - size of the reduced system
     * \param[in] Hsbg - upper triangular matrix
     * \param[in] rhs - right-hand side of the reduced system
     * \param[out] x - solution of the reduced system
     *
     * \pre the upper Hessenberg matrix has been transformed into a
     * triangular matrix.
     */
    void SolveReduced(const int & n, const vector<vector<double> > & Hsbg,
                      const vector<double> & rhs, vector<double> & x);
    
    /*!
     * \brief Modified Gram-Schmidt orthogonalization
     * \author Based on Kesheng John Wu's mgsro subroutine in Saad's SPARSKIT
     *
     * \tparam Vec - a generic vector class
     * \param[in] i - index indicating which vector in w is being orthogonalized
     * \param[in, out] Hsbg - the upper Hessenberg begin updated
     * \param[in, out] w - the (i+1)th vector of w is orthogonalized against the
     *                    previous vectors in w
     *
     * \pre the vectors w[0:i] are orthonormal
     * \post the vectors w[0:i+1] are orthonormal
     *
     * Reothogonalization is performed if the cosine of the angle between
     * w[i+1] and w[k], k < i+1, is greater than 0.98.  The norm of the "new"
     * vector is kept in nrm0 and updated after operating with each vector
     *
     */
    void ModGramSchmidt(int i, vector<vector<double> > & Hsbg, vector<CSysVector> & w);
    
    /*!
     * \brief writes header information for a CSysSolve residual history
     * \param[in, out] os - ostream class object for output
     * \param[in] solver - string describing the solver
     * \param[in] restol - the target tolerance to solve to
     * \param[in] resinit - the initial residual norm (absolute)
     *
     * \pre the ostream object os should be open
     */
    void WriteHeader(const string & solver, const double & restol, const double & resinit);
    
    /*!
     * \brief writes residual convergence data for one iteration to a stream
     * \param[in] iter - current iteration
     * \param[in] res - the (absolute) residual norm value
     * \param[in] resinit - the initial residual norm
     *
     * \pre the ostream object os should be open
     */
    void WriteHistory(const int & iter, const double & res, const double & resinit);
    
public:
    
    /*! \brief Conjugate Gradient method
     * \param[in] b - the right hand size vector
     * \param[in, out] x - on entry the intial guess, on exit the solution
     * \param[in] mat_vec - object that defines matrix-vector product
     * \param[in] precond - object that defines preconditioner
     * \param[in] tol - tolerance with which to solve the system
     * \param[in] m - maximum size of the search subspace
     * \param[in] monitoring - turn on priting residuals from solver to screen.
     */
    unsigned long CG_LinSolver(const CSysVector & b, CSysVector & x, CMatrixVectorProduct & mat_vec,
                               CPreconditioner & precond, double tol,
                               unsigned long m, bool monitoring);
    
    /*!
     * \brief Flexible Generalized Minimal Residual method
     * \param[in] b - the right hand size vector
     * \param[in, out] x - on entry the intial guess, on exit the solution
     * \param[in] mat_vec - object that defines matrix-vector product
     * \param[in] precond - object that defines preconditioner
     * \param[in] tol - tolerance with which to solve the system
     * \param[in] m - maximum size of the search subspace
     * \param[in] monitoring - turn on priting residuals from solver to screen.
     */
    unsigned long FGMRES_LinSolver(const CSysVector & b, CSysVector & x, CMatrixVectorProduct & mat_vec,
                                   CPreconditioner & precond, double tol,
                                   unsigned long m, double *residual, bool monitoring);
    
    /*!
     * \brief Biconjugate Gradient Stabilized Method (BCGSTAB)
     * \param[in] b - the right hand size vector
     * \param[in, out] x - on entry the intial guess, on exit the solution
     * \param[in] mat_vec - object that defines matrix-vector product
     * \param[in] precond - object that defines preconditioner
     * \param[in] tol - tolerance with which to solve the system
     * \param[in] m - maximum size of the search subspace
     * \param[in] monitoring - turn on priting residuals from solver to screen.
     */
    unsigned long BCGSTAB_LinSolver(const CSysVector & b, CSysVector & x, CMatrixVectorProduct & mat_vec,
                                    CPreconditioner & precond, double tol,
                                    unsigned long m, double *residual, bool monitoring);
    
    /*!
     * \brief Solve the linear system using a Krylov subspace method
     * \param[in] Jacobian - Jacobian Matrix for the linear system
     * \param[in] LinSysRes - Linear system residual
     * \param[in] LinSysSol - Linear system solution
     * \param[in] geometry -  Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    unsigned long Solve(CSysMatrix & Jacobian, CSysVector & LinSysRes, CSysVector & LinSysSol, CGeometry *geometry, CConfig *config);
    
};



/* grid_adaptation_structure.hpp------------------------------------------------------------
 *
 *
 *
 */

/*!
 * \class CGridAdaptation
 * \brief Parent class for defining the grid adaptation.
 * \author F. Palacios
 * \version 2.0.7
 */
class CGridAdaptation {
protected:
    unsigned long nPoint_new,	/*!< \brief Number of new points. */
    nElem_new;					/*!< \brief Number of new elements. */
    unsigned short nDim,	/*!< \brief Number of dimensions of the problem. */
    nVar;					/*!< \brief Number of variables in the problem. */
    double **ConsVar_Sol,	/*!< \brief Conservative variables (original solution). */
    **ConsVar_Res,			/*!< \brief Conservative variables (residual). */
    **ConsVar_Adapt;		/*!< \brief Conservative variables (adapted solution). */
    double **AdjVar_Sol,	/*!< \brief Adjoint variables (original solution). */
    **AdjVar_Res,			/*!< \brief Adjoint variables (residual). */
    **AdjVar_Adapt;			/*!< \brief Adjoint variables (adapted solution). */
    double **LinVar_Sol,	/*!< \brief Linear variables (original solution). */
    **LinVar_Res,			/*!< \brief Linear variables (residual). */
    **LinVar_Adapt;			/*!< \brief Linear variables (adapted solution). */
    double **Gradient,		/*!< \brief Gradient value. */
    **Gradient_Flow,		/*!< \brief Gradient of the flow variables. */
    **Gradient_Adj;			/*!< \brief Fradient of the adjoint variables. */
    double *Index;			/*!< \brief Adaptation index (indicates the value of the adaptation). */
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CGridAdaptation(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CGridAdaptation(void);
    
    /*!
     * \brief Read the flow solution from the restart file.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void GetFlowSolution(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Read the flow solution from the restart file.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void GetFlowResidual(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Read the flow solution from the restart file.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void GetAdjSolution(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Read the flow solution from the restart file.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void GetAdjResidual(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Read the flow solution from the restart file.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void GetLinSolution(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Read the flow solution from the restart file.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void GetLinResidual(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Do a complete adaptation of the computational grid.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] strength - Adaptation Strength.
     */
    void SetComplete_Refinement(CGeometry *geometry, unsigned short strength);
    
    /*!
     * \brief Do not do any kind of adaptation.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] strength - Adaptation Strength.
     */
    void SetNo_Refinement(CGeometry *geometry, unsigned short strength);
    
    /*!
     * \brief Do an adaptation of the computational grid on the wake.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] strength - Adaptation Strength.
     */
    void SetWake_Refinement(CGeometry *geometry, unsigned short strength);
    
    /*!
     * \brief Do an adaptation of the computational grid on the supersonic shock region.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void SetSupShock_Refinement(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Do an adaptation of the computational grid on a near field boundary.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    //void SetNearField_Refinement(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Do a complete adaptation of the computational grid using a homothetic technique (2D).
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] geo_adapt - Geometrical definition of the adapted grid.
     * \param[in] config - Definition of the particular problem.
     */
    void SetHomothetic_Adaptation2D(CGeometry *geometry, CPhysicalGeometry *geo_adapt, CConfig *config);
    
    /*!
     * \brief Do a complete adaptation of the computational grid using a homothetic technique (3D).
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] geo_adapt - Geometrical definition of the adapted grid.
     * \param[in] config - Definition of the particular problem.
     */
    void SetHomothetic_Adaptation3D(CGeometry *geometry, CPhysicalGeometry *geo_adapt, CConfig *config);
    
    /*!
     * \brief Find the adaptation code for each element in the fine grid.
     * \param[in] AdaptCode - Edge combination to stablish the right elemeent division.
     * \return Adaptation code for the element.
     */
    long CheckTriangleCode(bool *AdaptCode);
    
    /*!
     * \brief Find the adaptation code for each element in the fine grid.
     * \param[in] AdaptCode - Edge combination to stablish the right elemeent division.
     * \return Adaptation code for the element.
     */
    long CheckRectCode(bool *AdaptCode);
    
    /*!
     * \brief Find the adaptation code for each element in the fine grid.
     * \param[in] AdaptCode - Edge combination to stablish the right elemeent division.
     * \return Adaptation code for the element.
     */
    long CheckRectExtCode(bool *AdaptCode);
    
    /*!
     * \brief Find the adaptation code for each element in the fine grid.
     * \param[in] AdaptCode - Edge combination to stablish the right elemeent division.
     * \return Adaptation code for the element.
     */
    long CheckTetraCode(bool *AdaptCode);
    
    /*!
     * \brief Find the adaptation code for each element in the fine grid.
     * \param[in] AdaptCode - Edge combination to stablish the right elemeent division.
     * \return Adaptation code for the element.
     */
    long CheckHexaCode(bool *AdaptCode);
    
    /*!
     * \brief Find the adaptation code for each element in the fine grid.
     * \param[in] AdaptCode - Edge combination to stablish the right elemeent division.
     * \return Adaptation code for the element.
     */
    long CheckPyramCode(bool *AdaptCode);
    
    /*!
     * \brief Division pattern of the element.
     * \param[in] code - number that identify the division.
     * \param[in] nodes - Nodes that compose the element, including new nodes.
     * \param[in] edges - Edges that compose the element.
     * \param[out] Division - Division pattern.
     * \param[out] nPart - Number of new elements after the division.
     */
    void TriangleDivision(long code, long *nodes, long *edges, long **Division, long *nPart);
    
    /*!
     * \brief Division pattern of the element.
     * \param[in] code - number that identify the division.
     * \param[in] nodes - Nodes that compose the element, including new nodes.
     * \param[in] edges - Edges that compose the element.
     * \param[out] Division - Division pattern.
     * \param[out] nPart - Number of new elements after the division.
     */
    void RectDivision(long code, long *nodes, long **Division, long *nPart);
    
    /*!
     * \brief Division pattern of the element.
     * \param[in] code - number that identify the division.
     * \param[in] nodes - Nodes that compose the element, including new nodes.
     * \param[in] edges - Edges that compose the element.
     * \param[out] Division - Division pattern.
     * \param[out] nPart - Number of new elements after the division.
     */
    void RectExtDivision(long code, long *nodes, long **Division, long *nPart);
    
    /*!
     * \brief Division pattern of the element.
     * \param[in] code - number that identify the division.
     * \param[in] nodes - Nodes that compose the element, including new nodes.
     * \param[in] edges - Edges that compose the element.
     * \param[out] Division - Division pattern.
     * \param[out] nPart - Number of new elements after the division.
     */
    void TetraDivision(long code, long *nodes, long *edges, long **Division, long *nPart);
    
    /*!
     * \brief Division pattern of the element.
     * \param[in] code - number that identify the division.
     * \param[in] nodes - Nodes that compose the element, including new nodes.
     * \param[in] edges - Edges that compose the element.
     * \param[out] Division - Division pattern.
     * \param[out] nPart - Number of new elements after the division.
     */
    void HexaDivision(long code, long *nodes, long **Division, long *nPart);
    
    /*!
     * \brief Division pattern of the element.
     * \param[in] code - number that identify the division.
     * \param[in] nodes - Nodes that compose the element, including new nodes.
     * \param[in] edges - Edges that compose the element.
     * \param[out] Division - Division pattern.
     * \param[out] nPart - Number of new elements after the division.
     */
    void PyramDivision(long code, long *nodes, long **Division, long *nPart);
    
    /*!
     * \brief Do a complete adaptation of the computational grid.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     * \param[in] strength _________________________.
     */
    void SetIndicator_Flow(CGeometry *geometry, CConfig *config, unsigned short strength);
    
    /*!
     * \brief Do a complete adaptation of the computational grid.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     * \param[in] strength _________________________.
     */
    void SetIndicator_Adj(CGeometry *geometry, CConfig *config, unsigned short strength);
    
    /*!
     * \brief Do a complete adaptation of the computational grid.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void SetIndicator_FlowAdj(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Read the flow solution from the restart file.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void SetIndicator_Robust(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Read the flow solution from the restart file.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void SetIndicator_Computable(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Read the flow solution from the restart file.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void SetIndicator_Computable_Robust(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Write the restart file with the adapted grid.
     * \param[in] config - Definition of the particular problem.
     * \param[in] mesh_flowfilename - _________________________.
     */
    void SetRestart_FlowSolution(CConfig *config, CPhysicalGeometry *geo_adapt, string mesh_flowfilename);
    
    /*!
     * \brief Write the restart file with the adapted grid.
     * \param[in] config - Definition of the particular problem.
     * \param[in] mesh_adjfilename - _________________________.
     */		
    void SetRestart_AdjSolution(CConfig *config, CPhysicalGeometry *geo_adapt, string mesh_adjfilename);
    
    /*! 
     * \brief Read the flow solution from the restart file.
     * \param[in] config - Definition of the particular problem.
     * \param[in] mesh_linfilename - _________________________.
     */	
    void SetRestart_LinSolution(CConfig *config, CPhysicalGeometry *geo_adapt, string mesh_linfilename);
    
    /*! 
     * \brief Read the flow solution from the restart file.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     * \param[in] max_elem - _________________________.
     */	
    void SetSensorElem(CGeometry *geometry, CConfig *config, unsigned long max_elem);
    
};


/* grid_movement_structure.hpp------------------------------------------------------------
 *
 *
 *
 */
/*!
 * \class CGridMovement
 * \brief Class for moving the surface and volumetric
 *        numerical grid (2D and 3D problems).
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CGridMovement {
public:
    
    /*!
     * \brief Constructor of the class.
     */
    CGridMovement(void);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CGridMovement(void);
    
    
    /*!
     * \brief A pure virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void SetSurface_Deformation(CGeometry *geometry, CConfig *config);
    
};

/*!
 * \class CFreeFormDefBox
 * \brief Class for defining the free form FFDBox structure.
 * \author F. Palacios & A. Galdran.
 * \version 3.2.9 "eagle"
 */
class CFreeFormDefBox : public CGridMovement {
public:
    unsigned short nDim;                  /*!< \brief Number of dimensions of the problem. */
    unsigned short nCornerPoints,         /*!< \brief Number of corner points of the FFDBox. */
    nControlPoints, nControlPoints_Copy;  /*!< \brief Number of control points of the FFDBox. */
    double **Coord_Corner_Points,		/*!< \brief Coordinates of the corner points. */
    ****Coord_Control_Points,				/*!< \brief Coordinates of the control points. */
    ****ParCoord_Control_Points,		/*!< \brief Coordinates of the control points. */
    ****Coord_Control_Points_Copy,	/*!< \brief Coordinates of the control points (copy). */
    ****Coord_SupportCP;						/*!< \brief Coordinates of the support control points. */
    unsigned short lOrder, lOrder_Copy,	/*!< \brief Order of the FFDBox in the i direction. */
    mOrder,	mOrder_Copy, 								/*!< \brief Order of the FFDBox in the j direction. */
    nOrder, nOrder_Copy;									/*!< \brief Order of the FFDBox in the k direction. */
    unsigned short lDegree, lDegree_Copy, /*!< \brief Degree of the FFDBox in the i direction. (lOrder - 1)*/
    mDegree, mDegree_Copy,								/*!< \brief Degree of the FFDBox in the j direction. (mOrder - 1)*/
    nDegree, nDegree_Copy;								/*!< \brief Degree of the FFDBox in the k direction. (nOrder - 1)*/
    double *ParamCoord, *ParamCoord_,	/*!< \brief Parametric coordinates of a point. */
    *cart_coord, *cart_coord_;			/*!< \brief Cartesian coordinates of a point. */
    double ObjFunc;			/*!< \brief Objective function of the point inversion process. */
    double *Gradient;			/*!< \brief Gradient of the point inversion process. */
    double **Hessian;    /*!< \brief Hessian of the point inversion process. */
    double MaxCoord[3];		/*!< \brief Maximum coordinates of the FFDBox. */
    double MinCoord[3];		/*!< \brief Minimum coordinates of the FFDBox. */
    string Tag;						/*!< \brief Tag to identify the FFDBox. */
    unsigned short Level;								/*!< \brief Nested level of the FFD box. */
    vector<double> CartesianCoord[3];		/*!< \brief Vector with all the cartesian coordinates in the FFD FFDBox. */
    vector<double> ParametricCoord[3];	/*!< \brief Vector with all the parametrics coordinates in the FFD FFDBox. */
    vector<unsigned short> MarkerIndex;	/*!< \brief Vector with all markers in the FFD FFDBox. */
    vector<unsigned long> VertexIndex;	/*!< \brief Vector with all vertex index in the FFD FFDBox. */
    vector<unsigned long> PointIndex;		/*!< \brief Vector with all points index in the FFD FFDBox. */
    unsigned long nSurfacePoint;				/*!< \brief Number of surfaces in the FFD FFDBox. */
    vector<string> ParentFFDBox;					/*!< \brief Vector with all the parent FFD FFDBox. */
    vector<string> ChildFFDBox;					/*!< \brief Vector with all the child FFD FFDBox. */
    vector<unsigned short> Fix_IPlane;  /*!< \brief Fix FFD I plane. */
    vector<unsigned short> Fix_JPlane;  /*!< \brief Fix FFD J plane. */
    vector<unsigned short> Fix_KPlane;  /*!< \brief Fix FFD K plane. */
    
public:
    
    /*!
     * \brief Constructor of the class.
     */
    CFreeFormDefBox(void);
    
    /*!
     * \overload
     * \param[in] val_lDegree - Degree of the FFDBox in the i direction.
     * \param[in] val_mDegree - Degree of the FFDBox in the j direction.
     * \param[in] val_nDegree - Degree of the FFDBox in the k direction.
     */
    CFreeFormDefBox(unsigned short val_lDegree, unsigned short val_mDegree, unsigned short val_nDegree);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CFreeFormDefBox(void);
    
    /*!
     * \brief Define the I planes to to fix in a FFD box.
     * \param[in] val_plane - Index of the plane to fix.
     */
    void Set_Fix_IPlane(unsigned short val_plane);
    
    /*!
     * \brief Define the I planes to to fix in a FFD box.
     * \param[in] val_plane - Index of the plane to fix.
     */
    void Set_Fix_JPlane(unsigned short val_plane);
    
    /*!
     * \brief Define the I planes to to fix in a FFD box.
     * \param[in] val_plane - Index of the plane to fix.
     */
    void Set_Fix_KPlane(unsigned short val_plane);
    
    /*!
     * \brief Define the I planes to to fix in a FFD box.
     * \param[in] val_plane - Index of the plane to fix.
     */
    unsigned short Get_Fix_IPlane(unsigned short val_index);
    
    /*!
     * \brief Define the I planes to to fix in a FFD box.
     * \param[in] val_plane - Index of the plane to fix.
     */
    unsigned short Get_Fix_JPlane(unsigned short val_index);
    
    /*!
     * \brief Define the I planes to to fix in a FFD box.
     * \param[in] val_plane - Index of the plane to fix.
     */
    unsigned short Get_Fix_KPlane(unsigned short val_index);
    
    /*!
     * \brief Define the I planes to to fix in a FFD box.
     * \param[in] val_plane - Index of the plane to fix.
     */
    unsigned short Get_nFix_IPlane(void);
    
    /*!
     * \brief Define the I planes to to fix in a FFD box.
     * \param[in] val_plane - Index of the plane to fix.
     */
    unsigned short Get_nFix_JPlane(void);
    
    /*!
     * \brief Define the I planes to to fix in a FFD box.
     * \param[in] val_plane - Index of the plane to fix.
     */
    unsigned short Get_nFix_KPlane(void);
    
    /*!
     * \brief Add to the vector of markers a new marker.
     * \param[in] val_iMarker - New marker inside the FFD box.
     */
    void Set_MarkerIndex(unsigned short val_iMarker);
    
    /*!
     * \brief Add to the vector of vertices a new vertex.
     * \param[in] val_iVertex - New vertex inside the FFD box.
     */
    void Set_VertexIndex(unsigned long val_iVertex);
    
    /*!
     * \brief Add to the vector of points a new point.
     * \param[in] val_iPoint - New point inside the FFD box.
     */
    void Set_PointIndex(unsigned long val_iPoint);
    
    /*!
     * \brief Add to the vector of cartesian coordinates a new coordinate.
     * \param[in] val_coord - New coordinate inside the FFD box.
     */
    void Set_CartesianCoord(double *val_coord);
    
    /*!
     * \brief Add to the vector of parametric coordinates a new coordinate.
     * \param[in] val_coord - New coordinate inside the FFD box.
     */
    void Set_ParametricCoord(double *val_coord);
    
    /*!
     * \brief Add to the vector of parent FFDBoxes a new FFD FFDBox.
     * \param[in] val_iParentFFDBox - New parent FFDBox in the vector.
     */
    void SetParentFFDBox(string val_iParentFFDBox);
    
    /*!
     * \brief Add to the vector of child FFDBoxes a new FFD FFDBox.
     * \param[in] val_iChildFFDBox - New child FFDBox in the vector.
     */
    void SetChildFFDBox(string val_iChildFFDBox);
    
    /*!
     * \brief _______________.
     * \param[in] val_coord - _______________.
     * \param[in] val_iSurfacePoints - _______________.
     */
    void Set_CartesianCoord(double *val_coord, unsigned long val_iSurfacePoints);
    
    /*!
     * \brief _______________.
     * \param[in] val_coord - _______________.
     * \param[in] val_iSurfacePoints - _______________.
     */
    void Set_ParametricCoord(double *val_coord, unsigned long val_iSurfacePoints);
    
    /*!
     * \brief _______________.
     * \param[in] Get_MarkerIndex - _______________.
     * \return _______________.
     */
    unsigned short Get_MarkerIndex(unsigned long val_iSurfacePoints);
    
    /*!
     * \brief _______________.
     * \param[in] Get_VertexIndex - _______________.
     * \return _______________.
     */
    unsigned long Get_VertexIndex(unsigned long val_iSurfacePoints);
    
    /*!
     * \brief _______________.
     * \param[in] Get_PointIndex - _______________.
     * \return _______________.
     */
    unsigned long Get_PointIndex(unsigned long val_iSurfacePoints);
    
    /*!
     * \brief _______________.
     * \param[in] Get_CartesianCoord - _______________.
     * \return _______________.
     */
    double *Get_CartesianCoord(unsigned long val_iSurfacePoints);
    
    /*!
     * \brief _______________.
     * \param[in] Get_ParametricCoord - _______________.
     * \return _______________.
     */
    double *Get_ParametricCoord(unsigned long val_iSurfacePoints);
    
    /*!
     * \brief _______________.
     * \param[in] GetnSurfacePoint - _______________.
     * \return _______________.
     */
    unsigned long GetnSurfacePoint(void);
    
    /*!
     * \brief _______________.
     * \param[in] GetnParentFFDBox - _______________.
     * \return _______________.
     */
    unsigned short GetnParentFFDBox(void);
    
    /*!
     * \brief _______________.
     * \param[in] GetnChildFFDBox - _______________.
     * \return _______________.
     */
    unsigned short GetnChildFFDBox(void);
    
    /*!
     * \brief _______________.
     * \param[in] val_ParentFFDBox - _______________.
     * \return _______________.
     */
    string GetParentFFDBoxTag(unsigned short val_ParentFFDBox);
    
    /*!
     * \brief _______________.
     * \param[in] val_ChildFFDBox - _______________.
     * \return _______________.
     */
    string GetChildFFDBoxTag(unsigned short val_ChildFFDBox);
    
    /*!
     * \brief Change the the position of the corners of the unitary FFDBox,
     *        and find the position of the control points for the FFDBox
     * \param[in] FFDBox - Original FFDBox where we want to compute the control points.
     */
    void SetSupportCPChange(CFreeFormDefBox *FFDBox);
    
    /*!
     * \brief Set the number of corner points.
     * \param[in] val_ncornerpoints - Number of corner points.
     */
    void SetnCornerPoints(unsigned short val_ncornerpoints);
    
    /*!
     * \brief Get the number of corner points.
     * \return Number of corner points.
     */
    unsigned short GetnCornerPoints(void);
    
    /*!
     * \brief Get the number of control points.
     * \return Number of control points.
     */
    unsigned short GetnControlPoints(void);
    
    /*!
     * \brief Get the number of control points.
     * \return Number of control points.
     */
    void SetnControlPoints(void);
    
    /*!
     * \brief Get the number of numerical points on the surface.
     * \return Number of numerical points on the surface.
     */
    unsigned long GetnSurfacePoints(void);
    
    /*!
     * \brief Set the corner point for the unitary FFDBox.
     */
    void SetUnitCornerPoints(void);
    
    /*!
     * \brief Set the coordinates of the corner points.
     * \param[in] val_coord - Coordinates of the corner point with index <i>val_icornerpoints</i>.
     * \param[in] val_icornerpoints - Index of the corner point.
     */
    void SetCoordCornerPoints(double *val_coord, unsigned short val_icornerpoints);
    
    /*!
     * \overload
     * \param[in] val_xcoord - X coordinate of the corner point with index <i>val_icornerpoints</i>.
     * \param[in] val_ycoord - Y coordinate of the corner point with index <i>val_icornerpoints</i>.
     * \param[in] val_zcoord - Z coordinate of the corner point with index <i>val_icornerpoints</i>.
     * \param[in] val_icornerpoints - Index of the corner point.
     */
    void SetCoordCornerPoints(double val_xcoord, double val_ycoord, double val_zcoord, unsigned short val_icornerpoints);
    
    /*!
     * \brief Set the coordinates of the control points.
     * \param[in] val_coord - Coordinates of the control point.
     * \param[in] iDegree - Index of the FFDBox, i direction.
     * \param[in] jDegree - Index of the FFDBox, j direction.
     * \param[in] kDegree - Index of the FFDBox, k direction.
     */
    void SetCoordControlPoints(double *val_coord, unsigned short iDegree, unsigned short jDegree, unsigned short kDegree);
    
    /*!
     * \brief Set the coordinates of the control points.
     * \param[in] val_coord - Coordinates of the control point.
     * \param[in] iDegree - Index of the FFDBox, i direction.
     * \param[in] jDegree - Index of the FFDBox, j direction.
     * \param[in] kDegree - Index of the FFDBox, k direction.
     */
    void SetCoordControlPoints_Copy(double *val_coord, unsigned short iDegree, unsigned short jDegree, unsigned short kDegree);
    
    /*!
     * \brief Set the coordinates of the control points.
     * \param[in] val_coord - Coordinates of the control point.
     * \param[in] iDegree - Index of the FFDBox, i direction.
     * \param[in] jDegree - Index of the FFDBox, j direction.
     * \param[in] kDegree - Index of the FFDBox, k direction.
     */
    void SetParCoordControlPoints(double *val_coord, unsigned short iDegree, unsigned short jDegree, unsigned short kDegree);
    
    /*!
     * \brief Get the coordinates of the corner points.
     * \param[in] val_dim - Index of the coordinate (x, y, z).
     * \param[in] val_icornerpoints - Index of the corner point.
     * \return Coordinate <i>val_dim</i> of the corner point <i>val_icornerpoints</i>.
     */
    double GetCoordCornerPoints(unsigned short val_dim, unsigned short val_icornerpoints);
    
    /*!
     * \brief Get the coordinates of the corner points.
     * \param[in] val_icornerpoints - Index of the corner point.
     * \return Pointer to the coordinate vector of the corner point <i>val_icornerpoints</i>.
     */
    double *GetCoordCornerPoints(unsigned short val_icornerpoints);
    
    /*!
     * \brief Get the coordinates of the control point.
     * \param[in] val_iindex - Value of the local i index of the control point.
     * \param[in] val_jindex - Value of the local j index of the control point.
     * \param[in] val_kindex - Value of the local k index of the control point.
     * \return Pointer to the coordinate vector of the control point with local index (i, j, k).
     */
    double *GetCoordControlPoints(unsigned short val_iindex, unsigned short val_jindex, unsigned short val_kindex);
    
    /*!
     * \brief Get the parametric coordinates of the control point.
     * \param[in] val_iindex - Value of the local i index of the control point.
     * \param[in] val_jindex - Value of the local j index of the control point.
     * \param[in] val_kindex - Value of the local k index of the control point.
     * \return Pointer to the coordinate vector of the control point with local index (i, j, k).
     */
    double *GetParCoordControlPoints(unsigned short val_iindex, unsigned short val_jindex, unsigned short val_kindex);
    
    /*!
     * \brief Set the control points in a parallelepiped (hexahedron).
     */
    void SetControlPoints_Parallelepiped(void);
    
    /*!
     * \brief Set the control points of the final chuck in a unitary hexahedron free form.
     * \param[in] FFDBox - Original FFDBox where we want to compute the control points.
     */
    void SetSupportCP(CFreeFormDefBox *FFDBox);
    
    /*!
     * \brief Set the new value of the coordinates of the control points.
     * \param[in] val_index - Local index (i, j, k) of the control point.
     * \param[in] movement - Movement of the control point.
     */
    void SetControlPoints(unsigned short *val_index, double *movement);
    
    /*!
     * \brief Set the original value of the control points.
     */
    void SetOriginalControlPoints(void);
    
    /*!
     * \brief Set the tecplot file of the FFD chuck structure.
     * \param[in] iFFDBox - Index of the FFD box.
     * \param[in] original - Original box (before deformation).
     */
    void SetTecplot(CGeometry *geometry, unsigned short iFFDBox, bool original);
    
    /*!
     * \brief Set the cartesian coords of a point in R^3 and convert them to the parametric coords of
     *        our parametrization of a paralellepiped.
     * \param[in] cart_coord - Cartesian coordinates of a point.
     * \return Pointer to the parametric coordinates of a point.
     */
    double *GetParametricCoord_Analytical(double *cart_coord);
    
    /*!
     * \brief Iterative strategy for computing the parametric coordinates.
     * \param[in] xyz - Cartesians coordinates of the target point.
     * \param[in] guess - Initial guess for doing the parametric coordinates search.
     * \param[in] tol - Level of convergence of the iterative method.
     * \param[in] it_max - Maximal number of iterations.
     * \return Parametric coordinates of the point.
     */
    double *GetParametricCoord_Iterative(unsigned long iPoint, double *xyz, double *guess, CConfig *config);
    
    /*!
     * \brief Compute the cross product.
     * \param[in] v1 - First input vector.
     * \param[in] v2 - Second input vector.
     * \param[out] v3 - Output vector wuth the cross product.
     */
    void CrossProduct(double *v1, double *v2, double *v3);
    
    /*!
     * \brief Compute the doc product.
     * \param[in] v1 - First input vector.
     * \param[in] v2 - Sencond input vector.
     * \return Dot product between <i>v1</i>, and <i>v2</i>.
     */
    double DotProduct(double *v1, double *v2);
    
    /*!
     * \brief Here we take the parametric coords of a point in the box and we convert them to the
     *        physical cartesian coords by plugging the ParamCoords on the Bezier parameterization of our box.
     * \param[in] ParamCoord - Parametric coordinates of a point.
     * \return Pointer to the cartesian coordinates of a point.
     */
    double *EvalCartesianCoord(double *ParamCoord);
    
    /*!
     * \brief Set the Bernstein polynomial, defined as B_i^n(t) = Binomial(n, i)*t^i*(1-t)^(n-i).
     * \param[in] val_n - Degree of the Bernstein polynomial.
     * \param[in] val_i - Order of the Bernstein polynomial.
     * \param[in] val_t - Value of the parameter where the polynomial is evaluated.
     * \return Value of the Bernstein polynomial.
     */
    double GetBernstein(short val_n, short val_i, double val_t);
    
    /*!
     * \brief Get the binomial coefficient n over i, defined as n!/(m!(n-m)!)
     * \note If the denominator is 0, the value is 1.
     * \param[in] n - Upper coefficient.
     * \param[in] m - Lower coefficient.
     * \return Value of the binomial coefficient n over m.
     */
    unsigned long Binomial(unsigned short n, unsigned short m);
    
    /*!
     * \brief Get the order in the l direction of the FFD FFDBox.
     * \return Order in the l direction of the FFD FFDBox.
     */
    unsigned short GetlOrder(void);
    
    /*!
     * \brief Get the order in the m direction of the FFD FFDBox.
     * \return Order in the m direction of the FFD FFDBox.
     */
    unsigned short GetmOrder(void);
    
    /*!
     * \brief Get the order in the n direction of the FFD FFDBox.
     * \return Order in the n direction of the FFD FFDBox.
     */
    unsigned short GetnOrder(void);
    
    /*!
     * \brief Get the order in the l direction of the FFD FFDBox.
     * \return Order in the l direction of the FFD FFDBox.
     */
    void SetlOrder(unsigned short val_lOrder);
    
    /*!
     * \brief Get the order in the m direction of the FFD FFDBox.
     * \return Order in the m direction of the FFD FFDBox.
     */
    void SetmOrder(unsigned short val_mOrder);
    
    /*!
     * \brief Get the order in the n direction of the FFD FFDBox.
     * \return Order in the n direction of the FFD FFDBox.
     */
    void SetnOrder(unsigned short val_nOrder);
    
    /*!
     * \brief Set, at each vertex, the index of the free form FFDBox that contains the vertex.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iFFDBox - Index of the FFDBox.
     */
    bool GetPointFFD(CGeometry *geometry, CConfig *config, unsigned long iPoint);
    
    /*!
     * \brief Set the zone of the computational domain that is going to be deformed.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iFFDBox - Index of the FFDBox.
     */
    void SetDeformationZone(CGeometry *geometry, CConfig *config, unsigned short iFFDBox);
    
    /*!
     * \brief The "order" derivative of the i-th Bernstein polynomial of degree n, evaluated at t,
     *        is calculated as  (B_i^n(t))^{order}(t) = n*(GetBernstein(n-1, i-1, t)-GetBernstein(n-1, i, t)),
     *        having in account that if i=0, GetBernstein(n-1,-1, t) = 0.
     * \param[in] val_n - Degree of the Bernstein polynomial.
     * \param[in] val_i - Order of the Bernstein polynomial.
     * \param[in] val_t - Value of the parameter where the polynomial is evaluated.
     * \param[in] val_order - Order of the derivative.
     * \return Value of the Derivative of the Bernstein polynomial.
     */
    double GetBernsteinDerivative(short val_n, short val_i, double val_t, short val_order);
    
    /*!
     * \brief The routine computes the gradient of F(u, v, w) = ||X(u, v, w)-(x, y, z)||^2  evaluated at (u, v, w).
     * \param[in] val_coord - Parametric coordiates of the target point.
     * \param[in] xyz - Cartesians coordinates of the point.
     * \param[in] analytical - Compute the analytical gradient.
     * \return Value of the analytical gradient.
     */
    double *GetFFDGradient(double *val_coord, double *xyz);
    
    /*!
     * \brief The routine that computes the Hessian of F(u, v, w) = ||X(u, v, w)-(x, y, z)||^2 evaluated at (u, v, w)
     *        Input: (u, v, w), (x, y, z)
     *        Output: Hessian F (u, v, w).
     * \param[in] uvw - Current value of the parametrics coordinates.
     * \param[in] xyz - Cartesians coordinates of the target point to compose the functional.
     * \param[in] val_Hessian - Value of the hessian.
     */
    void GetFFDHessian(double *uvw, double *xyz, double **val_Hessian);
    
    /*!
     * \brief An auxiliary routine to help us compute the gradient of F(u, v, w) = ||X(u, v, w)-(x, y, z)||^2 =
     *        (Sum_ijk^lmn P1_ijk Bi Bj Bk -x)^2+(Sum_ijk^lmn P2_ijk Bi Bj Bk -y)^2+(Sum_ijk^lmn P3_ijk Bi Bj Bk -z)^2
     *        Input: val_t, val_diff (to identify the index of the Bernstein polynomail we differentiate), the i, j, k , l, m, n
     *        E.G.: val_diff=2 => we differentiate w.r.t. w  (val_diff=0,1, or 2) Output: d [B_i^l*B_j^m *B_k^n] / d val_diff
     *        (val_u, val_v, val_w).
     * \param[in] uvw - __________.
     * \param[in] val_diff - __________.
     * \param[in] ijk - __________.
     * \param[in] lmn - Degree of the FFD box.
     * \return __________.
     */
    double GetDerivative1(double *uvw, unsigned short val_diff, unsigned short *ijk, unsigned short *lmn);
    
    /*!
     * \brief An auxiliary routine to help us compute the gradient of F(u, v, w) = ||X(u, v, w)-(x, y, z)||^2 =
     *        (Sum_ijk^lmn P1_ijk Bi Bj Bk -x)^2+(Sum_ijk^lmn P2_ijk Bi Bj Bk -y)^2+(Sum_ijk^lmn P3_ijk Bi Bj Bk -z)^2
     *        Input: (u, v, w), dim , xyz=(x, y, z), l, m, n E.G.: dim=2 => we use the third coordinate of the control points,
     *        and the z-coordinate of xyz  (0<=dim<=2) Output: 2* ( (Sum_{i, j, k}^l, m, n P_{ijk}[dim] B_i^l[u] B_j^m[v] B_k^n[w]) -
     *        xyz[dim]).
     * \param[in] uvw - __________.
     * \param[in] dim - __________.
     * \param[in] xyz - __________.
     * \param[in] lmn - Degree of the FFD box.
     * \return __________.
     */
    double GetDerivative2(double *uvw, unsigned short dim, double *xyz, unsigned short *lmn);
    
    /*!
     * \brief An auxiliary routine to help us compute the gradient of F(u, v, w) = ||X(u, v, w)-(x, y, z)||^2 =
     *        (Sum_ijk^lmn P1_ijk Bi Bj Bk -x)^2+(Sum_ijk^lmn P2_ijk Bi Bj Bk -y)+(Sum_ijk^lmn P3_ijk Bi Bj Bk -z)
     * \param[in] uvw - Parametric coordiates of the point.
     * \param[in] dim - Value of the coordinate to be differentiate.
     * \param[in] diff_this - Diferentiation with respect this coordinate.
     * \param[in] lmn - Degree of the FFD box.
     * \return Sum_{i, j, k}^{l, m, n} [one of them with -1,
     *        depending on diff_this=0,1 or 2] P_{ijk}[dim] * (B_i^l[u] B_j^m[v] B_k^n[w])--one of them diffrentiated;
     *        which? diff_thiss will tell us ; E.G.: dim=2, diff_this=1 => we use the third coordinate of the control
     *        points, and derivate de v-Bersntein polynomial (use m-1 when summing!!).
     */
    double GetDerivative3(double *uvw, unsigned short dim, unsigned short diff_this,
                          unsigned short *lmn);
    
    /*!
     * \brief An auxiliary routine to help us compute the Hessian of F(u, v, w) = ||X(u, v, w)-(x, y, z)||^2 =
     *        (Sum_ijk^lmn P1_ijk Bi Bj Bk -x)^2+(Sum_ijk^lmn P2_ijk Bi Bj Bk -y)+(Sum_ijk^lmn P3_ijk Bi Bj Bk -z)
     *        Input: val_t, val_diff, val_diff2 (to identify the index of the Bernstein polynomials we differentiate), the i, j, k , l, m, n
     *        E.G.: val_diff=1, val_diff2=2  =>  we differentiate w.r.t. v and w  (val_diff=0,1, or 2)
     *        E.G.: val_diff=0, val_diff2=0 => we differentiate w.r.t. u two times
     *        Output: [d [B_i^l*B_j^m *B_k^n]/d val_diff *d [B_i^l*B_j^m *B_k^n]/d val_diff2] (val_u, val_v, val_w) .
     * \param[in] uvw - __________.
     * \param[in] val_diff - __________.
     * \param[in] val_diff2 - __________.
     * \param[in] ijk - __________.
     * \param[in] lmn - Degree of the FFD box.
     * \return __________.
     */
    double GetDerivative4(double *uvw, unsigned short val_diff, unsigned short val_diff2,
                          unsigned short *ijk, unsigned short *lmn);
    
    /*!
     * \brief An auxiliary routine to help us compute the Hessian of F(u, v, w) = ||X(u, v, w)-(x, y, z)||^2 =
     *        (Sum_ijk^lmn P1_ijk Bi Bj Bk -x)^2+(Sum_ijk^lmn P2_ijk Bi Bj Bk -y)+(Sum_ijk^lmn P3_ijk Bi Bj Bk -z)
     *        Input: (u, v, w), dim , diff_this, diff_this_also, xyz=(x, y, z), l, m, n
     *        Output:
     *        Sum_{i, j, k}^{l, m, n} [two of them with -1, depending on diff_this, diff_this_also=0,1 or 2]
     *        P_{ijk}[dim] * (B_i^l[u] B_j^m[v] B_k^n[w])--one of them diffrentiated; which? diff_thiss will tell us ;
     *        E.G.: dim=2, diff_this=1 => we use the third coordinate of the control points, and derivate de v-Bersntein
     *        polynomial (use m-1 when summing!!).
     * \param[in] uvw - __________.
     * \param[in] dim - __________.
     * \param[in] diff_this - __________.
     * \param[in] diff_this_also - __________.
     * \param[in] lmn - Degree of the FFD box.
     * \return __________.
     */
    double GetDerivative5(double *uvw, unsigned short dim, unsigned short diff_this, unsigned short diff_this_also,
                          unsigned short *lmn);
    
    /*!
     * \brief Euclidean norm of a vector.
     * \param[in] a - _______.
     * \return __________.
     */
    double GetNorm(double *a);
    
    /*!
     * \brief Set the tag that identify a FFDBox.
     * \param[in] val_tag - value of the tag.
     */
    void SetTag(string val_tag);
    
    /*!
     * \brief Get the tag that identify a FFDBox.
     * \return Value of the tag that identigy the FFDBox.
     */
    string GetTag(void);
    
    /*!
     * \brief Set the nested level of the FFDBox.
     * \param[in] val_level - value of the level.
     */
    void SetLevel(unsigned short val_level);
    
    /*!
     * \brief Get the nested level of the FFDBox.
     * \return Value of the nested level of the the FFDBox.
     */
    unsigned short GetLevel(void);
    
    /*!
     * \brief Compute the determinant of a 3 by 3 matrix.
     * \param[in] val_matrix 3 by 3 matrix.
     * \result Determinant of the matrix
     */
    double Determinant_3x3(double A00, double A01, double A02, double A10, double A11,
                           double A12, double A20, double A21, double A22);
    
};

/*!
 * \class CVolumetricMovement
 * \brief Class for moving the volumetric numerical grid.
 * \author F. Palacios, A. Bueno, T. Economon, S. Padron.
 * \version 3.2.9 "eagle"
 */
class CVolumetricMovement : public CGridMovement {
protected:
    
    unsigned short nDim;		/*!< \brief Number of dimensions. */
    unsigned short nVar;		/*!< \brief Number of variables. */
    
    unsigned long nPoint;		/*!< \brief Number of points. */
    unsigned long nPointDomain;		/*!< \brief Number of points in the domain. */
    
    CSysMatrix StiffMatrix; /*!< \brief Matrix to store the point-to-point stiffness. */
    CSysVector LinSysSol;
    CSysVector LinSysRes;
    
public:
    
    /*!
     * \brief Constructor of the class.
     */
    CVolumetricMovement(CGeometry *geometry);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CVolumetricMovement(void);
    
    /*!
     * \brief Update the value of the coordinates after the grid movement.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void UpdateGridCoord(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Update the dual grid after the grid movement (edges and control volumes).
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void UpdateDualGrid(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Update the coarse multigrid levels after the grid movement.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void UpdateMultiGrid(CGeometry **geometry, CConfig *config);
    
    /*!
     * \brief Compute the stiffness matrix for grid deformation using spring analogy.
     * \param[in] geometry - Geometrical definition of the problem.
     * \return Value of the length of the smallest edge of the grid.
     */
    double SetFEAMethodContributions_Elem(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Build the stiffness matrix for a 3-D hexahedron element. The result will be placed in StiffMatrix_Elem.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] StiffMatrix_Elem - Element stiffness matrix to be filled.
     * \param[in] CoordCorners - Index value for Node 1 of the current hexahedron.
     */
    void SetFEA_StiffMatrix3D(CGeometry *geometry, CConfig *config, double **StiffMatrix_Elem, unsigned long PointCorners[8], double CoordCorners[8][3], unsigned short nNodes, double scale);
    
    /*!
     * \brief Build the stiffness matrix for a 3-D hexahedron element. The result will be placed in StiffMatrix_Elem.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] StiffMatrix_Elem - Element stiffness matrix to be filled.
     * \param[in] CoordCorners - Index value for Node 1 of the current hexahedron.
     */
    void SetFEA_StiffMatrix2D(CGeometry *geometry, CConfig *config, double **StiffMatrix_Elem, unsigned long PointCorners[8], double CoordCorners[8][3], unsigned short nNodes, double scale);
    
    /*!
     * \brief Shape functions and derivative of the shape functions
     * \param[in] Xi - Local coordinates.
     * \param[in] Eta - Local coordinates.
     * \param[in] Mu - Local coordinates.
     * \param[in] CoordCorners - Coordiantes of the corners.
     * \param[in] DShapeFunction - Shape function information
     */
    double ShapeFunc_Hexa(double Xi, double Eta, double Zeta, double CoordCorners[8][3], double DShapeFunction[8][4]);
    
    /*!
     * \brief Shape functions and derivative of the shape functions
     * \param[in] Xi - Local coordinates.
     * \param[in] Eta - Local coordinates.
     * \param[in] Mu - Local coordinates.
     * \param[in] CoordCorners - Coordiantes of the corners.
     * \param[in] DShapeFunction - Shape function information
     */
    double ShapeFunc_Tetra(double Xi, double Eta, double Zeta, double CoordCorners[8][3], double DShapeFunction[8][4]);
    
    /*!
     * \brief Shape functions and derivative of the shape functions
     * \param[in] Xi - Local coordinates.
     * \param[in] Eta - Local coordinates.
     * \param[in] Mu - Local coordinates.
     * \param[in] CoordCorners - Coordiantes of the corners.
     * \param[in] DShapeFunction - Shape function information
     */
    double ShapeFunc_Pyram(double Xi, double Eta, double Zeta, double CoordCorners[8][3], double DShapeFunction[8][4]);
    
    /*!
     * \brief Shape functions and derivative of the shape functions
     * \param[in] Xi - Local coordinates.
     * \param[in] Eta - Local coordinates.
     * \param[in] Mu - Local coordinates.
     * \param[in] CoordCorners - Coordiantes of the corners.
     * \param[in] DShapeFunction - Shape function information
     */
    double ShapeFunc_Prism(double Xi, double Eta, double Zeta, double CoordCorners[8][3], double DShapeFunction[8][4]);
    
    /*!
     * \brief Shape functions and derivative of the shape functions
     * \param[in] Xi - Local coordinates.
     * \param[in] Eta - Local coordinates.
     * \param[in] CoordCorners - Coordiantes of the corners.
     * \param[in] DShapeFunction - Shape function information
     */
    double ShapeFunc_Triangle(double Xi, double Eta, double CoordCorners[8][3], double DShapeFunction[8][4]);
    
    /*!
     * \brief Shape functions and derivative of the shape functions
     * \param[in] Xi - Local coordinates.
     * \param[in] Eta - Local coordinates.
     * \param[in] CoordCorners - Coordiantes of the corners.
     * \param[in] DShapeFunction - Shape function information
     */
    double ShapeFunc_Rectangle(double Xi, double Eta, double CoordCorners[8][3], double DShapeFunction[8][4]);
    
    /*!
     * \brief Compute the shape functions for hexahedron
     * \param[in] CoordCorners - coordinates of the cornes of the hexahedron.
     */
    double GetHexa_Volume(double CoordCorners[8][3]);
    
    /*!
     * \brief Compute the shape functions for hexahedron
     * \param[in] CoordCorners - coordinates of the cornes of the hexahedron.
     */
    double GetTetra_Volume(double CoordCorners[8][3]);
    
    /*!
     * \brief Compute the shape functions for hexahedron
     * \param[in] CoordCorners - coordinates of the cornes of the hexahedron.
     */
    double GetPrism_Volume(double CoordCorners[8][3]);
    
    /*!
     * \brief Compute the shape functions for hexahedron
     * \param[in] CoordCorners - coordinates of the cornes of the hexahedron.
     */
    double GetPyram_Volume(double CoordCorners[8][3]);
    
    /*!
     * \brief Compute the shape functions for hexahedron
     * \param[in] CoordCorners - coordinates of the cornes of the hexahedron.
     */
    double GetTriangle_Area(double CoordCorners[8][3]);
    
    /*!
     * \brief Compute the shape functions for hexahedron
     * \param[in] CoordCorners - coordinates of the cornes of the hexahedron.
     */
    double GetRectangle_Area(double CoordCorners[8][3]);
    
    /*!
     * \brief Add the stiffness matrix for a 2-D triangular element to the global stiffness matrix for the entire mesh (node-based).
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] StiffMatrix_Elem - Element stiffness matrix to be filled.
     * \param[in] PointCorners
     * \param[in] nNodes
     */
    void AddFEA_StiffMatrix(CGeometry *geometry, double **StiffMatrix_Elem, unsigned long PointCorners[8], unsigned short nNodes);
    
    /*!
     * \brief Check for negative volumes (all elements) after performing grid deformation.
     * \param[in] geometry - Geometrical definition of the problem.
     */
    double Check_Grid(CGeometry *geometry);
    
    /*!
     * \brief Compute the minimum distance to the nearest deforming surface.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeDeforming_Wall_Distance(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Check the boundary vertex that are going to be moved.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void SetBoundaryDisplacements(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Check the domain points vertex that are going to be moved.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void SetDomainDisplacements(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Unsteady grid movement using rigid mesh rotation.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iZone - Zone number in the mesh.
     * \param[in] iter - Physical time iteration number.
     */
    void Rigid_Rotation(CGeometry *geometry, CConfig *config, unsigned short iZone, unsigned long iter);
    
    /*!
     * \brief Unsteady pitching grid movement using rigid mesh motion.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iZone - Zone number in the mesh.
     * \param[in] iter - Physical time iteration number.
     */
    void Rigid_Pitching(CGeometry *geometry, CConfig *config, unsigned short iZone, unsigned long iter);
    
    /*!
     * \brief Unsteady plunging grid movement using rigid mesh motion.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iZone - Zone number in the mesh.
     * \param[in] iter - Physical time iteration number.
     */
    void Rigid_Plunging(CGeometry *geometry, CConfig *config, unsigned short iZone, unsigned long iter);
    
    /*!
     * \brief Unsteady translational grid movement using rigid mesh motion.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iZone - Zone number in the mesh.
     * \param[in] iter - Physical time iteration number.
     */
    void Rigid_Translation(CGeometry *geometry, CConfig *config, unsigned short iZone, unsigned long iter);
    
    /*!
     * \brief Grid deformation using the spring analogy method.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     * \param[in] UpdateGeo - Update geometry.
     */
    void SetVolume_Deformation(CGeometry *geometry, CConfig *config, bool UpdateGeo);
    
    /*!
     * \brief Compute the determinant of a 3 by 3 matrix.
     * 3 by 3 matrix elements
     * \param[in] A00
     * \param[in] A01
     * \param[in] A02
     * \param[in] A10
     * \param[in] A11
     * \param[in] A12
     * \param[in] A20
     * \param[in] A21
     * \param[in] A22
     * \result Determinant of the matrix
     */
    double Determinant_3x3(double A00, double A01, double A02, double A10, double A11, double A12, double A20, double A21, double A22);
    
};

/*!
 * \class CSurfaceMovement
 * \brief Class for moving the surface numerical grid.
 * \author F. Palacios, T. Economon.
 * \version 3.2.9 "eagle"
 */
class CSurfaceMovement : public CGridMovement {
protected:
    CFreeFormDefBox** FFDBox;	/*!< \brief Definition of the Free Form Deformation Box. */
    unsigned short nFFDBox;	/*!< \brief Number of FFD FFDBoxes. */
    unsigned short nLevel;	/*!< \brief Level of the FFD FFDBoxes (parent/child). */
    bool FFDBoxDefinition;	/*!< \brief If the FFD FFDBox has been defined in the input file. */
    vector<double> GlobalCoordX[MAX_NUMBER_FFD];
    vector<double> GlobalCoordY[MAX_NUMBER_FFD];
    vector<double> GlobalCoordZ[MAX_NUMBER_FFD];
    vector<string> GlobalTag[MAX_NUMBER_FFD];
    vector<unsigned long> GlobalPoint[MAX_NUMBER_FFD];
    
public:
    
    /*!
     * \brief Constructor of the class.
     */
    CSurfaceMovement(void);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CSurfaceMovement(void);
    
    /*!
     * \brief Set a Hicks-Henne deformation bump functions on an airfoil.
     * \param[in] boundary - Geometry of the boundary.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iDV - Index of the design variable.
     * \param[in] ResetDef - Reset the deformation before starting a new one.
     */
    void SetHicksHenne(CGeometry *boundary, CConfig *config, unsigned short iDV, bool ResetDef);
    
    /*!
     * \brief Set a NACA 4 digits airfoil family for airfoil deformation.
     * \param[in] boundary - Geometry of the boundary.
     * \param[in] config - Definition of the particular problem.
     */
    void SetNACA_4Digits(CGeometry *boundary, CConfig *config);
    
    /*!
     * \brief Set a parabolic family for airfoil deformation.
     * \param[in] boundary - Geometry of the boundary.
     * \param[in] config - Definition of the particular problem.
     */
    void SetParabolic(CGeometry *boundary, CConfig *config);
    
    /*!
     * \brief Set a obstacle in a channel.
     * \param[in] boundary - Geometry of the boundary.
     * \param[in] config - Definition of the particular problem.
     */
    void SetAirfoil(CGeometry *boundary, CConfig *config);
    
    /*!
     * \brief Set a rotation for surface movement.
     * \param[in] boundary - Geometry of the boundary.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iDV - Index of the design variable.
     * \param[in] ResetDef - Reset the deformation before starting a new one.
     */
    void SetRotation(CGeometry *boundary, CConfig *config, unsigned short iDV, bool ResetDef);
    
    /*!
     * \brief Set the translational/rotational velocity for a moving wall.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iZone - Zone number in the mesh.
     * \param[in] iter - Physical time iteration number.
     */
    void Moving_Walls(CGeometry *geometry, CConfig *config, unsigned short iZone, unsigned long iter);
    
    /*!
     * \brief Computes the displacement of a translating surface for a dynamic mesh simulation.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iter - Current physical time iteration.
     * \param[in] iZone - Zone number in the mesh.
     */
    void Surface_Translating(CGeometry *geometry, CConfig *config,
                             unsigned long iter, unsigned short iZone);
    
    /*!
     * \brief Computes the displacement of a plunging surface for a dynamic mesh simulation.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iter - Current physical time iteration.
     * \param[in] iZone - Zone number in the mesh.
     */
    void Surface_Plunging(CGeometry *geometry, CConfig *config,
                          unsigned long iter, unsigned short iZone);
    
    /*!
     * \brief Computes the displacement of a pitching surface for a dynamic mesh simulation.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iter - Current physical time iteration.
     * \param[in] iZone - Zone number in the mesh.
     */
    void Surface_Pitching(CGeometry *geometry, CConfig *config,
                          unsigned long iter, unsigned short iZone);
    
    /*!
     * \brief Computes the displacement of a rotating surface for a dynamic mesh simulation.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iter - Current physical time iteration.
     * \param[in] iZone - Zone number in the mesh.
     */
    void Surface_Rotating(CGeometry *geometry, CConfig *config,
                          unsigned long iter, unsigned short iZone);
    
    /*!
     * \brief Unsteady aeroelastic grid movement by deforming the mesh.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     * \param[in] ExtIter - Physical iteration number.
     * \param[in] iMarker - Marker to deform.
     * \param[in] iMarker_Monitoring - Marker we are monitoring.
     * \param[in] displacements - solution of typical section wing model.
     */
    void AeroelasticDeform(CGeometry *geometry, CConfig *config, unsigned long ExtIter, unsigned short iMarker, unsigned short iMarker_Monitoring, double displacements[4]);
    
    /*!
     * \brief Deforms a 3-D flutter/pitching surface during an unsteady simulation.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iter - Current physical time iteration.
     * \param[in] iZone - Zone number in the mesh.
     */
    void SetBoundary_Flutter3D(CGeometry *geometry, CConfig *config,
                               CFreeFormDefBox **FFDBox, unsigned long iter, unsigned short iZone);
    
    /*!
     * \brief Set the collective pitch for a blade surface movement.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    //void SetCollective_Pitch(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Set any surface deformationsbased on an input file.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iZone - Zone number in the mesh.
     * \param[in] iter - Current physical time iteration.
     */
    void SetExternal_Deformation(CGeometry *geometry, CConfig *config, unsigned short iZone, unsigned long iter);
    
    /*!
     * \brief Set a displacement for surface movement.
     * \param[in] boundary - Geometry of the boundary.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iDV - Index of the design variable.
     * \param[in] ResetDef - Reset the deformation before starting a new one.
     */
    void SetTranslation(CGeometry *boundary, CConfig *config, unsigned short iDV, bool ResetDef);
    
    /*!
     * \brief Set a displacement for surface movement.
     * \param[in] boundary - Geometry of the boundary.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iDV - Index of the design variable.
     * \param[in] ResetDef - Reset the deformation before starting a new one.
     */
    void SetScale(CGeometry *boundary, CConfig *config, unsigned short iDV, bool ResetDef);
    
    /*!
     * \brief Copy the boundary coordinates to each vertex.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void CopyBoundary(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Set the surface/boundary deformation.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void SetSurface_Deformation(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Compute the parametric coordinates of a grid point using a point inversion strategy
     *        in the free form FFDBox.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     * \param[in] FFDBox - Array with all the free forms FFDBoxes of the computation.
     */
    void SetParametricCoord(CGeometry *geometry, CConfig *config, CFreeFormDefBox *FFDBox, unsigned short iFFDBox);
    
    /*!
     * \brief Update the parametric coordinates of a grid point using a point inversion strategy
     *        in the free form FFDBox.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     * \param[in] FFDBox - Array with all the free forms FFDBoxes of the computation.
     * \param[in] iFFDBox - _____________________.
     */
    void UpdateParametricCoord(CGeometry *geometry, CConfig *config, CFreeFormDefBox *FFDBox, unsigned short iFFDBox);
    
    /*!
     * \brief Check the intersections of the FFD with the surface
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     * \param[in] FFDBox - Array with all the free forms FFDBoxes of the computation.
     * \param[in] iFFDBox - _____________________.
     */
    void CheckFFDIntersections(CGeometry *geometry, CConfig *config, CFreeFormDefBox *FFDBox, unsigned short iFFDBox);
    
    /*!
     * \brief _____________________.
     * \param[in] geometry - _____________________.
     * \param[in] config - _____________________.
     * \param[in] FFDBoxParent - _____________________.
     * \param[in] FFDBoxChild - _____________________.
     */
    void SetParametricCoordCP(CGeometry *geometry, CConfig *config, CFreeFormDefBox *FFDBoxParent, CFreeFormDefBox *FFDBoxChild);
    
    /*!
     * \brief _____________________.
     * \param[in] geometry - _____________________.
     * \param[in] config - _____________________.
     * \param[in] FFDBoxParent - _____________________.
     * \param[in] FFDBoxChild - _____________________.
     */
    void GetCartesianCoordCP(CGeometry *geometry, CConfig *config, CFreeFormDefBox *FFDBoxParent, CFreeFormDefBox *FFDBoxChild);
    
    /*!
     * \brief Recompute the cartesian coordinates using the control points position.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     * \param[in] FFDBox - Array with all the free forms FFDBoxes of the computation.
     * \param[in] iFFDBox - _____________________.
     */
    void SetCartesianCoord(CGeometry *geometry, CConfig *config, CFreeFormDefBox *FFDBox, unsigned short iFFDBox);
    
    /*!
     * \brief Set the deformation of the Free From box using the control point position.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     * \param[in] FFDBox - Array with all the free forms FFDBoxes of the computation.
     * \param[in] iDV - Index of the design variable.
     * \param[in] ResetDef - Reset the deformation before starting a new one.
     */
    void SetFFDCPChange_2D(CGeometry *geometry, CConfig *config, CFreeFormDefBox *FFDBox, unsigned short iDV, bool ResetDef);
    
    /*!
     * \brief Set the deformation of the Free From box using the control point position.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     * \param[in] FFDBox - Array with all the free forms FFDBoxes of the computation.
     * \param[in] iDV - Index of the design variable.
     * \param[in] ResetDef - Reset the deformation before starting a new one.
     */
    void SetFFDCPChange(CGeometry *geometry, CConfig *config, CFreeFormDefBox *FFDBox, unsigned short iDV, bool ResetDef);
    
    /*!
     * \brief Set a camber deformation of the Free From box using the control point position.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     * \param[in] FFDBox - Array with all the free forms FFDBoxes of the computation.
     * \param[in] iDV - Index of the design variable.
     * \param[in] ResetDef - Reset the deformation before starting a new one.
     */
    void SetFFDCamber_2D(CGeometry *geometry, CConfig *config, CFreeFormDefBox *FFDBox, unsigned short iDV, bool ResetDef);
    
    /*!
     * \brief Set a thickness deformation of the Free From box using the control point position.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     * \param[in] FFDBox - Array with all the free forms FFDBoxes of the computation.
     * \param[in] iDV - Index of the design variable.
     * \param[in] ResetDef - Reset the deformation before starting a new one.
     */
    void SetFFDThickness_2D(CGeometry *geometry, CConfig *config, CFreeFormDefBox *FFDBox, unsigned short iDV, bool ResetDef);
    
    /*!
     * \brief Set a camber deformation of the Free From box using the control point position.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     * \param[in] FFDBox - Array with all the free forms FFDBoxes of the computation.
     * \param[in] iDV - Index of the design variable.
     * \param[in] ResetDef - Reset the deformation before starting a new one.
     */
    void SetFFDCamber(CGeometry *geometry, CConfig *config, CFreeFormDefBox *FFDBox, unsigned short iDV, bool ResetDef);
    
    /*!
     * \brief Set a thickness deformation of the Free From box using the control point position.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     * \param[in] FFDBox - Array with all the free forms FFDBoxes of the computation.
     * \param[in] iDV - Index of the design variable.
     * \param[in] ResetDef - Reset the deformation before starting a new one.
     */
    void SetFFDThickness(CGeometry *geometry, CConfig *config, CFreeFormDefBox *FFDBox, unsigned short iDV, bool ResetDef);
    
    /*!
     * \brief Set a dihedral angle deformation of the Free From box using the control point position.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     * \param[in] FFDBox - Array with all the free forms FFDBoxes of the computation.
     * \param[in] iDV - Index of the design variable.
     * \param[in] ResetDef - Reset the deformation before starting a new one.
     */
    void SetFFDDihedralAngle(CGeometry *geometry, CConfig *config, CFreeFormDefBox *FFDBox, unsigned short iDV, bool ResetDef);
    
    /*!
     * \brief Set a twist angle deformation of the Free From box using the control point position.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     * \param[in] FFDBox - Array with all the free forms FFDBoxes of the computation.
     * \param[in] iDV - Index of the design variable.
     * \param[in] ResetDef - Reset the deformation before starting a new one.
     */
    void SetFFDTwistAngle(CGeometry *geometry, CConfig *config, CFreeFormDefBox *FFDBox, unsigned short iDV, bool ResetDef);
    
    /*!
     * \brief Set a rotation angle deformation of the Free From box using the control point position.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     * \param[in] FFDBox - Array with all the free forms FFDBoxes of the computation.
     * \param[in] iDV - Index of the design variable.
     * \param[in] ResetDef - Reset the deformation before starting a new one.
     */		
    void SetFFDRotation(CGeometry *geometry, CConfig *config, CFreeFormDefBox *FFDBox, unsigned short iDV, bool ResetDef);
    
    /*!
     * \brief Set a rotation angle deformation in a control surface of the Free From box using the control point position.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     * \param[in] FFDBox - Array with all the free forms FFDBoxes of the computation.
     * \param[in] iDV - Index of the design variable.
     * \param[in] ResetDef - Reset the deformation before starting a new one.
     */
    void SetFFDControl_Surface(CGeometry *geometry, CConfig *config, CFreeFormDefBox *FFDBox, unsigned short iDV, bool ResetDef);
    
    /*! 
     * \brief Read the free form information from the grid input file.
     * \note If there is no control point information, and no parametric 
     *       coordinates information, the code will compute that information.
     * \param[in] config - Definition of the particular problem.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] FFDBox - Array with all the free forms FFDBoxes of the computation.
     * \param[in] val_mesh_filename - Name of the grid input file.
     */
    void ReadFFDInfo(CGeometry *geometry, CConfig *config, CFreeFormDefBox **FFDBox, string val_mesh_filename);
    
    /*!
     * \brief Read the free form information from the grid input file.
     * \note If there is no control point information, and no parametric
     *       coordinates information, the code will compute that information.
     * \param[in] config - Definition of the particular problem.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] FFDBox - Array with all the free forms FFDBoxes of the computation.
     */
    void ReadFFDInfo(CGeometry *geometry, CConfig *config, CFreeFormDefBox **FFDBox);
    
    /*!
     * \brief Merge the Free Form information in the SU2 file.
     * \param[in] config - Definition of the particular problem.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] val_mesh_filename - Name of the grid output file.
     */
    void MergeFFDInfo(CGeometry *geometry, CConfig *config);
    
    /*! 
     * \brief Write the Free Form information in the SU2 file.
     * \param[in] config - Definition of the particular problem.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] val_mesh_filename - Name of the grid output file.
     */		
    void WriteFFDInfo(CGeometry *geometry, CConfig *config);
    
    /*! 
     * \brief Get information about if there is a complete FFDBox definition, or it is necessary to 
     *        compute the parametric coordinates.
     * \return <code>TRUE</code> if the input grid file has a complete information; otherwise <code>FALSE</code>.
     */		
    bool GetFFDBoxDefinition(void);
    
    /*! 
     * \brief Obtain the number of FFDBoxes.
     * \return Number of FFD FFDBoxes.
     */		
    unsigned short GetnFFDBox(void);
    
    /*! 
     * \brief Obtain the number of levels.
     * \return Number of FFD levels.
     */		
    unsigned short GetnLevel(void);
    
};





/* Variable_structure.hpp------------------------------------------------------------
 *
 *
 *
 */

/*!
 * \class CVariable
 * \brief Main class for defining the variables.
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CVariable {
protected:
    
    double *Solution,		/*!< \brief Solution of the problem. */
    *Solution_Old;			/*!< \brief Old solution of the problem R-K. */
    bool Non_Physical;			/*!< \brief Non-physical points in the solution (force first order). */
    double *Solution_time_n,	/*!< \brief Solution of the problem at time n for dual-time stepping technique. */
    *Solution_time_n1;			/*!< \brief Solution of the problem at time n-1 for dual-time stepping technique. */
    double **Gradient;		/*!< \brief Gradient of the solution of the problem. */
    double *Limiter;				/*!< \brief Limiter of the solution of the problem. */
    double *Solution_Max;		/*!< \brief Max solution for limiter computation. */
    double *Solution_Min;		/*!< \brief Min solution for limiter computation. */
    double AuxVar;			/*!< \brief Auxiliar variable for gradient computation. */
    double *Grad_AuxVar;	/*!< \brief Gradient of the auxiliar variable. */
    double Delta_Time;	/*!< \brief Time step. */
    double Max_Lambda,	/*!< \brief Maximun eingenvalue. */
    Max_Lambda_Inv,		/*!< \brief Maximun inviscid eingenvalue. */
    Max_Lambda_Visc,	/*!< \brief Maximun viscous eingenvalue. */
    Lambda;				/*!< \brief Value of the eingenvalue. */
    double Sensor;	/*!< \brief Pressure sensor for high order central scheme. */
    double *Undivided_Laplacian;	/*!< \brief Undivided laplacian of the solution. */
    double *Res_TruncError,	/*!< \brief Truncation error for multigrid cycle. */
    *Residual_Old,		/*!< \brief Auxiliar structure for residual smoothing. */
    *Residual_Sum;		/*!< \brief Auxiliar structure for residual smoothing. */
    static unsigned short nDim;		/*!< \brief Number of dimension of the problem. */
    unsigned short nVar;		/*!< \brief Number of variables of the problem,
                                 note that this variable cannnot be static, it is possible to
                                 have different number of nVar in the same problem. */
    unsigned short nPrimVar, nPrimVarGrad;		/*!< \brief Number of variables of the problem,
                                                 note that this variable cannnot be static, it is possible to
                                                 have different number of nVar in the same problem. */
    unsigned short nSecondaryVar, nSecondaryVarGrad;		/*!< \brief Number of variables of the problem,
                                                             note that this variable cannnot be static, it is possible to
                                                             have different number of nVar in the same problem. */
    
public:
    
    /*!
     * \brief Constructor of the class.
     */
    CVariable(void);
    
    /*!
     * \overload
     * \param[in] val_nvar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CVariable(unsigned short val_nvar, CConfig *config);
    
    /*!
     * \overload
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nvar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CVariable(unsigned short val_nDim, unsigned short val_nvar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    virtual ~CVariable(void);
    
    /*!
     * \brief Set the value of the solution.
     * \param[in] val_solution - Solution of the problem.
     */
    void SetSolution(double *val_solution);
    
    /*!
     * \overload
     * \param[in] val_var - Index of the variable.
     * \param[in] val_solution - Value of the solution for the index <i>val_var</i>.
     */
    void SetSolution(unsigned short val_var, double val_solution);
    
    /*!
     * \brief Set the value of the non-physical point.
     * \param[in] val_value - identification of the non-physical point.
     */
    void SetNon_Physical(bool val_value);
    
    /*!
     * \brief Get the value of the non-physical point.
     * \return Value of the Non-physical point.
     */
    double GetNon_Physical(void);
    
    /*!
     * \brief Get the solution.
     * \param[in] val_var - Index of the variable.
     * \return Value of the solution for the index <i>val_var</i>.
     */
    double GetSolution(unsigned short val_var);
    
    /*!
     * \brief Get the old solution of the problem (Runge-Kutta method)
     * \param[in] val_var - Index of the variable.
     * \return Pointer to the old solution vector.
     */
    double GetSolution_Old(unsigned short val_var);
    
    /*!
     * \brief Set the value of the old solution.
     * \param[in] val_solution_old - Pointer to the residual vector.
     */
    void SetSolution_Old(double *val_solution_old);
    
    /*!
     * \overload
     * \param[in] val_var - Index of the variable.
     * \param[in] val_solution_old - Value of the old solution for the index <i>val_var</i>.
     */
    void SetSolution_Old(unsigned short val_var, double val_solution_old);
    
    /*!
     * \brief Set old variables to the value of the current variables.
     */
    void Set_OldSolution(void);
    
    /*!
     * \brief Set variables to the value of the old variables.
     */
    void Set_Solution(void);
    
    /*!
     * \brief Set the variable solution at time n.
     */
    void Set_Solution_time_n(void);
    
    /*!
     * \brief Set the variable solution at time n-1.
     */
    void Set_Solution_time_n1(void);
    
    /*!
     * \brief Set to zero the velocity components of the solution.
     */
    void SetVelSolutionZero(void);
    
    /*!
     * \brief Specify a vector to set the velocity components of the solution.
     * \param[in] val_vector - Pointer to the vector.
     */
    void SetVelSolutionVector(double *val_vector);
    
    /*!
     * \brief Set to zero velocity components of the solution.
     */
    void SetVelSolutionOldZero(void);
    
    /*!
     * \brief Specify a vector to set the velocity components of the old solution.
     * \param[in] val_vector - Pointer to the vector.
     */
    void SetVelSolutionOldVector(double *val_vector);
    
    /*!
     * \brief Set to zero the solution.
     */
    void SetSolutionZero(void);
    
    /*!
     * \brief Set to zero a particular solution.
     */
    void SetSolutionZero(unsigned short val_var);
    
    /*!
     * \brief Add a value to the solution.
     * \param[in] val_var - Number of the variable.
     * \param[in] val_solution - Value that we want to add to the solution.
     */
    void AddSolution(unsigned short val_var, double val_solution);
    
    /*!
     * \brief Add a value to the solution, clipping the values.
     * \param[in] val_var - Index of the variable.
     * \param[in] val_solution - Value of the solution change.
     * \param[in] lowerlimit - Lower value.
     * \param[in] upperlimit - Upper value.
     */
    void AddClippedSolution(unsigned short val_var, double val_solution,
                            double lowerlimit, double upperlimit);
    
    /*!
     * \brief Update the variables using a conservative format.
     * \param[in] val_var - Index of the variable.
     * \param[in] val_solution - Value of the solution change.
     * \param[in] val_density - Value of the density.
     * \param[in] val_density_old - Value of the old density.
     */
    void AddConservativeSolution(unsigned short val_var, double val_solution,
                                 double val_density, double val_density_old, double lowerlimit,
                                 double upperlimit);
    
    /*!
     * \brief Get the solution of the problem.
     * \return Pointer to the solution vector.
     */
    double *GetSolution(void);
    
    /*!
     * \brief Get the old solution of the problem (Runge-Kutta method)
     * \return Pointer to the old solution vector.
     */
    double *GetSolution_Old(void);
    
    /*!
     * \brief Get the solution at time n.
     * \return Pointer to the solution (at time n) vector.
     */
    double *GetSolution_time_n(void);
    
    /*!
     * \brief Get the solution at time n-1.
     * \return Pointer to the solution (at time n-1) vector.
     */
    double *GetSolution_time_n1(void);
    
    /*!
     * \brief Set the value of the old residual.
     * \param[in] val_residual_old - Pointer to the residual vector.
     */
    void SetResidual_Old(double *val_residual_old);
    
    /*!
     * \brief Add a value to the summed residual vector.
     * \param[in] val_residual - Pointer to the residual vector.
     */
    void AddResidual_Sum(double *val_residual);
    
    /*!
     * \brief Set summed residual vector to zero value.
     */
    void SetResidualSumZero(void);
    
    /*!
     * \brief Set the velocity of the truncation error to zero.
     */
    virtual void SetVel_ResTruncError_Zero(unsigned short iSpecies);
    
    /*!
     * \brief Get the value of the summed residual.
     * \return Pointer to the summed residual.
     */
    double *GetResidual_Sum(void);
    
    /*!
     * \brief Get the value of the old residual.
     * \return Pointer to the old residual.
     */
    double *GetResidual_Old(void);
    
    /*!
     * \brief Get the value of the summed residual.
     * \param[in] val_residual - Pointer to the summed residual.
     */
    void GetResidual_Sum(double *val_residual);
    
    /*!
     * \brief Set auxiliar variables, we are looking for the gradient of that variable.
     * \param[in] val_auxvar - Value of the auxiliar variable.
     */
    void SetAuxVar(double val_auxvar);
    
    /*!
     * \brief Get the value of the auxiliary variable.
     * \return Value of the auxiliary variable.
     */
    double GetAuxVar(void);
    
    /*!
     * \brief Set the auxiliary variable gradient to zero value.
     */
    void SetAuxVarGradientZero(void);
    
    /*!
     * \brief Set the value of the auxiliary variable gradient.
     * \param[in] val_dim - Index of the dimension.
     * \param[in] val_gradient - Value of the gradient for the index <i>val_dim</i>.
     */
    void SetAuxVarGradient(unsigned short val_dim, double val_gradient);
    
    /*!
     * \brief Add a value to the auxiliary variable gradient.
     * \param[in] val_dim - Index of the dimension.
     * \param[in] val_value - Value of the gradient to be added for the index <i>val_dim</i>.
     */
    void AddAuxVarGradient(unsigned short val_dim, double val_value);
    
    /*!
     * \brief Subtract a value to the auxiliary variable gradient.
     * \param[in] val_dim - Index of the dimension.
     * \param[in] val_value - Value of the gradient to be subtracted for the index <i>val_dim</i>.
     */
    void SubtractAuxVarGradient(unsigned short val_dim, double val_value);
    
    /*!
     * \brief Get the gradient of the auxiliary variable.
     * \return Value of the gradient of the auxiliary variable.
     */
    double *GetAuxVarGradient(void);
    
    /*!
     * \brief Get the gradient of the auxiliary variable.
     * \param[in] val_dim - Index of the dimension.
     * \return Value of the gradient of the auxiliary variable for the dimension <i>val_dim</i>.
     */
    double GetAuxVarGradient(unsigned short val_dim);
    
    /*!
     * \brief Add a value to the truncation error.
     * \param[in] val_truncation_error - Value that we want to add to the truncation error.
     */
    void AddRes_TruncError(double *val_truncation_error);
    
    /*!
     * \brief Subtract a value to the truncation error.
     * \param[in] val_truncation_error - Value that we want to subtract to the truncation error.
     */
    void SubtractRes_TruncError(double *val_truncation_error);
    
    /*!
     * \brief Set the truncation error to zero.
     */
    void SetRes_TruncErrorZero(void);
    
    /*!
     * \brief Set the truncation error to zero.
     */
    void SetVal_ResTruncError_Zero(unsigned short val_var);
    
    /*!
     * \brief Set the velocity of the truncation error to zero.
     */
    void SetVel_ResTruncError_Zero(void);
    
    /*!
     * \brief Set the velocity of the truncation error to zero.
     */
    void SetEnergy_ResTruncError_Zero(void);
    
    /*!
     * \brief Get the truncation error.
     * \return Pointer to the truncation error.
     */
    double *GetResTruncError(void);
    
    /*!
     * \brief Get the truncation error.
     * \param[in] val_trunc_error - Pointer to the truncation error.
     */
    void GetResTruncError(double *val_trunc_error);
    
    /*!
     * \brief Set the gradient of the solution.
     * \param[in] val_gradient - Gradient of the solution.
     */
    void SetGradient(double **val_gradient);
    
    /*!
     * \overload
     * \param[in] val_var - Index of the variable.
     * \param[in] val_dim - Index of the dimension.
     * \param[in] val_value - Value of the gradient.
     */
    void SetGradient(unsigned short val_var, unsigned short val_dim, double val_value);
    
    /*!
     * \brief Set to zero the gradient of the solution.
     */
    void SetGradientZero(void);
    
    /*!
     * \brief Add <i>val_value</i> to the solution gradient.
     * \param[in] val_var - Index of the variable.
     * \param[in] val_dim - Index of the dimension.
     * \param[in] val_value - Value to add to the solution gradient.
     */
    void AddGradient(unsigned short val_var, unsigned short val_dim, double val_value);
    
    /*!
     * \brief Subtract <i>val_value</i> to the solution gradient.
     * \param[in] val_var - Index of the variable.
     * \param[in] val_dim - Index of the dimension.
     * \param[in] val_value - Value to subtract to the solution gradient.
     */
    void SubtractGradient(unsigned short val_var, unsigned short val_dim, double val_value);
    
    /*!
     * \brief Get the value of the solution gradient.
     * \return Value of the gradient solution.
     */
    double **GetGradient(void);
    
    /*!
     * \brief Get the value of the solution gradient.
     * \param[in] val_var - Index of the variable.
     * \param[in] val_dim - Index of the dimension.
     * \return Value of the solution gradient.
     */
    double GetGradient(unsigned short val_var, unsigned short val_dim);
    
    /*!
     * \brief Set the value of the limiter.
     * \param[in] val_var - Index of the variable.
     * \param[in] val_limiter - Value of the limiter for the index <i>val_var</i>.
     */
    void SetLimiter(unsigned short val_var, double val_limiter);
    
    /*!
     * \brief Set the value of the limiter.
     * \param[in] val_var - Index of the variable.
     * \param[in] val_limiter - Value of the limiter for the index <i>val_var</i>.
     */
    virtual void SetLimiterPrimitive(unsigned short val_species, unsigned short val_var, double val_limiter);
    
    /*!
     * \brief Set the value of the limiter.
     * \param[in] val_species - Value of the limiter for the index <i>val_var</i>.
     * \param[in] val_var - Index of the variable.
     */
    virtual double GetLimiterPrimitive(unsigned short val_species, unsigned short val_var);
    
    /*!
     * \brief Set the value of the max solution.
     * \param[in] val_var - Index of the variable.
     * \param[in] val_solution - Value of the max solution for the index <i>val_var</i>.
     */
    void SetSolution_Max(unsigned short val_var, double val_solution);
    
    /*!
     * \brief Set the value of the min solution.
     * \param[in] val_var - Index of the variable.
     * \param[in] val_solution - Value of the min solution for the index <i>val_var</i>.
     */
    void SetSolution_Min(unsigned short val_var, double val_solution);
    
    /*!
     * \brief Get the value of the slope limiter.
     * \return Pointer to the limiters vector.
     */
    double *GetLimiter(void);
    
    /*!
     * \brief Get the value of the slope limiter.
     * \param[in] val_var - Index of the variable.
     * \return Value of the limiter vector for the variable <i>val_var</i>.
     */
    double GetLimiter(unsigned short val_var);
    
    /*!
     * \brief Get the value of the min solution.
     * \param[in] val_var - Index of the variable.
     * \return Value of the min solution for the variable <i>val_var</i>.
     */
    double GetSolution_Max(unsigned short val_var);
    
    /*!
     * \brief Get the value of the min solution.
     * \param[in] val_var - Index of the variable.
     * \return Value of the min solution for the variable <i>val_var</i>.
     */
    double GetSolution_Min(unsigned short val_var);
    
    /*!
     * \brief Get the value of the preconditioner Beta.
     * \return Value of the low Mach preconditioner variable Beta
     */
    virtual double GetPreconditioner_Beta();
    
    /*!
     * \brief Set the value of the preconditioner Beta.
     * \param[in] val_Beta - Value of the low Mach preconditioner variable Beta
     */
    virtual void SetPreconditioner_Beta(double val_Beta);
    
    /*!
     * \brief Get the value of the wind gust
     * \return Value of the wind gust
     */
    virtual double* GetWindGust();
    
    /*!
     * \brief Set the value of the wind gust
     * \param[in] val_WindGust - Value of the wind gust
     */
    virtual void SetWindGust(double* val_WindGust);
    
    /*!
     * \brief Get the value of the derivatives of the wind gust
     * \return Value of the derivatives of the wind gust
     */
    virtual double* GetWindGustDer();
    
    /*!
     * \brief Set the value of the derivatives of the wind gust
     * \param[in] val_WindGust - Value of the derivatives of the wind gust
     */
    virtual void SetWindGustDer(double* val_WindGust);
    
    /*!
     * \brief Set the value of the time step.
     * \param[in] val_delta_time - Value of the time step.
     */
    void SetDelta_Time(double val_delta_time);
    
    /*!
     * \brief Set the value of the time step.
     * \param[in] val_delta_time - Value of the time step.
     * \param[in] iSpecies - Index of the Species .
     */
    virtual void SetDelta_Time(double val_delta_time, unsigned short iSpecies);
    
    /*!
     * \brief Get the value of the time step.
     * \return Value of the time step.
     */
    double GetDelta_Time(void);
    
    /*!
     * \brief Get the value of the time step.
     * \param[in] iSpecies - Index of the Species
     * \return Value of the time step.
     */
    virtual double GetDelta_Time(unsigned short iSpecies);
    
    /*!
     * \brief Set the value of the maximum eigenvalue.
     * \param[in] val_max_lambda - Value of the maximum eigenvalue.
     */
    void SetMax_Lambda(double val_max_lambda);
    
    /*!
     * \brief Set the value of the maximum eigenvalue for the inviscid terms of the PDE.
     * \param[in] val_max_lambda - Value of the maximum eigenvalue for the inviscid terms of the PDE.
     */
    void SetMax_Lambda_Inv(double val_max_lambda);
    
    /*!
     * \brief Set the value of the maximum eigenvalue for the inviscid terms of the PDE.
     * \param[in] val_max_lambda - Value of the maximum eigenvalue for the inviscid terms of the PDE.
     * \param[in] val_species - Value of the species index to set the maximum eigenvalue.
     */
    virtual void SetMax_Lambda_Inv(double val_max_lambda, unsigned short val_species);
    
    /*!
     * \brief Set the value of the maximum eigenvalue for the viscous terms of the PDE.
     * \param[in] val_max_lambda - Value of the maximum eigenvalue for the viscous terms of the PDE.
     */
    void SetMax_Lambda_Visc(double val_max_lambda);
    
    /*!
     * \brief Set the value of the maximum eigenvalue for the viscous terms of the PDE.
     * \param[in] val_max_lambda - Value of the maximum eigenvalue for the viscous terms of the PDE.
     * \param[in] val_species - Index of the species to set the maximum eigenvalue of the viscous terms.
     */
    virtual void SetMax_Lambda_Visc(double val_max_lambda, unsigned short val_species);
    
    /*!
     * \brief Add a value to the maximum eigenvalue.
     * \param[in] val_max_lambda - Value of the maximum eigenvalue.
     */
    void AddMax_Lambda(double val_max_lambda);
    
    /*!
     * \brief Add a value to the maximum eigenvalue for the inviscid terms of the PDE.
     * \param[in] val_max_lambda - Value of the maximum eigenvalue for the inviscid terms of the PDE.
     */
    void AddMax_Lambda_Inv(double val_max_lambda);
    
    /*!
     * \brief Add a value to the maximum eigenvalue for the viscous terms of the PDE.
     * \param[in] val_max_lambda - Value of the maximum eigenvalue for the viscous terms of the PDE.
     */
    void AddMax_Lambda_Visc(double val_max_lambda);
    
    /*!
     * \brief Get the value of the maximum eigenvalue.
     * \return the value of the maximum eigenvalue.
     */
    double GetMax_Lambda(void);
    
    /*!
     * \brief Get the value of the maximum eigenvalue for the inviscid terms of the PDE.
     * \return the value of the maximum eigenvalue for the inviscid terms of the PDE.
     */
    double GetMax_Lambda_Inv(void);
    
    /*!
     * \brief Get the value of the maximum eigenvalue for the viscous terms of the PDE.
     * \return the value of the maximum eigenvalue for the viscous terms of the PDE.
     */
    double GetMax_Lambda_Visc(void);
    
    /*!
     * \brief Set the value of the spectral radius.
     * \param[in] val_lambda - Value of the spectral radius.
     */
    void SetLambda(double val_lambda);
    
    /*!
     * \brief Set the value of the spectral radius.
     * \param[in] val_lambda - Value of the spectral radius.
     * \param[in] val_iSpecies -Index of species
     */
    virtual void SetLambda(double val_lambda, unsigned short val_iSpecies);
    
    /*!
     * \brief Add the value of the spectral radius.
     * \param[in] val_lambda - Value of the spectral radius.
     */
    void AddLambda(double val_lambda);
    
    /*!
     * \brief Add the value of the spectral radius.
     * \param[in] val_iSpecies -Index of species
     * \param[in] val_lambda - Value of the spectral radius.
     */
    virtual void AddLambda(double val_lambda, unsigned short val_iSpecies);
    
    /*!
     * \brief Get the value of the spectral radius.
     * \return Value of the spectral radius.
     */
    double GetLambda(void);
    
    /*!
     * \brief Get the value of the spectral radius.
     * \param[in] val_iSpecies -Index of species
     * \return Value of the spectral radius.
     */
    virtual double GetLambda(unsigned short val_iSpecies);
    
    /*!
     * \brief Set pressure sensor.
     * \param[in] val_sensor - Value of the pressure sensor.
     */
    void SetSensor(double val_sensor);
    
    /*!
     * \brief Set pressure sensor.
     * \param[in] val_sensor - Value of the pressure sensor.
     * \param[in] val_sensor - Index of the Species.
     */
    virtual void SetSensor(double val_sensor, unsigned short iSpecies);
    
    /*!
     * \brief Get the pressure sensor.
     * \return Value of the pressure sensor.
     */
    double GetSensor(void);
    
    /*!
     * \brief Get the pressure sensor.
     * \param[in] iSpecies - index of species
     * \return Value of the pressure sensor.
     */
    virtual double GetSensor(unsigned short iSpecies);
    
    /*!
     * \brief Set the value of the undivided laplacian of the solution.
     * \param[in] val_var - Index of the variable.
     * \param[in] val_undivided_laplacian - Value of the undivided solution for the index <i>val_var</i>.
     */
    void SetUndivided_Laplacian(unsigned short val_var, double val_undivided_laplacian);
    
    /*!
     * \brief Add the value of the undivided laplacian of the solution.
     * \param[in] val_und_lapl - Value of the undivided solution.
     */
    void AddUnd_Lapl(double *val_und_lapl);
    
    /*!
     * \brief Subtract the value of the undivided laplacian of the solution.
     * \param[in] val_und_lapl - Value of the undivided solution.
     */
    void SubtractUnd_Lapl(double *val_und_lapl);
    
    /*!
     * \brief Subtract the value of the undivided laplacian of the solution.
     * \param[in] val_var - Variable of the undivided laplacian.
     * \param[in] val_und_lapl - Value of the undivided solution.
     */
    void SubtractUnd_Lapl(unsigned short val_var, double val_und_lapl);
    
    /*!
     * \brief Set the undivided laplacian of the solution to zero.
     */
    void SetUnd_LaplZero(void);
    
    /*!
     * \brief Set a value to the undivided laplacian.
     * \param[in] val_var - Variable of the undivided laplacian.
     * \param[in] val_und_lapl - Value of the undivided laplacian.
     */
    void SetUnd_Lapl(unsigned short val_var, double val_und_lapl);
    
    /*!
     * \brief Get the undivided laplacian of the solution.
     * \return Pointer to the undivided laplacian vector.
     */
    double *GetUndivided_Laplacian(void);
    
    /*!
     * \brief Get the undivided laplacian of the solution.
     * \param[in] val_var - Variable of the undivided laplacian.
     * \return Value of the undivided laplacian vector.
     */
    double GetUndivided_Laplacian(unsigned short val_var);
    
    /*!
     * \brief A virtual member.
     * \return Value of the flow density.
     */
    virtual double GetDensity(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the flow density.
     */
    virtual double GetDensity(unsigned short val_iSpecies);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_Species - Index of species s.
     * \return Value of the mass fraction of species s.
     */
    virtual double GetMassFraction(unsigned short val_Species);
    
    /*!
     * \brief A virtual member.
     * \return Value of the flow energy.
     */
    virtual double GetEnergy(void);
    
    /*!
     * \brief A virtual member.
     * \return Pointer to the force projection vector.
     */
    virtual double *GetForceProj_Vector(void);
    
    /*!
     * \brief A virtual member.
     * \return Pointer to the objective function source.
     */
    virtual double *GetObjFuncSource(void);
    
    /*!
     * \brief A virtual member.
     * \return Pointer to the internal boundary vector.
     */
    virtual double *GetIntBoundary_Jump(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the eddy viscosity.
     */
    virtual double GetEddyViscosity(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the eddy viscosity.
     */
    virtual double GetEddyViscosityInc(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the flow enthalpy.
     */
    virtual double GetEnthalpy(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the flow pressure.
     */
    virtual double GetPressure(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the flow pressure.
     */
    virtual double GetPressureInc(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the linearized pressure.
     */
    virtual double GetDeltaPressure(void);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_vector - Direction of projection.
     * \return Value of the projected velocity.
     */
    virtual double GetProjVel(double *val_vector);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_vector - Direction of projection.
     * \param[in] val_species - Index of the desired species.
     * \return Value of the projected velocity.
     */
    virtual double GetProjVel(double *val_vector, unsigned short val_species);
    
    /*!
     * \brief A virtual member.
     * \return Value of the sound speed.
     */
    virtual double GetSoundSpeed(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the density for the incompressible flow.
     */
    virtual double GetDensityInc(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the levelset for the freesurface flows.
     */
    virtual double GetLevelSet(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the distance for the freesurface flows.
     */
    virtual double GetDistance(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the beta for the incompressible flow.
     */
    virtual double GetBetaInc2(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the temperature.
     */
    virtual double GetTemperature(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the vibrational-electronic temperature.
     */
    virtual double GetTemperature_ve(void);
    
    /*!
     * \brief A virtual member -- Get the mixture specific heat at constant volume (trans.-rot.).
     * \return \f$\rho C^{t-r}_{v} \f$
     */
    virtual double GetRhoCv_tr(void);
    
    /*!
     * \brief A virtual member -- Get the mixture specific heat at constant volume (vib.-el.).
     * \return \f$\rho C^{v-e}_{v} \f$
     */
    virtual double GetRhoCv_ve(void);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_dim - Index of the dimension.
     * \return Value of the velocity for the dimension <i>val_dim</i>.
     */
    virtual double GetVelocity(unsigned short val_dim);
    
    /*!
     * \brief A virtual member.
     * \return Norm 2 of the velocity vector.
     */
    virtual double GetVelocity2(void);
    
    /*!
     * \brief A virtual member.
     * \return Norm 2 of the velocity vector of Fluid val_species.
     */
    virtual double GetVelocity2(unsigned short val_species);
    
    /*!
     * \brief A virtual member.
     * \return The laminar viscosity of the flow.
     */
    virtual double GetLaminarViscosity(void);
    
    /*!
     * \brief A virtual member.
     * \return The laminar viscosity of the incompressible flow.
     */
    virtual double GetLaminarViscosityInc(void);
    
    /*!
     * \brief A virtual member.
     * \return The laminar viscosity of the flow.
     */
    virtual double GetLaminarViscosity(unsigned short iSpecies);
    
    /*!
     * \brief A virtual member.
     * \return Value of the species diffusion coefficient.
     */
    virtual double* GetDiffusionCoeff(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the thermal conductivity (translational/rotational)
     */
    virtual double GetThermalConductivity(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the specific heat at constant P
     */
    virtual double GetSpecificHeatCp(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the thermal conductivity (vibrational)
     */
    virtual double GetThermalConductivity_ve(void);
    
    /*!
     * \brief A virtual member.
     * \return Sets separation intermittency
     */
    virtual void SetGammaSep(double gamma_sep);
    
    /*!
     * \brief A virtual member.
     * \return Sets separation intermittency
     */
    virtual void SetGammaEff(void);
    
    /*!
     * \brief A virtual member.
     * \return Returns intermittency
     */
    virtual double GetIntermittency();
    
    /*!
     * \brief A virtual member.
     * \param[in] val_dim - Index of the dimension.
     * \return Value of the vorticity.
     */
    virtual double *GetVorticity(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the rate of strain magnitude.
     */
    virtual double GetStrainMag(void);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_ForceProj_Vector - Pointer to the force projection vector.
     */
    virtual void SetForceProj_Vector(double *val_ForceProj_Vector);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_SetObjFuncSource - Pointer to the objective function source.
     */
    virtual void SetObjFuncSource(double *val_SetObjFuncSource);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_IntBoundary_Jump - Pointer to the interior boundary jump.
     */
    virtual void SetIntBoundary_Jump(double *val_IntBoundary_Jump);
    
    /*!
     * \brief A virtual member.
     * \param[in] eddy_visc - Value of the eddy viscosity.
     */
    virtual void SetEddyViscosity(double eddy_visc);
    
    /*!
     * \brief A virtual member.
     * \param[in] eddy_visc - Value of the eddy viscosity.
     */
    virtual void SetEddyViscosityInc(double eddy_visc);
    
    /*!
     * \brief A virtual member.
     */
    virtual void SetEnthalpy(void);
    
    /*!
     * \brief A virtual member.
     */
    virtual bool SetPrimVar_Compressible(CConfig *config);
    
    /*!
     * \brief A virtual member.
     */
    virtual bool SetPrimVar_Compressible(CFluidModel *FluidModel);
    
    /*!
     * \brief A virtual member.
     */
    virtual void SetSecondaryVar_Compressible(CFluidModel *FluidModel);
    
    /*!
     * \brief A virtual member.
     */
    virtual bool Cons2PrimVar(CConfig *config, double *U, double *V,
                              double *dPdU, double *dTdU,
                              double *dTvedU);
    /*!
     * \brief A virtual member.
     */
    virtual void Prim2ConsVar(CConfig *config, double *V, double *U);
    
    /*!
     * \brief A virtual member.
     */
    virtual bool SetPrimVar_Compressible(double SharpEdge_Distance, bool check, CConfig *config);
    
    /*!
     * \brief A virtual member.
     */
    virtual bool SetPrimVar_Incompressible(double SharpEdge_Distance, bool check, CConfig *config);
    
    /*!
     * \brief A virtual member.
     */
    virtual bool SetPrimVar_FreeSurface(double SharpEdge_Distance, bool check, CConfig *config);
    
    /*!
     * \brief A virtual member.
     */
    virtual bool SetPrimVar_Compressible(double eddy_visc, double turb_ke, CConfig *config);
    
    /*!
     * \brief A virtual member.
     */
    virtual bool SetPrimVar_Compressible(double eddy_visc, double turb_ke, CFluidModel *FluidModel);
    
    /*!
     * \brief A virtual member.
     */
    virtual bool SetPrimVar_Incompressible(double Density_Inf, CConfig *config);
    
    /*!
     * \brief A virtual member.
     */
    virtual bool SetPrimVar_FreeSurface(CConfig *config);
    
    /*!
     * \brief A virtual member.
     */
    virtual bool SetPrimVar_Incompressible(double Density_Inf, double Viscosity_Inf, double eddy_visc, double turb_ke, CConfig *config);
    
    /*!
     * \brief A virtual member.
     */
    virtual bool SetPrimVar_FreeSurface(double eddy_visc, double turb_ke, CConfig *config);
    
    /*!
     * \brief A virtual member.
     */
    virtual double GetPrimitive(unsigned short val_var);
    
    /*!
     * \brief A virtual member.
     */
    virtual void SetPrimitive(unsigned short val_var, double val_prim);
    
    /*!
     * \brief A virtual member.
     */
    virtual void SetPrimitive(double *val_prim);
    
    /*!
     * \brief A virtual member.
     */
    virtual double *GetPrimitive(void);
    
    /*!
     * \brief A virtual member.
     */
    virtual double GetSecondary(unsigned short val_var);
    
    /*!
     * \brief A virtual member.
     */
    virtual void SetSecondary(unsigned short val_var, double val_secondary);
    
    /*!
     * \brief A virtual member.
     */
    virtual void SetSecondary(double *val_secondary);
    
    /*!
     * \brief A virtual member.
     */
    virtual void SetdPdrho_e(double dPdrho_e);
    
    /*!
   	 * \brief A virtual member.
   	 */
    virtual void SetdPde_rho(double dPde_rho);
    
    /*!
     * \brief A virtual member.
     */
    virtual void SetdTdrho_e(double dTdrho_e);
    
    /*!
     * \brief A virtual member.
     */
    virtual void SetdTde_rho(double dTde_rho);
    
    /*!
   	 * \brief A virtual member.
   	 */
    virtual void Setdmudrho_T(double dmudrho_T);
    
    /*!
     * \brief A virtual member.
     */
    virtual void SetdmudT_rho(double dmudT_rho);
    
    /*!
     * \brief A virtual member.
     */
    virtual void Setdktdrho_T(double dktdrho_T);
    
    /*!
     * \brief A virtual member.
     */
    virtual void SetdktdT_rho(double dktdT_rho);
    
    /*!
     * \brief A virtual member.
     */
    virtual double *GetSecondary(void);
    
    /*!
     * \brief A virtual member.
     */
    virtual void SetDensityInc(double val_density);
    
    /*!
     * \brief A virtual member.
     */
    virtual void SetPressureInc(void);
    
    /*!
     * \brief A virtual member.
     */
    virtual void SetVelocityInc(void);
    
    /*!
     * \brief A virtual member.
     */
    virtual void SetBetaInc2(double val_betainc2);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_phi - Value of the adjoint velocity.
     */
    virtual void SetPhi_Old(double *val_phi);
    
    /*!
     * \brief A virtual member.
     * \param[in] Gamma - Ratio of Specific heats
     */
    virtual bool SetPressure(double Gamma);
    
    /*!
     * \brief A virtual member.
     * \param[in] config
     */
    virtual bool SetPressure(CConfig *config);
    
    /*!
     * \brief A virtual member.
     */
    virtual bool SetPressure(double Gamma, double turb_ke);
    
    /*!
     * \brief A virtual member.
     */
    virtual void SetPressure(void);
    
    /*!
     * \brief Calculates vib.-el. energy per mass, \f$e^{vib-el}_s\f$, for input species (not including KE)
     */
    virtual double CalcEve(double *V, CConfig *config, unsigned short val_Species);
    
    /*!
     * \brief Calculates enthalpy per mass, \f$h_s\f$, for input species (not including KE)
     */
    virtual double CalcHs(double *V, CConfig *config, unsigned short val_Species);
    
    /*!
     * \brief Calculates enthalpy per mass, \f$Cv_s\f$, for input species (not including KE)
     */
    virtual double CalcCvve(double val_Tve, CConfig *config, unsigned short val_Species);
    
    /*!
     * \brief A virtual member.
     * \param[in] config - Configuration settings
     */
    virtual void CalcdPdU(double *V, CConfig *config, double *dPdU);
    
    /*!
     * \brief Set partial derivative of temperature w.r.t. density \f$\frac{\partial P}{\partial \rho_s}\f$
     */
    virtual void CalcdTdU(double *V, CConfig *config, double *dTdU);
    
    /*!
     * \brief Set partial derivative of temperature w.r.t. density \f$\frac{\partial P}{\partial \rho_s}\f$
     */
    virtual void CalcdTvedU(double *V, CConfig *config, double *dTdU);
    
    /*!
     * \brief A virtual member.
     */
    virtual double *GetdPdU(void);
    
    /*!
     * \brief A virtual member.
     */
    virtual double *GetdTdU(void);
    
    /*!
     * \brief A virtual member.
     */
    virtual double *GetdTvedU(void);
    
    /*!
     * \brief A virtual member.
     */
    virtual bool SetDensity(void);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_velocity - Value of the velocity.
     * \param[in] Gamma - Ratio of Specific heats
     */
    virtual void SetDeltaPressure(double *val_velocity, double Gamma);
    
    /*!
     * \brief A virtual member.
     * \param[in] Gamma - Ratio of specific heats.
     */
    virtual bool SetSoundSpeed(double Gamma);
    
    /*!
     * \brief A virtual member.
     * \param[in] config - Configuration parameters.
     */
    virtual bool SetSoundSpeed(CConfig *config);
    
    /*!
     * \brief A virtual member.
     */
    virtual bool SetSoundSpeed(void);
    
    /*!
     * \brief A virtual member.
     * \param[in] Gas_Constant - Value of the Gas Constant
     */
    virtual bool SetTemperature(double Gas_Constant);
    
    /*!
     * \brief Sets the vibrational electronic temperature of the flow.
     * \return Value of the temperature of the flow.
     */
    virtual bool SetTemperature_ve(double val_Tve);
    
    /*!
     * \brief A virtual member.
     * \param[in] config - Configuration parameters.
     */
    virtual bool SetTemperature(CConfig *config);
    
    /*!
     * \brief A virtual member.
     * \param[in] config - Configuration parameters.
     */
    virtual void SetPrimitive(CConfig *config);
    
    /*!
     * \brief A virtual member.
     * \param[in] config - Configuration parameters.
     */
    virtual void SetPrimitive(CConfig *config, double *Coord);
    
    /*!
     * \brief A virtual member.
     * \param[in] Temperature_Wall - Value of the Temperature at the wall
     */
    virtual void SetWallTemperature(double Temperature_Wall);
    
    /*!
     * \brief A virtual member.
     * \param[in] Temperature_Wall - Value of the Temperature at the wall
     */
    virtual void SetWallTemperature(double* Temperature_Wall);
    
    /*!
     * \brief Set the thermal coefficient.
     * \param[in] config - Configuration parameters.
     */
    virtual void SetThermalCoeff(CConfig *config);
    
    /*!
     * \brief A virtual member.
     */
    virtual void SetVelocity(void);
    
    /*!
     * \brief A virtual member.
     */
    virtual void SetStress(unsigned short iVar, unsigned short jVar, double val_stress);
    
    /*!
     * \brief A virtual member.
     
     */
    virtual double **GetStress(void);
    
    /*!
     * \brief A virtual member.
     */
    virtual void SetVonMises_Stress(double val_stress);
    
    /*!
     * \brief A virtual member.
     
     */
    virtual double GetVonMises_Stress(void);
    
    /*!
     * \brief A virtual member.
     */
    virtual void SetFlow_Pressure(double val_pressure);
    
    /*!
     * \brief A virtual member.
     
     */
    virtual double GetFlow_Pressure(void);
    
    /*!
     * \brief A virtual member.
     */
    virtual void SetVelocity2(void);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_velocity - Pointer to the velocity.
     */
    virtual void SetVelocity_Old(double *val_velocity);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_velocity - Pointer to the velocity.
     */
    virtual void SetVelocityInc_Old(double *val_velocity);
    
    /*!
     * \brief A virtual member.
     * \param[in] laminarViscosity
     */
    virtual void SetLaminarViscosity(double laminarViscosity);
    
    /*!
     * \brief A virtual member.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void SetLaminarViscosity(CConfig *config);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_laminar_viscosity_inc - Value of the laminar viscosity (incompressible flows).
     */
    virtual void SetLaminarViscosityInc(double val_laminar_viscosity_inc);
    
    /*!
     * \brief A virtual member.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void SetThermalConductivity(double thermalConductivity);
    
    /*!
     * \brief A virtual member.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void SetThermalConductivity(CConfig *config);
    
    /*!
     * \brief A virtual member.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void SetSpecificHeatCp(double Cp);
    
    /*!
     * \brief A virtual member.
     */
    virtual bool SetVorticity(bool val_limiter);
    
    /*!
     * \brief A virtual member.
     */
    virtual bool SetStrainMag(bool val_limiter);
    
    /*!
     * \brief A virtual member.
     */
    virtual void SetVelSolutionOldDVector(void);
    
    /*!
     * \brief A virtual member.
     */
    virtual void SetVelSolutionDVector(void);
    
    /*!
     * \brief A virtual member.
     */
    virtual void SetGradient_PrimitiveZero(unsigned short val_primvar);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_var - Index of the variable.
     * \param[in] val_dim - Index of the dimension.
     * \param[in] val_value - Value to add to the gradient of the primitive variables.
     */
    virtual void AddGradient_Primitive(unsigned short val_var, unsigned short val_dim, double val_value);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_var - Index of the variable.
     * \param[in] val_dim - Index of the dimension.
     * \param[in] val_value - Value to subtract to the gradient of the primitive variables.
     */
    virtual void SubtractGradient_Primitive(unsigned short val_var, unsigned short val_dim, double val_value);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_var - Index of the variable.
     * \param[in] val_dim - Index of the dimension.
     * \return Value of the primitive variables gradient.
     */
    virtual double GetGradient_Primitive(unsigned short val_var, unsigned short val_dim);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_var - Index of the variable.
     * \return Value of the primitive variables gradient.
     */
    virtual double GetLimiter_Primitive(unsigned short val_var);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_var - Index of the variable.
     * \param[in] val_dim - Index of the dimension.
     * \param[in] val_value - Value of the gradient.
     */
    virtual void SetGradient_Primitive(unsigned short val_var, unsigned short val_dim, double val_value);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_var - Index of the variable.
     * \param[in] val_value - Value of the gradient.
     */
    virtual void SetLimiter_Primitive(unsigned short val_var, double val_value);
    
    /*!
     * \brief A virtual member.
     * \return Value of the primitive variables gradient.
     */
    virtual double **GetGradient_Primitive(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the primitive variables gradient.
     */
    virtual double *GetLimiter_Primitive(void);
    
    /*!
     * \brief A virtual member.
     */
    virtual void SetGradient_SecondaryZero(unsigned short val_secondaryvar);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_var - Index of the variable.
     * \param[in] val_dim - Index of the dimension.
     * \param[in] val_value - Value to add to the gradient of the Secondary variables.
     */
    virtual void AddGradient_Secondary(unsigned short val_var, unsigned short val_dim, double val_value);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_var - Index of the variable.
     * \param[in] val_dim - Index of the dimension.
     * \param[in] val_value - Value to subtract to the gradient of the Secondary variables.
     */
    virtual void SubtractGradient_Secondary(unsigned short val_var, unsigned short val_dim, double val_value);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_var - Index of the variable.
     * \param[in] val_dim - Index of the dimension.
     * \return Value of the Secondary variables gradient.
     */
    virtual double GetGradient_Secondary(unsigned short val_var, unsigned short val_dim);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_var - Index of the variable.
     * \return Value of the Secondary variables gradient.
     */
    virtual double GetLimiter_Secondary(unsigned short val_var);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_var - Index of the variable.
     * \param[in] val_dim - Index of the dimension.
     * \param[in] val_value - Value of the gradient.
     */
    virtual void SetGradient_Secondary(unsigned short val_var, unsigned short val_dim, double val_value);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_var - Index of the variable.
     * \param[in] val_value - Value of the gradient.
     */
    virtual void SetLimiter_Secondary(unsigned short val_var, double val_value);
    
    /*!
     * \brief A virtual member.
     * \return Value of the Secondary variables gradient.
     */
    virtual double **GetGradient_Secondary(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the Secondary variables gradient.
     */
    virtual double *GetLimiter_Secondary(void);
    
    /*!
     * \brief Set the blending function for the blending of k-w and k-eps.
     * \param[in] val_viscosity - Value of the vicosity.
     * \param[in] val_density - Value of the density.
     * \param[in] val_dist - Value of the distance to the wall.
     */
    virtual void SetBlendingFunc(double val_viscosity, double val_dist, double val_density);
    
    /*!
     * \brief Get the first blending function of the SST model.
     */
    virtual double GetF1blending(void);
    
    /*!
     * \brief Get the second blending function of the SST model.
     */
    virtual double GetF2blending(void);
    
    /*!
     * \brief Get the value of the cross diffusion of tke and omega.
     */
    virtual double GetCrossDiff(void) { return 0.0; };
    
    /*!
     * \brief Get the value of the eddy viscosity.
     * \return the value of the eddy viscosity.
     */
    virtual double GetmuT(void);
    
    /*!
     * \brief Set the value of the eddy viscosity.
     * \param[in] val_muT
     */
    virtual void SetmuT(double val_muT);
    
    /*!
     * \brief Add a value to the maximum eigenvalue for the inviscid terms of the PDE.
     * \param[in] val_max_lambda - Value of the maximum eigenvalue for the inviscid terms of the PDE.
     * \param[in] iSpecies - Value of iSpecies to which the eigenvalue belongs
     */
    virtual void AddMax_Lambda_Inv(double val_max_lambda, unsigned short iSpecies);
    
    /*!
     * \brief Add a value to the maximum eigenvalue for the viscous terms of the PDE.
     * \param[in] val_max_lambda - Value of the maximum eigenvalue for the viscous terms of the PDE.
     * \param[in] iSpecies - Value of iSpecies to which the eigenvalue belongs
     */
    virtual void AddMax_Lambda_Visc(double val_max_lambda, unsigned short iSpecies);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_difflevelset - Value of the diff level set (value-target).
     */
    virtual void SetDiffLevelSet(double val_difflevelset);
    
    /*!
     * \brief A virtual member.
     */
    virtual double GetDiffLevelSet(void);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_source - Value of the time spectral source.
     */
    virtual void SetTimeSpectral_Source(unsigned short val_var, double val_source);
    
    /*!
     * \brief A virtual member.
     */
    virtual double GetTimeSpectral_Source(unsigned short val_var);
    
    /*!
     * \brief Set the Eddy Viscosity Sensitivity of the problem.
     * \param[in] val_EddyViscSens - Eddy Viscosity Sensitivity.
     */
    virtual void SetEddyViscSens(double *val_EddyViscSens, unsigned short numTotalVar);
    
    /*!
     * \brief Get the Eddy Viscosity Sensitivity of the problem.
     * \return Pointer to the Eddy Viscosity Sensitivity.
     */
    virtual double *GetEddyViscSens(void);
    
    /*!
     * \brief A virtual member.  Retrieves index of species densities in the TNE2 solver.
     */
    virtual unsigned short GetRhosIndex(void);
    
    /*!
     * \brief Retrieves the value of the species density in the primitive variable vector.
     *  iRho_s
     */
    virtual unsigned short GetRhoIndex(void);
    
    /*!
     * \brief Retrieves the value of the species density in the primitive variable vector.
     *  iRho_s
     */
    virtual unsigned short GetPIndex(void);
    
    /*!
     * \brief Retrieves the value of the species density in the primitive variable vector.
     * iRho_s
     */
    virtual unsigned short GetTIndex(void);
    
    /*!
     * \brief Retrieves the value of the species density in the primitive variable vector.
     * iRho_s
     */
    virtual unsigned short GetTveIndex(void);
    
    /*!
     * \brief Retrieves the value of the velocity index in the primitive variable vector.
     * iRho*u
     */
    virtual unsigned short GetVelIndex(void);
    
    /*!
     * \brief Retrieves the value of the species density in the primitive variable vector.
     * iRho_s
     */
    virtual unsigned short GetHIndex(void);
    
    /*!
     * \brief Retrieves the value of the species density in the primitive variable vector.
     * iRho_s
     */
    virtual unsigned short GetAIndex(void);
    
    /*!
     * \brief Retrieves the value of the species density in the primitive variable vector.
     * iRho_s
     */
    virtual unsigned short GetRhoCvtrIndex(void);
    
    /*!
     * \brief Retrieves the value of the species density in the primitive variable vector.
     * iRho_s
     */
    virtual unsigned short GetRhoCvveIndex(void);
    
    /*!
     * \brief A virtual member. Set the direct solution for the adjoint solver.
     * \param[in] val_solution_direct - Value of the direct solution.
     */
    virtual void SetSolution_Direct(double *val_solution_direct);
    
    /*!
     * \brief A virtual member. Get the direct solution for the adjoint solver.
     * \return Pointer to the direct solution vector.
     */
    virtual double *GetSolution_Direct(void);
    
};

/*!
 * \class CBaselineVariable
 * \brief Main class for defining the variables of a baseline solution from a restart file (for output).
 * \author F. Palacios, T. Economon.
 * \version 3.2.9 "eagle"
 */
class CBaselineVariable : public CVariable {
public:
    
    /*!
     * \brief Constructor of the class.
     */
    CBaselineVariable(void);
    
    /*!
     * \overload
     * \param[in] val_solution - Pointer to the flow value (initialization value).
     * \param[in] val_nvar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CBaselineVariable(double *val_solution, unsigned short val_nvar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    virtual ~CBaselineVariable(void);
    
};

/*!
 * \class CPotentialVariable
 * \brief Main class for defining the variables of the potential solver.
 * \ingroup Potential_Flow_Equation
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CPotentialVariable : public CVariable {
    double *Charge_Density;
public:
    
    /*!
     * \brief Constructor of the class.
     */
    CPotentialVariable(void);
    
    /*!
     * \overload
     * \param[in] val_potential - Value of the potential solution (initialization value).
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nvar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CPotentialVariable(double val_potential, unsigned short val_nDim, unsigned short val_nvar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CPotentialVariable(void);
    
    /*!
     * \brief A virtual member.
     */
    double* GetChargeDensity();
    
    /*!
     * \brief A virtual member.
     * \param[in] positive_charge - Mass density of positive charge.
     * \param[in] negative_charge - Mass density of negative charge.
     */
    void SetChargeDensity(double positive_charge, double negative_charge);
    
};

/*!
 * \class CWaveVariable
 * \brief Main class for defining the variables of the wave equation solver.
 * \ingroup Potential_Flow_Equation
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CWaveVariable : public CVariable {
protected:
    double *Solution_Direct;  /*!< \brief Direct solution container for use in the adjoint wave solver. */
    
public:
    
    /*!
     * \brief Constructor of the class.
     */
    CWaveVariable(void);
    
    /*!
     * \overload
     * \param[in] val_wave - Values of the wave solution (initialization value).
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nvar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CWaveVariable(double *val_wave, unsigned short val_nDim, unsigned short val_nvar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CWaveVariable(void);
    
    /*!
     * \brief Set the direct solution for the adjoint solver.
     * \param[in] val_solution_direct - Value of the direct solution.
     */
    void SetSolution_Direct(double *val_solution_direct);
    
    /*!
     * \brief Get the direct solution for the adjoint solver.
     * \return Pointer to the direct solution vector.
     */
    double *GetSolution_Direct(void);
    
};

/*!
 * \class CHeatVariable
 * \brief Main class for defining the variables of the Heat equation solver.
 * \ingroup Potential_Flow_Equation
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CHeatVariable : public CVariable {
protected:
    double *Solution_Direct;  /*!< \brief Direct solution container for use in the adjoint Heat solver. */
    
public:
    
    /*!
     * \brief Constructor of the class.
     */
    CHeatVariable(void);
    
    /*!
     * \overload
     * \param[in] val_Heat - Values of the Heat solution (initialization value).
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nvar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CHeatVariable(double *val_Heat, unsigned short val_nDim, unsigned short val_nvar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CHeatVariable(void);
    
    /*!
     * \brief Set the direct solution for the adjoint solver.
     * \param[in] val_solution_direct - Value of the direct solution.
     */
    void SetSolution_Direct(double *val_solution_direct);
    
    /*!
     * \brief Get the direct solution for the adjoint solver.
     * \return Pointer to the direct solution vector.
     */
    double *GetSolution_Direct(void);
    
};

/*!
 * \class CFEAVariable
 * \brief Main class for defining the variables of the FEA equation solver.
 * \ingroup Potential_Flow_Equation
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CFEAVariable : public CVariable {
protected:
    double Flow_Pressure;	/*!< \brief Pressure of the fluid. */
    double **Stress;  /*!< \brief Stress tensor. */
    double VonMises_Stress; /*!< \brief Von Mises stress. */
    
public:
    
    /*!
     * \brief Constructor of the class.
     */
    CFEAVariable(void);
    
    /*!
     * \overload
     * \param[in] val_fea - Values of the fea solution (initialization value).
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nvar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CFEAVariable(double *val_fea, unsigned short val_nDim, unsigned short val_nvar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CFEAVariable(void);
    
    /*!
     * \brief Set the value of the stress.
     * \param[in] iVar - i index.
     * \param[in] jVar - j index.
     * \param[in] val_stress - Value of the stress.
     */
    void SetStress(unsigned short iVar, unsigned short jVar, double val_stress);
    
    /*!
     * \brief Get the value of the stress.
     * \return Value of the stress.
     */
    double **GetStress(void);
    
    /*!
     * \brief Set the value of the Von Mises stress.
     * \param[in] val_stress - Value of the Von Mises stress.
     */
    void SetVonMises_Stress(double val_stress);
    
    /*!
     * \brief Get the value of the Von Mises stress.
     * \return Value of the Von Mises stress.
     */
    double GetVonMises_Stress(void);
    
    /*!
     * \brief Set the value of the Von Mises stress.
     * \param[in] val_stress - Value of the Von Mises stress.
     */
    void SetFlow_Pressure(double val_pressure);
    
    /*!
     * \brief Get the value of the Von Mises stress.
     * \return Value of the Von Mises stress.
     */
    double GetFlow_Pressure(void);
    
};

/*!
 * \class CEulerVariable
 * \brief Main class for defining the variables of the Euler's solver.
 * \ingroup Euler_Equations
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CEulerVariable : public CVariable {
protected:
    double Velocity2;			/*!< \brief Square of the velocity vector. */
    double *TS_Source;		/*!< \brief Time spectral source term. */
    double Precond_Beta;	/*!< \brief Low Mach number preconditioner value, Beta. */
    double *WindGust;           /*! < \brief Wind gust value */
    double *WindGustDer;        /*! < \brief Wind gust derivatives value */
    
    /*--- Primitive variable definition ---*/
    
    double *Primitive;	/*!< \brief Primitive variables (T, vx, vy, vz, P, rho, h, c) in compressible flows. */
    double **Gradient_Primitive;	/*!< \brief Gradient of the primitive variables (T, vx, vy, vz, P, rho). */
    double *Limiter_Primitive;    /*!< \brief Limiter of the primitive variables (T, vx, vy, vz, P, rho). */
    
    /*--- Secondary variable definition ---*/
    
    double *Secondary;	/*!< \brief Primitive variables (T, vx, vy, vz, P, rho, h, c) in compressible flows. */
    double **Gradient_Secondary;	/*!< \brief Gradient of the primitive variables (T, vx, vy, vz, P, rho). */
    double *Limiter_Secondary;    /*!< \brief Limiter of the primitive variables (T, vx, vy, vz, P, rho). */
    
public:
    
    /*!
     * \brief Constructor of the class.
     */
    CEulerVariable(void);
    
    /*!
     * \overload
     * \param[in] val_density - Value of the flow density (initialization value).
     * \param[in] val_velocity - Value of the flow velocity (initialization value).
     * \param[in] val_energy - Value of the flow energy (initialization value).
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nvar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CEulerVariable(double val_density, double *val_velocity, double val_energy, unsigned short val_nDim,
                   unsigned short val_nvar, CConfig *config);
    
    /*!
     * \overload
     * \param[in] val_solution - Pointer to the flow value (initialization value).
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nvar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CEulerVariable(double *val_solution, unsigned short val_nDim, unsigned short val_nvar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    virtual ~CEulerVariable(void);
    
    /*!
     * \brief Set to zero the gradient of the primitive variables.
     */
    void SetGradient_PrimitiveZero(unsigned short val_primvar);
    
    /*!
     * \brief Add <i>val_value</i> to the gradient of the primitive variables.
     * \param[in] val_var - Index of the variable.
     * \param[in] val_dim - Index of the dimension.
     * \param[in] val_value - Value to add to the gradient of the primitive variables.
     */
    void AddGradient_Primitive(unsigned short val_var, unsigned short val_dim, double val_value);
    
    /*!
     * \brief Subtract <i>val_value</i> to the gradient of the primitive variables.
     * \param[in] val_var - Index of the variable.
     * \param[in] val_dim - Index of the dimension.
     * \param[in] val_value - Value to subtract to the gradient of the primitive variables.
     */
    void SubtractGradient_Primitive(unsigned short val_var, unsigned short val_dim, double val_value);
    
    /*!
     * \brief Get the value of the primitive variables gradient.
     * \param[in] val_var - Index of the variable.
     * \param[in] val_dim - Index of the dimension.
     * \return Value of the primitive variables gradient.
     */
    double GetGradient_Primitive(unsigned short val_var, unsigned short val_dim);
    
    /*!
     * \brief Get the value of the primitive variables gradient.
     * \param[in] val_var - Index of the variable.
     * \return Value of the primitive variables gradient.
     */
    double GetLimiter_Primitive(unsigned short val_var);
    
    /*!
     * \brief Set the gradient of the primitive variables.
     * \param[in] val_var - Index of the variable.
     * \param[in] val_dim - Index of the dimension.
     * \param[in] val_value - Value of the gradient.
     */
    void SetGradient_Primitive(unsigned short val_var, unsigned short val_dim, double val_value);
    
    /*!
     * \brief Set the gradient of the primitive variables.
     * \param[in] val_var - Index of the variable.
     * \param[in] val_value - Value of the gradient.
     */
    void SetLimiter_Primitive(unsigned short val_var, double val_value);
    
    /*!
     * \brief Get the value of the primitive variables gradient.
     * \return Value of the primitive variables gradient.
     */
    double **GetGradient_Primitive(void);
    
    /*!
     * \brief Get the value of the primitive variables gradient.
     * \return Value of the primitive variables gradient.
     */
    double *GetLimiter_Primitive(void);
    
    /*!
     * \brief Set to zero the gradient of the primitive variables.
     */
    void SetGradient_SecondaryZero(unsigned short val_secondaryvar);
    
    /*!
     * \brief Add <i>val_value</i> to the gradient of the primitive variables.
     * \param[in] val_var - Index of the variable.
     * \param[in] val_dim - Index of the dimension.
     * \param[in] val_value - Value to add to the gradient of the primitive variables.
     */
    void AddGradient_Secondary(unsigned short val_var, unsigned short val_dim, double val_value);
    
    /*!
     * \brief Subtract <i>val_value</i> to the gradient of the primitive variables.
     * \param[in] val_var - Index of the variable.
     * \param[in] val_dim - Index of the dimension.
     * \param[in] val_value - Value to subtract to the gradient of the primitive variables.
     */
    void SubtractGradient_Secondary(unsigned short val_var, unsigned short val_dim, double val_value);
    
    /*!
     * \brief Get the value of the primitive variables gradient.
     * \param[in] val_var - Index of the variable.
     * \param[in] val_dim - Index of the dimension.
     * \return Value of the primitive variables gradient.
     */
    double GetGradient_Secondary(unsigned short val_var, unsigned short val_dim);
    
    /*!
     * \brief Get the value of the primitive variables gradient.
     * \param[in] val_var - Index of the variable.
     * \param[in] val_dim - Index of the dimension.
     * \return Value of the primitive variables gradient.
     */
    double GetLimiter_Secondary(unsigned short val_var);
    
    /*!
     * \brief Set the gradient of the primitive variables.
     * \param[in] val_var - Index of the variable.
     * \param[in] val_dim - Index of the dimension.
     * \param[in] val_value - Value of the gradient.
     */
    void SetGradient_Secondary(unsigned short val_var, unsigned short val_dim, double val_value);
    
    /*!
     * \brief Set the gradient of the primitive variables.
     * \param[in] val_var - Index of the variable.
     * \param[in] val_dim - Index of the dimension.
     * \param[in] val_value - Value of the gradient.
     */
    void SetLimiter_Secondary(unsigned short val_var, double val_value);
    
    /*!
     * \brief Get the value of the primitive variables gradient.
     * \return Value of the primitive variables gradient.
     */
    double **GetGradient_Secondary(void);
    
    /*!
     * \brief Get the value of the primitive variables gradient.
     * \return Value of the primitive variables gradient.
     */
    double *GetLimiter_Secondary(void);
    
    /*!
     * \brief A virtual member.
     */
    void SetdPdrho_e(double dPdrho_e);
    
    /*!
   	 * \brief A virtual member.
   	 */
    void SetdPde_rho(double dPde_rho);
    
    /*!
     * \brief Set the value of the pressure.
     */
    bool SetPressure(double Gamma);
    
    /*!
     * \brief Set the value of the speed of the sound.
     * \param[in] Gamma - Value of Gamma.
     */
    bool SetSoundSpeed(double Gamma);
    
    /*!
     * \brief Set the value of the enthalpy.
     */
    void SetEnthalpy(void);
    
    //	/*!
    //	 * \brief Set all the primitive variables for compressible flows.
    //	 */
    //	bool SetPrimVar_Compressible(CConfig *config);
    
    /*!
     * \brief Set all the primitive variables for compressible flows.
     */
    bool SetPrimVar_Compressible(CFluidModel *FluidModel);
    
    /*!
     * \brief A virtual member.
     */
    void SetSecondaryVar_Compressible(CFluidModel *FluidModel);
    
    /*!
     * \brief Set all the primitive variables for incompressible flows.
     */
    bool SetPrimVar_Incompressible(double Density_Inf, CConfig *config);
    
    /*!
     * \brief Set all the primitive variables for incompressible flows.
     */
    bool SetPrimVar_FreeSurface(CConfig *config);
    
    /*!
     * \brief Get the primitive variables.
     * \param[in] val_var - Index of the variable.
     * \return Value of the primitive variable for the index <i>val_var</i>.
     */
    double GetPrimitive(unsigned short val_var);
    
    /*!
     * \brief Set the value of the primitive variables.
     * \param[in] val_var - Index of the variable.
     * \param[in] val_var - Index of the variable.
     * \return Set the value of the primitive variable for the index <i>val_var</i>.
     */
    void SetPrimitive(unsigned short val_var, double val_prim);
    
    /*!
     * \brief Set the value of the primitive variables.
     * \param[in] val_prim - Primitive variables.
     * \return Set the value of the primitive variable for the index <i>val_var</i>.
     */
    void SetPrimitive(double *val_prim);
    
    /*!
     * \brief Get the primitive variables of the problem.
     * \return Pointer to the primitive variable vector.
     */
    double *GetPrimitive(void);
    
    /*!
     * \brief Get the primitive variables.
     * \param[in] val_var - Index of the variable.
     * \return Value of the primitive variable for the index <i>val_var</i>.
     */
    double GetSecondary(unsigned short val_var);
    
    /*!
     * \brief Set the value of the primitive variables.
     * \param[in] val_var - Index of the variable.
     * \param[in] val_var - Index of the variable.
     * \return Set the value of the primitive variable for the index <i>val_var</i>.
     */
    void SetSecondary(unsigned short val_var, double val_secondary);
    
    /*!
     * \brief Set the value of the primitive variables.
     * \param[in] val_prim - Primitive variables.
     * \return Set the value of the primitive variable for the index <i>val_var</i>.
     */
    void SetSecondary(double *val_secondary);
    
    /*!
     * \brief Get the primitive variables of the problem.
     * \return Pointer to the primitive variable vector.
     */
    double *GetSecondary(void);
    
    /*!
     * \brief Set the value of the density for the incompressible flows.
     */
    void SetDensityInc(double val_density);
    
    /*!
     * \brief Set the value of the density for the incompressible flows.
     */
    bool SetDensity(void);
    
    /*!
     * \brief Set the value of the density for the incompressible flows.
     */
    void SetPressureInc(void);
    
    /*!
     * \brief Set the value of the density for the incompressible flows.
     */
    void SetVelocityInc(void);
    
    /*!
     * \brief Set the value of the beta coeffient for incompressible flows.
     */
    void SetBetaInc2(double val_betainc2);
    
    /*!
     * \brief Set the value of the temperature.
     * \param[in] Gas_Constant - Value of Gas Constant
     */
    bool SetTemperature(double Gas_Constant);
    
    /*!
     * \brief Get the norm 2 of the velocity.
     * \return Norm 2 of the velocity vector.
     */
    double GetVelocity2(void);
    
    /*!
     * \brief Get the flow pressure.
     * \return Value of the flow pressure.
     */
    double GetPressure(void);
    
    /*!
     * \brief Get the flow pressure.
     * \return Value of the flow pressure.
     */
    double GetPressureInc(void);
    
    /*!
     * \brief Get the speed of the sound.
     * \return Value of speed of the sound.
     */
    double GetSoundSpeed(void);
    
    /*!
     * \brief Get the value of density for the incompressible flow
     * \return Value of beta squared.
     */
    double GetDensityInc(void);
    
    /*!
     * \brief Get the value of levelset for the freesurface flows
     * \return Value of beta squared.
     */
    double GetLevelSet(void);
    
    /*!
     * \brief Get the value of distance for the freesurface flows
     * \return Value of beta squared.
     */
    double GetDistance(void);
    
    /*!
     * \brief Get the value of beta squared for the incompressible flow
     * \return Value of beta squared.
     */
    double GetBetaInc2(void);
    
    /*!
     * \brief Get the enthalpy of the flow.
     * \return Value of the enthalpy of the flow.
     */
    double GetEnthalpy(void);
    
    /*!
     * \brief Get the density of the flow.
     * \return Value of the density of the flow.
     */
    double GetDensity(void);
    
    /*!
     * \brief Get the energy of the flow.
     * \return Value of the energy of the flow.
     */
    double GetEnergy(void);
    
    /*!
     * \brief Get the temperature of the flow.
     * \return Value of the temperature of the flow.
     */
    double GetTemperature(void);
    
    /*!
     * \brief Get the velocity of the flow.
     * \param[in] val_dim - Index of the dimension.
     * \return Value of the velocity for the dimension <i>val_dim</i>.
     */
    double GetVelocity(unsigned short val_dim);
    
    /*!
     * \brief Get the projected velocity in a unitary vector direction (compressible solver).
     * \param[in] val_vector - Direction of projection.
     * \return Value of the projected velocity.
     */
    double GetProjVel(double *val_vector);
    
    /*!
     * \brief Set the velocity vector from the solution.
     * \param[in] val_velocity - Pointer to the velocity.
     */
    void SetVelocity(void);
    
    /*!
     * \brief Set the velocity vector from the old solution.
     * \param[in] val_velocity - Pointer to the velocity.
     */
    void SetVelocity_Old(double *val_velocity);
    
    /*!
     * \brief Set the velocity vector from the old solution.
     * \param[in] val_velocity - Pointer to the velocity.
     */
    void SetVelocityInc_Old(double *val_velocity);
    
    /*!
     * \brief Set the time spectral source term.
     * \param[in] val_var - Index of the variable.
     * \param[in] val_solution - Value of the time spectral source term. for the index <i>val_var</i>.
     */
    void SetTimeSpectral_Source(unsigned short val_var, double val_source);
    
    /*!
     * \brief Get the time spectral source term.
     * \param[in] val_var - Index of the variable.
     * \return Value of the time spectral source term for the index <i>val_var</i>.
     */
    double GetTimeSpectral_Source(unsigned short val_var);
    
    /*!
     * \brief Get the value of the preconditioner Beta.
     * \return Value of the low Mach preconditioner variable Beta
     */
    double GetPreconditioner_Beta();
    
    /*!
     * \brief Set the value of the preconditioner Beta.
     * \param[in] Value of the low Mach preconditioner variable Beta
     */
    void SetPreconditioner_Beta(double val_Beta);
    
    /*!
     * \brief Set the value of the magnetic field
     * \param[in] Value of the magnetic field
     */
    //void SetMagneticField(double* val_B);
    
    /*!
     * \brief Get the value of the wind gust
     * \return Value of the wind gust
     */
    double* GetWindGust();
    
    /*!
     * \brief Set the value of the wind gust
     * \param[in] Value of the wind gust
     */
    void SetWindGust(double* val_WindGust);
    
    /*!
     * \brief Get the value of the derivatives of the wind gust
     * \return Value of the derivatives of the wind gust
     */
    double* GetWindGustDer();
    
    /*!
     * \brief Set the value of the derivatives of the wind gust
     * \param[in] Value of the derivatives of the wind gust
     */
    void SetWindGustDer(double* val_WindGust);
};

/*!
 * \class CNSVariable
 * \brief Main class for defining the variables of the Navier-Stokes' solver.
 * \ingroup Navier_Stokes_Equations
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CNSVariable : public CEulerVariable {
private:
    double Prandtl_Lam;     /*!< \brief Laminar Prandtl number. */
    double Prandtl_Turb;    /*!< \brief Turbulent Prandtl number. */
    double Temperature_Ref; /*!< \brief Reference temperature of the fluid. */
    double Viscosity_Ref;   /*!< \brief Reference viscosity of the fluid. */
    double Viscosity_Inf;   /*!< \brief Viscosity of the fluid at the infinity. */
    double Vorticity[3];    /*!< \brief Vorticity of the fluid. */
    double StrainMag;       /*!< \brief Magnitude of rate of strain tensor. */
public:
    
    /*!
     * \brief Constructor of the class.
     */
    CNSVariable(void);
    
    /*!
     * \overload
     * \param[in] val_density - Value of the flow density (initialization value).
     * \param[in] val_velocity - Value of the flow velocity (initialization value).
     * \param[in] val_energy - Value of the flow energy (initialization value).
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nvar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CNSVariable(double val_density, double *val_velocity,
                double val_energy, unsigned short val_nDim, unsigned short val_nvar, CConfig *config);
    
    /*!
     * \overload
     * \param[in] val_solution - Pointer to the flow value (initialization value).
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nvar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CNSVariable(double *val_solution, unsigned short val_nDim, unsigned short val_nvar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CNSVariable(void);
    
    /*!
     * \brief Set the laminar viscosity.
     */
    void SetLaminarViscosity(double laminarViscosity);
    
    /*!
     * \overload
     * \param[in] val_laminar_viscosity_inc - Value of the laminar viscosity (incompressible flows).
     */
    void SetLaminarViscosityInc(double val_laminar_viscosity_inc);
    
    /*!
     * \brief Set the laminar viscosity.
     */
    void SetThermalConductivity(double thermalConductivity);
    
    /*!
     * \brief Set the specific heat Cp.
     */
    void SetSpecificHeatCp(double Cp);
    
    /*!
     * \brief Set the vorticity value.
     */
    bool SetVorticity(bool val_limiter);
    
    /*!
     * \brief Set the rate of strain magnitude.
     */
    bool SetStrainMag(bool val_limiter);
    
    /*!
     * \overload
     * \param[in] eddy_visc - Value of the eddy viscosity.
     */
    void SetEddyViscosity(double eddy_visc);
    
    /*!
     * \overload
     * \param[in] eddy_visc - Value of the eddy viscosity.
     */
    void SetEddyViscosityInc(double eddy_visc);
    
    /*!
     * \brief Get the laminar viscosity of the flow.
     * \return Value of the laminar viscosity of the flow.
     */
    double GetLaminarViscosity(void);
    
    /*!
     * \brief Get the laminar viscosity of the incompressible flow.
     * \return Value of the laminar viscosity of the incompressible flow.
     */
    double GetLaminarViscosityInc(void);
    
    /*!
     * \brief Get the thermal conductivity of the flow.
     * \return Value of the laminar viscosity of the flow.
     */
    double GetThermalConductivity(void);
    
    /*!
     * \brief Get the eddy viscosity of the flow.
     * \return The eddy viscosity of the flow.
     */
    double GetEddyViscosity(void);
    
    /*!
     * \brief Get the specific heat at constant P of the flow.
     * \return Value of the specific heat at constant P  of the flow.
     */
    double GetSpecificHeatCp(void);
    
    /*!
     * \brief Get the eddy viscosity of the flow.
     * \return The eddy viscosity of the flow.
     */
    double GetEddyViscosityInc(void);
    
    /*!
     * \brief Set the temperature at the wall
     */
    void SetWallTemperature(double temperature_wall);
    
    /*!
     * \brief Get the value of the vorticity.
     * \param[in] val_dim - Index of the dimension.
     * \return Value of the vorticity.
     */
    double *GetVorticity(void);
    
    /*!
     * \brief Get the value of the magnitude of rate of strain.
     * \return Value of the rate of strain magnitude.
     */
    double GetStrainMag(void);
    
    /*!
     * \brief Set the derivative of temperature with respect to density (at constant internal energy).
     */
    void SetdTdrho_e(double dTdrho_e);
    
    /*!
     * \brief Set the derivative of temperature with respect to internal energy (at constant density).
     */
    void SetdTde_rho(double dTde_rho);
    
    /*!
     * \brief Set the derivative of laminar viscosity with respect to density (at constant temperature).
     */
    void Setdmudrho_T(double dmudrho_T);
    
    /*!
     * \brief Set the derivative of laminar viscosity with respect to temperature (at constant density).
     */
    void SetdmudT_rho(double dmudT_rho);
    
    /*!
     * \brief Set the derivative of thermal conductivity with respect to density (at constant temperature).
     */
    void Setdktdrho_T(double dktdrho_T);
    
    /*!
     * \brief Set the derivative of thermal conductivity with respect to temperature (at constant density).
     */
    void SetdktdT_rho(double dktdT_rho);
    
    /*!
     * \brief Set all the primitive variables for compressible flows
     */
    bool SetPrimVar_Compressible(double eddy_visc, double turb_ke, CFluidModel *FluidModel);
    
    /*!
     * \brief Set all the secondary variables (partial derivatives) for compressible flows
     */
    void SetSecondaryVar_Compressible(CFluidModel *FluidModel);
    
    /*!
     * \brief Set all the primitive variables for incompressible flows
     */
    bool SetPrimVar_Incompressible(double Density_Inf, double Viscosity_Inf, double eddy_visc, double turb_ke, CConfig *config);
    
    /*!
     * \brief Set all the primitive variables for incompressible flows
     */
    bool SetPrimVar_FreeSurface(double eddy_visc, double turb_ke, CConfig *config);
};

/*!
 * \class CTurbVariable
 * \brief Main class for defining the variables of the turbulence model.
 * \ingroup Turbulence_Model
 * \author A. Bueno.
 * \version 3.2.9 "eagle"
 */
class CTurbVariable : public CVariable {
protected:
    double muT;                /*!< \brief Eddy viscosity. */
    double *TS_Source; 	       /*!< \brief Time spectral source term. */
    
public:
    /*!
     * \brief Constructor of the class.
     */
    CTurbVariable(void);
    
    /*!
     * \overload
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nvar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CTurbVariable(unsigned short val_nDim, unsigned short val_nvar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    virtual ~CTurbVariable(void);
    
    /*!
     * \brief Get the value of the eddy viscosity.
     * \return the value of the eddy viscosity.
     */
    double GetmuT();
    
    /*!
     * \brief Set the value of the eddy viscosity.
     * \param[in] val_muT - Value of the eddy viscosity.
     */
    void SetmuT(double val_muT);
};

/*!
 * \class CTurbSAVariable
 * \brief Main class for defining the variables of the turbulence model.
 * \ingroup Turbulence_Model
 * \author A. Bueno.
 * \version 3.2.9 "eagle"
 */

class CTurbSAVariable : public CTurbVariable {
public:
    /*!
     * \brief Constructor of the class.
     */
    CTurbSAVariable(void);
    
    /*!
     * \overload
     * \param[in] val_nu_tilde - Turbulent variable value (initialization value).
     * \param[in] val_muT  - The eddy viscosity
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nvar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CTurbSAVariable(double val_nu_tilde, double val_muT, unsigned short val_nDim, unsigned short val_nvar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CTurbSAVariable(void);
    
    /*!
     * \brief Set the time spectral source term.
     * \param[in] val_var - Index of the variable.
     * \param[in] val_source - Value of the time spectral source term. for the index <i>val_var</i>.
     */
    void SetTimeSpectral_Source(unsigned short val_var, double val_source);
    
    /*!
     * \brief Get the time spectral source term.
     * \param[in] val_var - Index of the variable.
     * \return Value of the time spectral source term for the index <i>val_var</i>.
     */
    double GetTimeSpectral_Source(unsigned short val_var);
    
};


/*!
 * \class CTurbMLVariable
 * \brief Main class for defining the variables of the turbulence model.
 * \ingroup Turbulence_Model
 * \author A. Bueno.
 * \version 3.2.9 "eagle"
 */

class CTurbMLVariable : public CTurbVariable {
public:
    /*!
     * \brief Constructor of the class.
     */
    CTurbMLVariable(void);
    
    /*!
     * \overload
     * \param[in] val_nu_tilde - Turbulent variable value (initialization value).
     * \param[in] val_muT  - The eddy viscosity
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nvar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CTurbMLVariable(double val_nu_tilde, double val_muT, unsigned short val_nDim, unsigned short val_nvar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CTurbMLVariable(void);
    
    /*!
     * \brief Set the time spectral source term.
     * \param[in] val_var - Index of the variable.
     * \param[in] val_source - Value of the time spectral source term. for the index <i>val_var</i>.
     */
    void SetTimeSpectral_Source(unsigned short val_var, double val_source);
    
    /*!
     * \brief Get the time spectral source term.
     * \param[in] val_var - Index of the variable.
     * \return Value of the time spectral source term for the index <i>val_var</i>.
     */
    double GetTimeSpectral_Source(unsigned short val_var);
    
};

/*!
 * \class CTransLMVariable
 * \brief Main class for defining the variables of the turbulence model.
 * \ingroup Turbulence_Model
 * \author A. Bueno.
 * \version 3.2.9 "eagle"
 */

class CTransLMVariable : public CTurbVariable {
protected:
    double gamma_sep;
    
public:
    
    /*!
     * \brief Constructor of the class.
     */
    CTransLMVariable(void);
    
    /*!
     * \overload
     * \param[in] val_nu_tilde - Turbulent variable value (initialization value).
     * \param[in] val_REth
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nvar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CTransLMVariable(double val_nu_tilde, double val_intermittency, double val_REth, unsigned short val_nDim, unsigned short val_nvar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CTransLMVariable(void);
    
    /*!
     * \brief ________________.
     */
    double GetIntermittency(void);
    
    /*!
     * \brief ________________.
     * \param[in] gamma_sep_in
     */
    void SetGammaSep(double gamma_sep_in);
    
    /*!
     * \brief ________________.
     */
    void SetGammaEff(void);
    
};

/*!
 * \class CTurbSSTVariable
 * \brief Main class for defining the variables of the turbulence model.
 * \ingroup Turbulence_Model
 * \author A. Bueno.
 * \version 3.2.9 "eagle"
 */

class CTurbSSTVariable : public CTurbVariable {
protected:
    double sigma_om2,
    beta_star;
    double F1,		/*!< \brief Menter blending function for blending of k-w and k-eps. */
    F2,		        /*!< \brief Menter blending function for stress limiter. */
    CDkw;           /*!< \brief Cross-diffusion. */
    
public:
    /*!
     * \brief Constructor of the class.
     */
    CTurbSSTVariable(void);
    
    /*!
     * \overload
     * \param[in] val_rho_kine - Turbulent variable value (initialization value).
     * \param[in] val_rho_omega - Turbulent variable value (initialization value).
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nvar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CTurbSSTVariable(double val_rho_kine, double val_rho_omega, double val_muT, unsigned short val_nDim, unsigned short val_nvar,
                     double *constants, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CTurbSSTVariable(void);
    
    /*!
     * \brief Set the blending function for the blending of k-w and k-eps.
     * \param[in] val_viscosity - Value of the vicosity.
     * \param[in] val_dist - Value of the distance to the wall.
     * \param[in] val_density - Value of the density.
     */
    void SetBlendingFunc(double val_viscosity, double val_dist, double val_density);
    
    /*!
     * \brief Get the first blending function.
     */
    double GetF1blending(void);
    
    /*!
     * \brief Get the second blending function.
     */
    double GetF2blending(void);
    
    /*!
     * \brief Get the value of the cross diffusion of tke and omega.
     */
    double GetCrossDiff(void);
};

/*!
 * \class CAdjPotentialVariable
 * \brief Main class for defining the variables of the adjoint potential solver.
 * \ingroup Potential_Flow_Equation
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CAdjPotentialVariable : public CVariable {
private:
    double Psi;			/*!< \brief Value of the adjoint variable. */
    double *ForceProj_Vector;	/*!< \brief Vector d. */
    
public:
    
//    /*!
//     * \brief Constructor of the class.
//     */
//    CAdjPotentialVariable(void);
//    
//    /*!
//     * \overload
//     * \param[in] val_psi - Potential adjoint variable value (initialization value).
//     * \param[in] val_nDim - Number of dimensions of the problem.
//     * \param[in] val_nvar - Number of variables of the problem.
//     * \param[in] config - Definition of the particular problem.
//     */
//    CAdjPotentialVariable(double val_psi, unsigned short val_nDim, unsigned short val_nvar, CConfig *config);
//    
//    /*!
//     * \brief Destructor of the class.
//     */
//    
//    ~CAdjPotentialVariable(void);
};

/*!
 * \class CAdjEulerVariable
 * \brief Main class for defining the variables of the adjoint Euler solver.
 * \ingroup Euler_Equations
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CAdjEulerVariable : public CVariable {
protected:
    double *Psi;		/*!< \brief Vector of the adjoint variables. */
    double *ForceProj_Vector;	/*!< \brief Vector d. */
    double *ObjFuncSource;    /*!< \brief Vector containing objective function sensitivity for discrete adjoint. */
    double *IntBoundary_Jump;	/*!< \brief Interior boundary jump vector. */
    double *TS_Source;		/*!< \brief Time spectral source term. */
    bool incompressible;
public:
    
    /*!
     * \brief Constructor of the class.
     */
    CAdjEulerVariable(void);
    
    /*!
     * \overload
     * \param[in] val_psirho - Value of the adjoint density (initialization value).
     * \param[in] val_phi - Value of the adjoint velocity (initialization value).
     * \param[in] val_psie - Value of the adjoint energy (initialization value).
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nvar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CAdjEulerVariable(double val_psirho, double *val_phi, double val_psie, unsigned short val_nDim, unsigned short val_nvar, CConfig *config);
    
    /*!
     * \overload
     * \param[in] val_solution - Pointer to the adjoint value (initialization value).
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nvar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CAdjEulerVariable(double *val_solution, unsigned short val_nDim, unsigned short val_nvar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    virtual ~CAdjEulerVariable(void);
    
    /*!
     * \brief Set all the primitive variables for compressible flows.
     */
    bool SetPrimVar_Compressible(double SharpEdge_Distance, bool check, CConfig *config);
    
    /*!
     * \brief Set all the primitive variables for compressible flows.
     */
    bool SetPrimVar_Incompressible(double SharpEdge_Distance, bool check, CConfig *config);
    
    /*!
     * \brief Set all the primitive variables for compressible flows.
     */
    bool SetPrimVar_FreeSurface(double SharpEdge_Distance, bool check, CConfig *config);
    
    /*!
     * \brief Set the value of the adjoint velocity.
     * \param[in] val_phi - Value of the adjoint velocity.
     */
    void SetPhi_Old(double *val_phi);
    
    /*!
     * \brief Set the value of the force projection vector.
     * \param[in] val_ForceProj_Vector - Pointer to the force projection vector.
     */
    void SetForceProj_Vector(double *val_ForceProj_Vector);
    
    /*!
     * \brief Set the value of the objective function source.
     * \param[in] val_SetObjFuncSource - Pointer to the objective function source.
     */
    void SetObjFuncSource(double *val_SetObjFuncSource);
    
    /*!
     * \brief Set the value of the interior boundary jump vector vector.
     * \param[in] val_IntBoundary_Jump - Pointer to the interior boundary jump vector.
     */
    void SetIntBoundary_Jump(double *val_IntBoundary_Jump);
    
    /*!
     * \brief Get the value of the force projection vector.
     * \return Pointer to the force projection vector.
     */
    double *GetForceProj_Vector(void);
    
    /*!
     * \brief Get the value of the objective function source.
     * \param[in] val_SetObjFuncSource - Pointer to the objective function source.
     */
    double *GetObjFuncSource(void);
    
    /*!
     * \brief Get the value of the force projection vector.
     * \return Pointer to the force projection vector.
     */
    double *GetIntBoundary_Jump(void);
    
    /*!
     * \brief Set the time spectral source term.
     * \param[in] val_var - Index of the variable.
     * \param[in] val_solution - Value of the time spectral source term. for the index <i>val_var</i>.
     */
    void SetTimeSpectral_Source(unsigned short val_var, double val_source);
    
    /*!
     * \brief Get the time spectral source term.
     * \param[in] val_var - Index of the variable.
     * \return Value of the time spectral source term for the index <i>val_var</i>.
     */
    double GetTimeSpectral_Source(unsigned short val_var);
};

/*!
 * \class CAdjNSVariable
 * \brief Main class for defining the variables of the adjoint Navier-Stokes solver.
 * \ingroup Navier_Stokes_Equations
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CAdjNSVariable : public CAdjEulerVariable {
private:
    
public:
    
    /*!
     * \brief Constructor of the class.
     */
    CAdjNSVariable(void);
    
    /*!
     * \overload
     * \param[in] val_psirho - Value of the adjoint density (initialization value).
     * \param[in] val_phi - Value of the adjoint velocity (initialization value).
     * \param[in] val_psie - Value of the adjoint energy (initialization value).
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nvar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CAdjNSVariable(double val_psirho, double *val_phi, double val_psie, unsigned short val_nDim, unsigned short val_nvar, CConfig *config);
    
    /*!
     * \overload
     * \param[in] val_solution - Pointer to the adjoint value (initialization value).
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nvar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CAdjNSVariable(double *val_solution, unsigned short val_nDim, unsigned short val_nvar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CAdjNSVariable(void);
    
    /*!
     * \brief Set the value of the adjoint velocity.
     * \param[in] val_phi - Value of the adjoint velocity.
     */
    void SetPhi_Old(double *val_phi);
    
    /*!
     * \brief Set the value of the force projection vector.
     * \param[in] val_ForceProj_Vector - Pointer to the force projection vector.
     */
    void SetForceProj_Vector(double *val_ForceProj_Vector);
    
    /*!
     * \brief Get the value of the force projection vector.
     * \return Pointer to the force projection vector.
     */
    double *GetForceProj_Vector(void);
    
    /*!
     * \brief Set the value of the force projection vector on the solution vector.
     */
    void SetVelSolutionOldDVector(void);
    
    /*!
     * \brief Set the value of the force projection vector on the old solution vector.
     */
    void SetVelSolutionDVector(void);
    
};

/*!
 * \class CAdjTurbVariable
 * \brief Main class for defining the variables of the adjoint turbulence model.
 * \ingroup Turbulence_Model
 * \author A. Bueno.
 * \version 3.2.9 "eagle"
 */
class CAdjTurbVariable : public CVariable {
protected:
    double *dmuT_dUTvar;       /*!< \brief Sensitivity of eddy viscosity to mean flow and turbulence vars. */
    double **dRTstar_dUTvar; 	/*!< \brief Sensitivity of modified turbulence residual (no boundary flux)
                                 to mean flow and turbulence vars. */
    double **dFT_dUTvar; 	/*!< \brief Sensitivity of boundary flux
                             to mean flow and turbulence vars. */
    double *EddyViscSens;    /*!< \brief Eddy Viscosity Sensitivity. */
    
public:
    
    /*!
     * \brief Constructor of the class.
     */
    CAdjTurbVariable(void);
    
    /*!
     * \overload
     * \param[in] val_psinu_inf - Value of the adjoint turbulence variable at the infinity (initialization value).
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nvar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CAdjTurbVariable(double val_psinu_inf, unsigned short val_nDim, unsigned short val_nvar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CAdjTurbVariable(void);
    
    /*!
     * \brief Set the Eddy Viscosity Sensitivity of the problem.
     * \param[in] val_EddyViscSens - Eddy Viscosity Sensitivity.
     */
    void SetEddyViscSens(double *val_EddyViscSens, unsigned short numTotalVar);
    
    /*!
     * \brief Get the Eddy Viscosity Sensitivity of the problem.
     * \return Pointer to the Eddy Viscosity Sensitivity.
     */
    double *GetEddyViscSens(void);
};

/*!
 * \class CLinPotentialVariable
 * \brief Main class for defining the variables of the linearized potential equation.
 * \ingroup Potential_Flow_Equation
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CLinPotentialVariable : public CVariable {
public:
};

/*!
 * \class CLinEulerVariable
 * \brief Main class for defining the variables of the linearized Euler's equations.
 * \ingroup Euler_Equations
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CLinEulerVariable : public CVariable {
private:
    double *DeltaU;			/*!< \brief Vector of the linearized variables. */
    double *ForceProj_Vector;		/*!< \brief Vector d. */
    double DeltaPressure;	/*!< \brief Linearized pressure variable. */
    
public:
    
    /*!
     * \brief Constructor of the class.
     */
    CLinEulerVariable(void);
    
    /*!
     * \overload
     * \param[in] val_deltarho - Value of the linearized density (initialization value).
     * \param[in] val_deltavel - Value of the linearized velocity (initialization value).
     * \param[in] val_deltae - Value of the linearized energy (initialization value).
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nvar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CLinEulerVariable(double val_deltarho, double *val_deltavel, double val_deltae, unsigned short val_nDim, unsigned short val_nvar, CConfig *config);
    
    /*!
     * \overload
     * \param[in] val_solution - Pointer to the linearized value (initialization value).
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nvar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CLinEulerVariable(double *val_solution, unsigned short val_nDim, unsigned short val_nvar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CLinEulerVariable(void);
    
    /*!
     * \brief Set the value of the linearized velocity.
     * \param[in] val_deltavel - Value of the linearized velocity.
     */
    void SetDeltaVel_Old(double *val_deltavel);
    
    /*!
     * \brief Set the value of the force projection vector.
     * \param[in] val_ForceProj_Vector - Pointer to the force projection vector.
     */
    void SetForceProj_Vector(double *val_ForceProj_Vector);
    
    /*!
     * \brief Get the value of the force projection vector.
     * \return Pointer to the force projection vector.
     */
    double *GetForceProj_Vector(void);
    
    /*!
     * \brief Set the value of the linearized pressure.
     * \param[in] val_velocity - Value of the velocity.
     * \param[in] Gamma - The ratio of specific heats.
     */
    void SetDeltaPressure(double *val_velocity, double Gamma);
    
    /*!
     * \brief Get the value of the linearized pressure.
     * \return Value of the linearized pressure.
     */
    double GetDeltaPressure(void);
};

/*!
 * \class CLinNSVariable
 * \brief Main class for defining the variables of the linearized Navier-Stokes' equations.
 * \ingroup Navier_Stokes_Equations
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CLinNSVariable : public CLinEulerVariable {
public:
};

/*!
 * \class CAdjLevelSetVariable
 * \brief Main class for defining the variables of the Level Set.
 * \ingroup LevelSet_Model
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CAdjLevelSetVariable : public CVariable {
public:
    /*!
     * \brief Constructor of the class.
     */
    CAdjLevelSetVariable(void);
    
    /*!
     * \overload
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nvar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CAdjLevelSetVariable(unsigned short val_nDim, unsigned short val_nvar, CConfig *config);
    
    /*!
     * \overload
     * \param[in] val_levelset - Level set variable value (initialization value).
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nvar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CAdjLevelSetVariable(double val_levelset, unsigned short val_nDim, unsigned short val_nvar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    virtual ~CAdjLevelSetVariable(void);
    
};

/*!
 * \class CTNE2EulerVariable
 * \brief Main class for defining the variables of the TNE2 Euler's solver.
 * \ingroup Euler_Equations
 * \author S. R. Copeland, F. Palacios
 * \version 2.0.6
 */
class CTNE2EulerVariable : public CVariable {
protected:
    bool ionization;       /*!< \brief Presence of charged species in gas mixture. */
    unsigned short nSpecies;  /*!< \brief Number of species in the gas mixture. */
    double Velocity2;			/*!< \brief Square of the velocity vector. */
    double Precond_Beta;	/*!< \brief Low Mach number preconditioner value, Beta. */
    
    /*--- Primitive variable definition ---*/
    double *Primitive;	/*!< \brief Primitive variables (T, vx, vy, vz, P, rho, h, c) in compressible flows. */
    double **Gradient_Primitive;	/*!< \brief Gradient of the primitive variables (T, vx, vy, vz, P, rho). */
    double *Limiter_Primitive;    /*!< \brief Limiter of the primitive variables (T, vx, vy, vz, P, rho). */
    double *dPdU;                 /*!< \brief Partial derivative of pressure w.r.t. conserved variables. */
    double *dTdU;  /*!< \brief Partial derivative of temperature w.r.t. conserved variables. */
    double *dTvedU; /*!< \brief Partial derivative of vib.-el. temperature w.r.t. conserved variables. */
    
    unsigned short RHOS_INDEX, T_INDEX, TVE_INDEX, VEL_INDEX, P_INDEX,
    RHO_INDEX, H_INDEX, A_INDEX, RHOCVTR_INDEX, RHOCVVE_INDEX;
    
    
public:
    
    /*!
     * \brief Constructor of the class.
     */
    CTNE2EulerVariable(void);
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of conserved variables.
     */
    CTNE2EulerVariable(unsigned short val_nDim, unsigned short val_nVar,
                       unsigned short val_nPrimVar,
                       unsigned short val_nPrimVarGrad,
                       CConfig *config);
    
    /*!
     * \overload
     * \param[in] val_pressure
     * \param[in] val_massfrac
     * \param[in] val_mach
     * \param[in] val_temperature
     * \param[in] val_temperature_ve
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nvar - Number of conserved variables.
     * \param[in] val_nvarprim - Number of primitive variables.
     * \param[in] val_nvarprimgrad - Number of primitive gradient variables.
     * \param[in] config - Definition of the particular problem.
     */
    CTNE2EulerVariable(double val_pressure, double *val_massfrac,
                       double *val_mach, double val_temperature,
                       double val_temperature_ve, unsigned short val_nDim,
                       unsigned short val_nvar, unsigned short val_nvarprim,
                       unsigned short val_nvarprimgrad, CConfig *config);
    
    /*!
     * \overload
     * \param[in] val_solution - Pointer to the flow value (initialization value).
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nvar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CTNE2EulerVariable(double *val_solution, unsigned short val_nDim,
                       unsigned short val_nvar, unsigned short val_nvarprim,
                       unsigned short val_nvarprimgrad, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    virtual ~CTNE2EulerVariable(void);
    
    /*!
     * \brief Set to zero the gradient of the primitive variables.
     */
    void SetGradient_PrimitiveZero(unsigned short val_primvar);
    
    /*!
     * \brief Add <i>val_value</i> to the gradient of the primitive variables.
     * \param[in] val_var - Index of the variable.
     * \param[in] val_dim - Index of the dimension.
     * \param[in] val_value - Value to add to the gradient of the primitive variables.
     */
    void AddGradient_Primitive(unsigned short val_var, unsigned short val_dim, double val_value);
    
    /*!
     * \brief Subtract <i>val_value</i> to the gradient of the primitive variables.
     * \param[in] val_var - Index of the variable.
     * \param[in] val_dim - Index of the dimension.
     * \param[in] val_value - Value to subtract to the gradient of the primitive variables.
     */
    void SubtractGradient_Primitive(unsigned short val_var, unsigned short val_dim, double val_value);
    
    /*!
     * \brief Get the value of the primitive variables gradient.
     * \param[in] val_var - Index of the variable.
     * \param[in] val_dim - Index of the dimension.
     * \return Value of the primitive variables gradient.
     */
    double GetGradient_Primitive(unsigned short val_var, unsigned short val_dim);
    
    /*!
     * \brief Set the gradient of the primitive variables.
     * \param[in] val_var - Index of the variable.
     * \param[in] val_dim - Index of the dimension.
     * \param[in] val_value - Value of the gradient.
     */
    void SetGradient_Primitive(unsigned short val_var, unsigned short val_dim, double val_value);
    
    /*!
     * \brief Get the value of the primitive variables gradient.
     * \return Value of the primitive variables gradient.
     */
    double **GetGradient_Primitive(void);
    
    /*!
     * \brief Set the value of the velocity*velocity.
     */
    void SetVelocity2(void);
    
    /*!
     * \brief Set the value of the mixture density.
     */
    bool SetDensity(void);
    
    /*!
     * \brief Set the value of the pressure.  Requires T&Tve calculation.
     * \param[in] config
     */
    bool SetPressure(CConfig *config);
    
    /*!
     * \brief Set the value of the speed of the sound.
     * \param[in] config
     */
    bool SetSoundSpeed(CConfig *config);
    
    /*!
     * \brief Set the value of the enthalpy.
     */
    void SetEnthalpy(void);
    
    /*!
     * \brief Sets gas mixture quantities (\f$\rho C^{trans-rot}_v\f$ & \f$\rho C^{vib-el}_v\f$)
     * \param[in] config
     */
    void SetGasProperties(CConfig *config);
    
    /*!
     * \brief Calculates vib.-el. energy per mass, \f$e^{vib-el}_s\f$, for input species (not including KE)
     */
    double CalcEve(double *V, CConfig *config, unsigned short val_Species);
    
    /*!
     * \brief Calculates enthalpy per mass, \f$h^{vib-el}_s\f$, for input species (not including KE)
     */
    double CalcHs(double *V, CConfig *config, unsigned short val_Species);
    
    /*!
     * \brief Calculates enthalpy per mass, \f$C^{vib-el}_{v_s}\f$, for input species (not including KE)
     */
    double CalcCvve(double val_Tve, CConfig *config, unsigned short val_Species);
    
    /*!
     * \brief Calculates partial derivative of pressure w.r.t. conserved variables \f$\frac{\partial P}{\partial U}\f$
     * \param[in] config - Configuration settings
     * \param[in] dPdU - Passed-by-reference array to assign the derivatives
     */
    void CalcdPdU(double *V, CConfig *config, double *dPdU);
    
    /*!
     * \brief Set partial derivative of temperature w.r.t. density \f$\frac{\partial P}{\partial \rho_s}\f$
     */
    void CalcdTdU(double *V, CConfig *config, double *dTdU);
    
    /*!
     * \brief Set partial derivative of vib.-el. temperature w.r.t. density \f$\frac{\partial P}{\partial \rho_s}\f$
     */
    void CalcdTvedU(double *V, CConfig *config, double *dTvedU);
    
    /*!
     * \brief Set partial derivative of pressure w.r.t. density \f$\frac{\partial P}{\partial \rho_s}\f$
     */
    //void SetdTdrhos(CConfig *config);
    
    /*!
     * \brief Set partial derivative of pressure w.r.t. density \f$\frac{\partial P}{\partial \rho_s}\f$
     */
   // void SetdTvedrhos(CConfig *config);
    
    /*!
     * \brief Set partial derivative of pressure w.r.t. density \f$\frac{\partial P}{\partial \rho_s}\f$
     */
    double *GetdPdU(void);
    
    /*!
     * \brief Set partial derivative of temperature w.r.t. density \f$\frac{\partial T}{\partial \rho_s}\f$
     */
    double *GetdTdU(void);
    
    /*!
     * \brief Set partial derivative of vib.-el. temperature w.r.t. density \f$\frac{\partial T^{V-E}}{\partial \rho_s}\f$
     */
    double *GetdTvedU(void);
    
    /*!
     * \brief Set all the primitive variables for compressible flows.
     */
    bool SetPrimVar_Compressible(CConfig *config);
    
    /*!
     * \brief Set all the conserved variables.
     */
    bool Cons2PrimVar(CConfig *config, double *U, double *V, double *dPdU,
                      double *dTdU, double *dTvedU);
    
    /*!
     * \brief Set all the conserved variables.
     */
    void Prim2ConsVar(CConfig *config, double *V, double *U);
    
    /*!
     * \brief Get the primitive variables.
     * \param[in] val_var - Index of the variable.
     * \return Value of the primitive variable for the index <i>val_var</i>.
     */
    double GetPrimitive(unsigned short val_var);
    
    /*!
     * \brief Set the value of the primitive variables.
     * \param[in] val_var - Index of the variable.
     * \param[in] val_var - Index of the variable.
     * \return Set the value of the primitive variable for the index <i>val_var</i>.
     */
    void SetPrimitive(unsigned short val_var, double val_prim);
    
    /*!
     * \brief Set the value of the primitive variables.
     * \param[in] val_prim - Primitive variables.
     * \return Set the value of the primitive variable for the index <i>val_var</i>.
     */
    void SetPrimitive(double *val_prim);
    
    /*!
     * \brief Get the primitive variables of the problem.
     * \return Pointer to the primitive variable vector.
     */
    double *GetPrimitive(void);
    
    /*!
     * \brief A virtual member.
     * \param[in] config - Configuration parameters.
     */
    bool SetTemperature(CConfig *config);
    
    /*!
     * \brief Get the norm 2 of the velocity.
     * \return Norm 2 of the velocity vector.
     */
    double GetVelocity2(void);
    
    /*!
     * \brief Get the flow pressure.
     * \return Value of the flow pressure.
     */
    double GetPressure(void);
    /*!
     * \brief Get the speed of the sound.
     * \return Value of speed of the sound.
     */
    double GetSoundSpeed(void);
    
    /*!
     * \brief Get the enthalpy of the flow.
     * \return Value of the enthalpy of the flow.
     */
    double GetEnthalpy(void);
    
    /*!
     * \brief Get the density of the flow.
     * \return Value of the density of the flow.
     */
    double GetDensity(void);
    
    /*!
     * \brief Get the mass fraction \f$\rho_s / \rho \f$ of species s.
     * \param[in] val_Species - Index of species s.
     * \return Value of the mass fraction of species s.
     */
    double GetMassFraction(unsigned short val_Species);
    
    /*!
     * \brief Get the energy of the flow.
     * \return Value of the energy of the flow.
     */
    double GetEnergy(void);
    
    /*!
     * \brief Get the temperature of the flow.
     * \return Value of the temperature of the flow.
     */
    double GetTemperature(void);
    
    /*!
     * \brief Sets the temperature of the flow.
     * \return Value of the temperature of the flow.
     */
    bool SetTemperature(double val_T);
    
    /*!
     * \brief A virtual member.
     * \return Value of the vibrational-electronic temperature.
     */
    double GetTemperature_ve(void);
    
    /*!
     * \brief Sets the vibrational electronic temperature of the flow.
     * \return Value of the temperature of the flow.
     */
    bool SetTemperature_ve(double val_Tve);
    
    /*!
     * \brief Get the mixture specific heat at constant volume (trans.-rot.).
     * \return \f$\rho C^{t-r}_{v} \f$
     */
    double GetRhoCv_tr(void);
    
    /*!
     * \brief Get the mixture specific heat at constant volume (vib.-el.).
     * \return \f$\rho C^{v-e}_{v} \f$
     */
    double GetRhoCv_ve(void);
    
    /*!
     * \brief Get the velocity of the flow.
     * \param[in] val_dim - Index of the dimension.
     * \return Value of the velocity for the dimension <i>val_dim</i>.
     */
    double GetVelocity(unsigned short val_dim);
    
    /*!
     * \brief Get the projected velocity in a unitary vector direction (compressible solver).
     * \param[in] val_vector - Direction of projection.
     * \return Value of the projected velocity.
     */
    double GetProjVel(double *val_vector);
    
    /*!
     * \brief Set the velocity vector from the old solution.
     * \param[in] val_velocity - Pointer to the velocity.
     */
    void SetVelocity_Old(double *val_velocity);
    
    /*!
     * \brief Get the value of the limiter.
     */
    double *GetLimiter_Primitive(void);
    
    /*!
     * \brief Get the value of the primitive variables gradient.
     * \param[in] val_var - Index of the variable.
     * \return Value of the primitive variables gradient.
     */
    double GetLimiter_Primitive(unsigned short val_var);
    
    /*!
     * \brief Set the value of the limiter.
     */
    void SetLimiter_Primitive(unsigned short val_var, double val_value);
    
    /*!
     * \brief Set the value of the limiter.
     */
    void SetLimiter(unsigned short val_var, double val_value);
    
    /*!
     * \brief Get the value of the preconditioner Beta.
     * \return Value of the low Mach preconditioner variable Beta
     */
    double GetPreconditioner_Beta();
    
    /*!
     * \brief Set the value of the preconditioner Beta.
     * \param[in] val_Beta Value of the low Mach preconditioner variable Beta
     */
    void SetPreconditioner_Beta(double val_Beta);
    
    /*!
     * \brief Retrieves the value of the species density in the primitive variable vector.
     * iRho_s
     */
    unsigned short GetRhosIndex(void);
    
    /*!
     * \brief Retrieves the value of the species density in the primitive variable vector.
     * iRho_s
     */
    unsigned short GetRhoIndex(void);
    
    /*!
     * \brief Retrieves the value of the species density in the primitive variable vector.
     * iRho_s
     */
    unsigned short GetPIndex(void);
    
    /*!
     * \brief Retrieves the value of the species density in the primitive variable vector.
     * iRho_s
     */
    unsigned short GetTIndex(void);
    
    /*!
     * \brief Retrieves the value of the species density in the primitive variable vector.
     * iRho_s
     */
    unsigned short GetTveIndex(void);
    
    /*!
     * \brief Retrieves the value of the species density in the primitive variable vector.
     * iRho*u
     */
    unsigned short GetVelIndex(void);
    
    /*!
     * \brief Retrieves the value of the species density in the primitive variable vector.
     * iRho_s
     */
    unsigned short GetHIndex(void);
    
    /*!
     * \brief Retrieves the value of the species density in the primitive variable vector.
     * iRho_s
     */
    unsigned short GetAIndex(void);
    
    /*!
     * \brief Retrieves the value of the species density in the primitive variable vector.
     * iRho_s
     */
    unsigned short GetRhoCvtrIndex(void);
    
    /*!
     * \brief Retrieves the value of the species density in the primitive variable vector.
     * iRho_s
     */
    unsigned short GetRhoCvveIndex(void);
    
};

/*!
 * \class CTNE2NSVariable
 * \brief Main class for defining the variables of the TNE2 Navier-Stokes' solver.
 * \ingroup Navier_Stokes_Equations
 * \author S. R. Copeland, F. Palacios
 * \version 2.0.6
 */
class CTNE2NSVariable : public CTNE2EulerVariable {
private:
    double Prandtl_Lam;       /*!< \brief Laminar Prandtl number. */
    double Temperature_Ref;   /*!< \brief Reference temperature of the fluid. */
    double Viscosity_Ref;     /*!< \brief Reference viscosity of the fluid. */
    double Viscosity_Inf;     /*!< \brief Viscosity of the fluid at the infinity. */
    double *DiffusionCoeff;    /*!< \brief Diffusion coefficient of the mixture. */
    double LaminarViscosity;	/*!< \brief Viscosity of the fluid. */
    double ThermalCond;       /*!< \brief T-R thermal conductivity of the gas mixture. */
    double ThermalCond_ve;    /*!< \brief V-E thermal conductivity of the gas mixture. */
    double Vorticity[3];		/*!< \brief Vorticity of the fluid. */
    
public:
    
    /*!
     * \brief Constructor of the class.
     */
    CTNE2NSVariable(void);
    
    
    /*!
     * \overload
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nvar - Number of conserved variables.
     * \param[in] val_nprimvar - Number of primitive variables.
     * \param[in] val_nprimvargrad - Number of primitive gradient variables.
     * \param[in] config - Definition of the particular problem.
     */
    CTNE2NSVariable(unsigned short val_nDim, unsigned short val_nvar,
                    unsigned short val_nprimvar, unsigned short val_nprimvargrad,
                    CConfig *config);
    
    /*!
     * \overload
     * \param[in] val_density - Value of the flow density (initialization value).
     * \param[in] val_massfrac -
     * \param[in] val_velocity - Value of the flow velocity (initialization value).
     * \param[in] val_temperature -
     * \param[in] val_temperature_ve -
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nvar - Number of conserved variables.
     * \param[in] val_nvarprim - Number of primitive variables.
     * \param[in] val_nvarprimgrad - Number of primitive gradient variables.
     * \param[in] config - Definition of the particular problem.
     */
    CTNE2NSVariable(double val_density, double *val_massfrac, double *val_velocity,
                    double val_temperature, double val_temperature_ve, unsigned short val_nDim,
                    unsigned short val_nvar, unsigned short val_nvarprim,
                    unsigned short val_nvarprimgrad, CConfig *config);
    
    /*!
     * \overload
     * \param[in] val_solution - Pointer to the flow value (initialization value).
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nvar - Number of conserved variables.
     * \param[in] val_nvarprim - Number of primitive variables.
     * \param[in] val_nvarprimgrad - Number of primitive gradient variables.
     * \param[in] config - Definition of the particular problem.
     */
    CTNE2NSVariable(double *val_solution, unsigned short val_nDim, unsigned short val_nvar,
                    unsigned short val_nvarprim, unsigned short val_nvarprimgrad,
                    CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CTNE2NSVariable(void);
    
    /*!
     * \brief Set the laminar viscosity.
     */
    void SetDiffusionCoeff(CConfig *config);
    
    /*!
     * \brief Set the laminar viscosity.
     */
    void SetLaminarViscosity(CConfig *config);
    
    /*!
     * \brief Get the laminar viscosity of the flow.
     * \return Value of the laminar viscosity of the flow.
     */
    void SetThermalConductivity(CConfig *config);
    
    /*!
     * \brief Set the vorticity value.
     */
    bool SetVorticity(bool val_limiter);
    
    /*!
     * \brief Get the species diffusion coefficient.
     * \return Value of the species diffusion coefficient.
     */
    double* GetDiffusionCoeff(void);
    
    /*!
     * \brief Get the laminar viscosity of the flow.
     * \return Value of the laminar viscosity of the flow.
     */
    double GetLaminarViscosity(void);
    
    /*!
     * \brief Get the thermal conductivity of the flow.
     * \return Value of the laminar viscosity of the flow.
     */
    double GetThermalConductivity(void);
    
    /*!
     * \brief Get the vib-el. thermal conductivity of the flow.
     * \return Value of the laminar viscosity of the flow.
     */
    double GetThermalConductivity_ve(void);
    
    /*!
     * \brief Set the temperature at the wall
     */
    void SetWallTemperature(double temperature_wall);
    
    /*!
     * \brief Get the value of the vorticity.
     * \param[in] val_dim - Index of the dimension.
     * \return Value of the vorticity.
     */
    double *GetVorticity(void);
    
    /*!
     * \brief Set all the primitive variables for compressible flows
     */
    bool SetPrimVar_Compressible(CConfig *config);
    
};


/*!
 * \class CAdjTNE2EulerVariable
 * \brief Main class for defining the variables of the adjoint Euler solver.
 * \ingroup Euler_Equations
 * \author F. Palacios
 * \version 2.0.6
 */
class CAdjTNE2EulerVariable : public CVariable {
protected:
    unsigned short nSpecies;
    double *Psi;		/*!< \brief Vector of the adjoint variables. */
    double *ForceProj_Vector;	/*!< \brief Vector d. */
    double *ObjFuncSource;    /*!< \brief Vector containing objective function sensitivity for discrete adjoint. */
    double *IntBoundary_Jump;	/*!< \brief Interior boundary jump vector. */
    double *TS_Source;		/*!< \brief Time spectral source term. */
    double Theta;		/*!< \brief Theta variable. */
    bool incompressible;
public:
    
    /*!
     * \brief Constructor of the class.
     */
    CAdjTNE2EulerVariable(void);
    
    /*!
     * \overload
     * \param[in] val_psirho - Value of the adjoint density (initialization value).
     * \param[in] val_phi - Value of the adjoint velocity (initialization value).
     * \param[in] val_psie - Value of the adjoint energy (initialization value).
     * \param[in] val_psieve - Value of the adjoint vibrational energy (initialization value).
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nvar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CAdjTNE2EulerVariable(double *val_psirho, double *val_phi,
                          double val_psie, double val_psieve,
                          unsigned short val_nDim, unsigned short val_nvar,
                          CConfig *config);
    
    /*!
     * \overload
     * \param[in] val_solution - Pointer to the adjoint value (initialization value).
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nvar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CAdjTNE2EulerVariable(double *val_solution, unsigned short val_nDim, unsigned short val_nvar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    virtual ~CAdjTNE2EulerVariable(void);
    
    /*!
     * \brief Set all the primitive variables for compressible flows.
     */
    bool SetPrimVar_Compressible(double SharpEdge_Distance,
                                 bool check,
                                 CConfig *config);
    
    /*!
     * \brief Set the value of the adjoint velocity.
     * \param[in] val_phi - Value of the adjoint velocity.
     */
    void SetPhi_Old(double *val_phi);
    
    /*!
     * \brief Get the value of theta.
     */
    double GetTheta(void);
    
    /*!
     * \brief Set the value of the force projection vector.
     * \param[in] val_ForceProj_Vector - Pointer to the force projection vector.
     */
    void SetForceProj_Vector(double *val_ForceProj_Vector);
    
    /*!
     * \brief Set the value of the objective function source.
     * \param[in] val_SetObjFuncSource - Pointer to the objective function source.
     */
    void SetObjFuncSource(double *val_SetObjFuncSource);
    
    /*!
     * \brief Get the value of the force projection vector.
     * \return Pointer to the force projection vector.
     */
    double *GetForceProj_Vector(void);
    
    /*!
     * \brief Get the value of the objective function source.
     * \param[in] val_SetObjFuncSource - Pointer to the objective function source.
     */
    double *GetObjFuncSource(void);
    
};

/*!
 * \class CAdjNSVariable
 * \brief Main class for defining the variables of the adjoint Navier-Stokes solver.
 * \ingroup Navier_Stokes_Equations
 * \author S. R. Copeland, F. Palacios
 * \version 2.0.6
 */
class CAdjTNE2NSVariable : public CAdjTNE2EulerVariable {
private:
    
public:
    
    /*!
     * \brief Constructor of the class.
     */
    CAdjTNE2NSVariable(void);
    
    /*!
     * \overload
     * \param[in] val_psirho - Value of the adjoint density (initialization value).
     * \param[in] val_phi - Value of the adjoint velocity (initialization value).
     * \param[in] val_psie - Value of the adjoint energy (initialization value).
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nvar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CAdjTNE2NSVariable(double *val_psirho, double *val_phi,
                       double val_psie, double val_psieve,
                       unsigned short val_nDim, unsigned short val_nvar,
                       CConfig *config);
    
    /*!
     * \overload
     * \param[in] val_solution - Pointer to the adjoint value (initialization value).
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nvar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CAdjTNE2NSVariable(double *val_solution, unsigned short val_nDim, unsigned short val_nvar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CAdjTNE2NSVariable(void);
    
    /*!
     * \brief Set the value of the adjoint velocity.
     * \param[in] val_phi - Value of the adjoint velocity.
     */
    void SetPhi_Old(double *val_phi);
    
    /*!
     * \brief Get the value of theta.
     */
    double GetTheta(void);
    
    /*!
     * \brief Set the value of the force projection vector.
     * \param[in] val_ForceProj_Vector - Pointer to the force projection vector.
     */
    void SetForceProj_Vector(double *val_ForceProj_Vector);
    
    /*!
     * \brief Get the value of the force projection vector.
     * \return Pointer to the force projection vector.
     */
    double *GetForceProj_Vector(void);
    
    /*!
     * \brief Set the value of the force projection vector on the solution vector.
     */
    void SetVelSolutionOldDVector(void);
    
    /*!
     * \brief Set the value of the force projection vector on the old solution vector.
     */
    void SetVelSolutionDVector(void);
    
};


/*! 
 * \class CTemplateVariable
 * \brief Main class for defining the variables of the potential solver.
 * \ingroup Potential_Flow_Equation
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CTemplateVariable : public CVariable {
public:
    
    /*!
     * \brief Constructor of the class. 
     */
    CTemplateVariable(void);
    
    /*!
     * \overload
     * \param[in] val_potential - Value of the potential solution (initialization value).		 
     * \param[in] val_nDim - Number of dimensions of the problem.		 
     * \param[in] val_nvar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.	 
     */	
    CTemplateVariable(double val_potential, unsigned short val_nDim, unsigned short val_nvar, CConfig *config);
    
    /*!
     * \brief Destructor of the class. 
     */	
    ~CTemplateVariable(void);
};



/* numerics_machine_learning_turbulent.hpp------------------------------------------------------------
 *
 *
 *
 */

class SpalartAllmarasOtherOutputs{
public:
    SpalartAllmarasOtherOutputs();
    ~SpalartAllmarasOtherOutputs();
    
};

class SpalartAllmarasConstants{
public:
    SpalartAllmarasConstants();
    ~SpalartAllmarasConstants();
    
};

class SpalartAllmarasInputs{
private:
    
    void init(int nDim, double limiter);
public:
    SpalartAllmarasInputs(int nDim);
    SpalartAllmarasInputs(int nDim, double limiter);
    ~SpalartAllmarasInputs();
    void Set(double** DUiDXj, double* DTurb_Kin_Visc_DXj, bool rotating_frame, bool transition, double dist, double Laminar_Viscosity, double Density, double Turbulent_Kinematic_Viscosity, double intermittency);
    int GetNumDim();
    double GetLimiter();
    double** GetMeanFlowGradient();
    double* GetTurbKinViscGradient();
    
};


void SpalartAllmarasSourceTerm(SpalartAllmarasInputs* inputs, SpalartAllmarasConstants* constants, double* output_residual, double* output_jacobian, SpalartAllmarasOtherOutputs* otherOutput);

double ComputeVorticity(int nDim, double** DUiDXj);


/* numerics_machine_learning.hpp------------------------------------------------------------
 *
 *
 *
 */

class CScaler{
public:
    CScaler();
    virtual ~CScaler();
    virtual void Scale(double *) = 0;
    virtual void Unscale(double *) = 0;
};

class CNormalScaler: public CScaler{
private:
    double * mu;
    double * sigma;
    int dim;
    
public:
    CNormalScaler();
    CNormalScaler(int,double*,double*);
#ifdef HAVE_JSONCPP
    CNormalScaler(Json::Value);
#endif
    ~CNormalScaler();
    void Scale(double *);
    void Unscale(double *);
};

class CMulInputScaler : public CScaler{
public:
    double MulScale;
    CScaler* InnerScaler;
    CMulInputScaler();
#ifdef HAVE_JSONCPP
    CMulInputScaler(Json::Value);
#endif
    ~CMulInputScaler();
    void Scale(double *);
    void Unscale(double *);
};

class CMulOutputScaler : public CScaler{
public:
    double MulScale;
    CMulOutputScaler();
#ifdef HAVE_JSONCPP
    CMulOutputScaler(Json::Value);
#endif
    ~CMulOutputScaler();
    void Scale(double *);
    void Unscale(double *);
    
};

class CActivator{
public:
    CActivator();
    ~CActivator();
    virtual double Activate(double combination){cout<< "IN BASE ACTIVATOR THIS IS BAD" <<endl; return 0;};
};

class CTanhActivator : public CActivator{
public:
    CTanhActivator();
#ifdef HAVE_JSONCPP
    CTanhActivator(Json::Value);
#endif
    ~CTanhActivator();
    double Activate(double combination);
};

class CLinearActivator : public CActivator{
public:
    CLinearActivator();
#ifdef HAVE_JSONCPP
    CLinearActivator(Json::Value);
#endif
    ~CLinearActivator();
    double Activate(double combination);
};

class CNeuron{
public:
    CNeuron();
    ~CNeuron();
    virtual double Activate(double combination){cout << "In base neuron. Bad";return 0;};
    virtual double Combine(double * parameters, int nParameters, double *inputs, int nInputs){cout << "In base neuron. Bad";return 0;};
};

class CSumNeuron : public CNeuron{
private:
    CActivator *activator;
public:
    CSumNeuron();
    CSumNeuron(CActivator*); // activator, parameterStart, nParameters
#ifdef HAVE_JSONCPP
    CSumNeuron(Json::Value);
#endif
    ~CSumNeuron();
    //Activator* GetActivator(void);
    double Combine(double * parameters, int nParameters, double * inputs, int nInputs);
    double Activate(double combination);
};


class CPredictor{
protected:
    int inputDim;
    int outputDim;
public:
    CPredictor();
    virtual  ~CPredictor();
    virtual void Predict(double *, double *){cout << "In base Predict, this is bad";};
    int InputDim();
    int OutputDim();
};

class CScalePredictor{
public:
    CScalePredictor();
    CScalePredictor(string filename);
    ~CScalePredictor();
    CPredictor *Pred;
    CScaler *InputScaler;
    CScaler *OutputScaler;
public:
    void Predict(double *inputs, double *outputs);
    // Need to add predict method
};

class CMulPredictor : public CPredictor{
public:
    CMulPredictor();
#ifdef HAVE_JSONCPP
    CMulPredictor(Json::Value);
#endif
    ~CMulPredictor();
    CPredictor* Inner;
    void Predict(double *, double *);
    
};

class CNeurNet : public CPredictor {
private:
    
    //  int inputDim;
    
    void processLayer(double *, int,CNeuron **, double **, int, int * ,double *);
    
    //----
    //	int outputDim;
    
public:
    CNeurNet();
#ifdef HAVE_JSONCPP
    CNeurNet(Json::Value);
#endif
    ~CNeurNet();
    //	int InputDim();
    //	int OutputDim();
    void Predict(double *, double *);
    
};

class CSANondimInputs{
private:
    int nDim;
public:
    CSANondimInputs(int);
    ~CSANondimInputs();
    void Set(SpalartAllmarasInputs*);
    void NondimensionalizeSource(int,double*);
    void DimensionalizeSource(int,double*);
    
};



/* numerics_structure.hpp------------------------------------------------------------
 *
 *
 *
 */

/*!
 * \class CNumerics
 * \brief Class for defining the numerical methods.
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CNumerics {
protected:
    unsigned short nDim, nVar;	/*!< \brief Number of dimensions and variables. */
    unsigned short nSpecies; 	/*!< \brief No of species present in plasma */
    double Gamma;				/*!< \brief Fluid's Gamma constant (ratio of specific heats). */
    double Gamma_Minus_One;		/*!< \brief Fluids's Gamma - 1.0  . */
    double Gas_Constant;		 		/*!< \brief Gas constant. */
    double *Vector; /*!< \brief Auxiliary vector. */
    double *Enthalpy_formation;
    unsigned short nDiatomics, nMonatomics;
    double Prandtl_Lam;				/*!< \brief Laminar Prandtl's number. */
    double Prandtl_Turb;		/*!< \brief Turbulent Prandtl's number. */
    
public:
    
    double
    **Flux_Tensor,	/*!< \brief Flux tensor (used for viscous and inviscid purposes. */
    *Proj_Flux_Tensor;		/*!< \brief Flux tensor projected in a direction. */
    
    double
    **tau,		/*!< \brief Viscous stress tensor. */
    **delta;			/*!< \brief Identity matrix. */
    double **dVdU; /*!< \brief Transformation matrix from primitive variables, V, to conserved, U. */
    double
    *Diffusion_Coeff_i, /*!< \brief Species diffusion coefficients at point i. */
    *Diffusion_Coeff_j; /*!< \brief Species diffusion coefficients at point j. */
    double Laminar_Viscosity_i,	/*!< \brief Laminar viscosity at point i. */
    Laminar_Viscosity_j,		/*!< \brief Laminar viscosity at point j. */
    Laminar_Viscosity_id,	/*!< \brief Variation of laminar viscosity at point i. */
    Laminar_Viscosity_jd;		/*!< \brief Variation of laminar viscosity at point j. */
    double Thermal_Conductivity_i, /*!< \brief Thermal conductivity at point i. */
    Thermal_Conductivity_j, /*!< \brief Thermal conductivity at point j. */
    Thermal_Conductivity_ve_i, /*!< \brief Thermal conductivity at point i. */
    Thermal_Conductivity_ve_j; /*!< \brief Thermal conductivity at point j. */
    double Cp_i, /*!< \brief Cp at point i. */
    Cp_j;         /*!< \brief Cp at point j. */
    double *Theta_v; /*!< \brief Characteristic vibrational temperature */
    double Eddy_Viscosity_i,	/*!< \brief Eddy viscosity at point i. */
    Eddy_Viscosity_j;			/*!< \brief Eddy viscosity at point j. */
    double turb_ke_i,	/*!< \brief Turbulent kinetic energy at point i. */
    turb_ke_j;			/*!< \brief Turbulent kinetic energy at point j. */
    double Pressure_i,	/*!< \brief Pressure at point i. */
    Pressure_j;			/*!< \brief Pressure at point j. */
    double GravityForce_i,	/*!< \brief Gravity force at point i. */
    GravityForce_j;			/*!< \brief Gravity force at point j. */
    double Density_i,	/*!< \brief Density at point i. */
    Density_j;			/*!< \brief Density at point j. */
    double DensityInc_i,	/*!< \brief Incompressible density at point i. */
    DensityInc_j;			/*!< \brief Incompressible density at point j. */
    double BetaInc2_i,	/*!< \brief Beta incompressible at point i. */
    BetaInc2_j;			/*!< \brief Beta incompressible at point j. */
    double Lambda_i,	/*!< \brief Spectral radius at point i. */
    Lambda_j;			/*!< \brief Spectral radius at point j. */
    double LambdaComb_i,	/*!< \brief Spectral radius at point i. */
    LambdaComb_j;			/*!< \brief Spectral radius at point j. */
    double SoundSpeed_i,	/*!< \brief Sound speed at point i. */
    SoundSpeed_j;			/*!< \brief Sound speed at point j. */
    double Enthalpy_i,	/*!< \brief Enthalpy at point i. */
    Enthalpy_j;			/*!< \brief Enthalpy at point j. */
    double dist_i,	/*!< \brief Distance of point i to the nearest wall. */
    dist_j;			/*!< \brief Distance of point j to the nearest wall. */
    double Temp_i,	/*!< \brief Temperature at point i. */
    Temp_j;			/*!< \brief Temperature at point j. */
    double *Temp_tr_i, /*!< \brief Temperature transl-rot at point i. */
    *Temp_tr_j;/*!< \brief Temperature transl-rot at point j. */
    double *Temp_vib_i, /*!< \brief Temperature vibrational at point i. */
    *Temp_vib_j;/*!< \brief Temperature vibrational at point j. */
    double *Und_Lapl_i, /*!< \brief Undivided laplacians at point i. */
    *Und_Lapl_j;		/*!< \brief Undivided laplacians at point j. */
    double Sensor_i,	/*!< \brief Pressure sensor at point i. */
    Sensor_j;			/*!< \brief Pressure sensor at point j. */
    double *GridVel_i,	/*!< \brief Grid velocity at point i. */
    *GridVel_j;			/*!< \brief Grid velocity at point j. */
    double *U_i,		/*!< \brief Vector of conservative variables at point i. */
    *U_id,		/*!< \brief Vector of derivative of conservative variables at point i. */
    *UZeroOrder_i,  /*!< \brief Vector of conservative variables at point i without reconstruction. */
    *U_j,				/*!< \brief Vector of conservative variables at point j. */
    *UZeroOrder_j,  /*!< \brief Vector of conservative variables at point j without reconstruction. */
    *U_jd,				/*!< \brief Vector of derivative of conservative variables at point j. */
    *U_0,				/*!< \brief Vector of conservative variables at node 0. */
    *U_1,				/*!< \brief Vector of conservative variables at node 1. */
    *U_2,				/*!< \brief Vector of conservative variables at node 2. */
    *U_3;				/*!< \brief Vector of conservative variables at node 3. */
    double *V_i,		/*!< \brief Vector of primitive variables at point i. */
    *V_j;				/*!< \brief Vector of primitive variables at point j. */
    double *S_i,		/*!< \brief Vector of secondary variables at point i. */
    *S_j;				/*!< \brief Vector of secondary variables at point j. */
    double *Psi_i,		/*!< \brief Vector of adjoint variables at point i. */
    *Psi_j;				/*!< \brief Vector of adjoint variables at point j. */
    double *DeltaU_i,	/*!< \brief Vector of linearized variables at point i. */
    *DeltaU_j;			/*!< \brief Vector of linearized variables at point j. */
    double *TurbVar_i,	/*!< \brief Vector of turbulent variables at point i. */
    *TurbVar_id,	/*!< \brief Vector of derivative of turbulent variables at point i. */
    *TurbVar_j,			/*!< \brief Vector of turbulent variables at point j. */
    *TurbVar_jd;	/*!< \brief Vector of derivative of turbulent variables at point j. */
    double *TransVar_i,	/*!< \brief Vector of turbulent variables at point i. */
    *TransVar_j;			/*!< \brief Vector of turbulent variables at point j. */
    double *LevelSetVar_i,	/*!< \brief Vector of turbulent variables at point i. */
    *LevelSetVar_j;			/*!< \brief Vector of turbulent variables at point j. */
    double *TurbPsi_i,	/*!< \brief Vector of adjoint turbulent variables at point i. */
    *TurbPsi_j;			/*!< \brief Vector of adjoint turbulent variables at point j. */
    double **ConsVar_Grad_i,	/*!< \brief Gradient of conservative variables at point i. */
    **ConsVar_Grad_j,			/*!< \brief Gradient of conservative variables at point j. */
    **ConsVar_Grad_0,			/*!< \brief Gradient of conservative variables at point 0. */
    **ConsVar_Grad_1,			/*!< \brief Gradient of conservative variables at point 1. */
    **ConsVar_Grad_2,			/*!< \brief Gradient of conservative variables at point 2. */
    **ConsVar_Grad_3,			/*!< \brief Gradient of conservative variables at point 3. */
    **ConsVar_Grad;				/*!< \brief Gradient of conservative variables which is a scalar. */
    double **PrimVar_Grad_i,	/*!< \brief Gradient of primitive variables at point i. */
    **PrimVar_Grad_j;			/*!< \brief Gradient of primitive variables at point j. */
    double *PrimVar_Lim_i,	/*!< \brief Limiter of primitive variables at point i. */
    *PrimVar_Lim_j;			/*!< \brief Limiter of primitive variables at point j. */
    double *PsiVar_Lim_i,		/*!< \brief Limiter of adjoint variables at point i. */
    *PsiVar_Lim_j;			/*!< \brief Limiter of adjoint variables at point j. */
    double **PsiVar_Grad_i,		/*!< \brief Gradient of adjoint variables at point i. */
    **PsiVar_Grad_j;			/*!< \brief Gradient of adjoint variables at point j. */
    double **TurbVar_Grad_i,	/*!< \brief Gradient of turbulent variables at point i. */
    **TurbVar_Grad_j;			/*!< \brief Gradient of turbulent variables at point j. */
    double **TransVar_Grad_i,	/*!< \brief Gradient of turbulent variables at point i. */
    **TransVar_Grad_j;			/*!< \brief Gradient of turbulent variables at point j. */
    double **LevelSetVar_Grad_i,	/*!< \brief Gradient of level set variables at point i. */
    **LevelSetVar_Grad_j;			/*!< \brief Gradient of level set variables at point j. */
    double **TurbPsi_Grad_i,	/*!< \brief Gradient of adjoint turbulent variables at point i. */
    **TurbPsi_Grad_j;			/*!< \brief Gradient of adjoint turbulent variables at point j. */
    double *AuxVar_Grad_i,		/*!< \brief Gradient of an auxiliary variable at point i. */
    *AuxVar_Grad_j;				/*!< \brief Gradient of an auxiliary variable at point i. */
    double *Coord_i,	/*!< \brief Cartesians coordinates of point i. */
    *Coord_j,			/*!< \brief Cartesians coordinates of point j. */
    *Coord_0,			/*!< \brief Cartesians coordinates of point 0 (Galerkin method, triangle). */
    *Coord_1,			/*!< \brief Cartesians coordinates of point 1 (Galerkin method, tetrahedra). */
    *Coord_2,			/*!< \brief Cartesians coordinates of point 2 (Galerkin method, triangle). */
    *Coord_3;			/*!< \brief Cartesians coordinates of point 3 (Galerkin method, tetrahedra). */
    unsigned short Neighbor_i,	/*!< \brief Number of neighbors of the point i. */
    Neighbor_j;					/*!< \brief Number of neighbors of the point j. */
    double *Normal,	/*!< \brief Normal vector, it norm is the area of the face. */
    *UnitNormal,		/*!< \brief Unitary normal vector. */
    *UnitNormald;		/*!< \brief derivatve of unitary normal vector. */
    double TimeStep,		/*!< \brief Time step useful in dual time method. */
    Area,				/*!< \brief Area of the face i-j. */
    Volume;				/*!< \brief Volume of the control volume around point i. */
    double Volume_n,	/*!< \brief Volume of the control volume at time n. */
    Volume_nM1,		/*!< \brief Volume of the control volume at time n-1. */
    Volume_nP1;		/*!< \brief Volume of the control volume at time n+1. */
    double *U_n,	/*!< \brief Vector of conservative variables at time n. */
    *U_nM1,		/*!< \brief Vector of conservative variables at time n-1. */
    *U_nP1;		/*!< \brief Vector of conservative variables at time n+1. */
    double vel2_inf; /*!< \brief value of the square of freestream speed. */
    double *WindGust_i,	/*!< \brief Wind gust at point i. */
    *WindGust_j;			/*!< \brief Wind gust at point j. */
    double *WindGustDer_i,	/*!< \brief Wind gust derivatives at point i. */
    *WindGustDer_j;			/*!< \brief Wind gust derivatives at point j. */
    double *Vorticity_i, *Vorticity_j;  /*!< \brief Vorticity. */
    double StrainMag_i, StrainMag_j;   /*!< \brief Strain rate magnitude. */
    
    double *l, *m;
    double *dPdU_i, *dPdU_j;
    double *dTdU_i, *dTdU_j;
    double *dTvedU_i, *dTvedU_j;
    double *Ys, **dFdYj, **dFdYi, *sumdFdYih, *sumdFdYjh, *sumdFdYieve, *sumdFdYjeve;
    unsigned short RHOS_INDEX, T_INDEX, TVE_INDEX, VEL_INDEX, P_INDEX,
    RHO_INDEX, H_INDEX, A_INDEX, RHOCVTR_INDEX, RHOCVVE_INDEX;
    CVariable *var;
    
    /*!
     * \brief Constructor of the class.
     */
    CNumerics(void);
    
    /*!
     * \overload
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CNumerics(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    virtual ~CNumerics(void);
    
    /*!
     * \brief Compute the determinant of a 3 by 3 matrix.
     * \param[in] val_matrix 3 by 3 matrix.
     * \result Determinant of the matrix
     */
    double Determinant_3x3(double A00, double A01, double A02,
                           double A10, double A11, double A12,
                           double A20, double A21, double A22);
    
    /*!
     * \brief Set the solution at different times.
     * \param[in] val_u_nM1 Conservative solution at time n-1.
     * \param[in] val_u_n Conservative solution at time n.
     * \param[in] val_u_nP1 Conservative solution at time n+1.
     */
    void SetPastSol(double *val_u_nM1, double *val_u_n, double *val_u_nP1);
    
    /*!
     * \brief Set the control volume at different times.
     * \param[in] val_volume_nM1 - Control volume at time n-1.
     * \param[in] val_volume_n - Control volume at time n.
     * \param[in] val_volume_nP1 - Control volume at time n+1.
     */
    void SetPastVolume(double val_volume_nM1, double val_volume_n, double val_volume_nP1);
    
    /*!
     * \brief Set the time step.
     * \param[in] val_timestep - Value of the time step.
     */
    void SetTimeStep(double val_timestep);
    
    /*!
     * \brief Get the Preconditioning Beta.
     * \return val_Beta - Value of the low Mach Preconditioner.
     */
    virtual double GetPrecond_Beta();
    
    /*!
     * \brief Set the freestream velocity square.
     * \param[in] SetVelocity2_Inf - Value of the square of the freestream velocity.
     */
    void SetVelocity2_Inf(double val_velocity2);
    
    /*!
     * \brief Set the value of the vorticity
     * \param[in] val_vorticity - Value of the vorticity.
     */
    void SetVorticity(double *val_vorticity_i, double *val_vorticity_j);
    
    /*!
     * \brief Set the value of the rate of strain magnitude.
     * \param[in] val_StrainMag_i - Value of the magnitude of rate of strain at point i.
     * \param[in] val_StrainMag_j - Value of the magnitude of rate of strain at point j.
     */
    void SetStrainMag(double val_strainmag_i, double val_strainmag_j);
    
    /*!
     * \brief Set the value of the conservative variables.
     * \param[in] val_u_i - Value of the conservative variable at point i.
     * \param[in] val_u_j - Value of the conservative variable at point j.
     */
    void SetConservative(double *val_u_i, double *val_u_j);
    
    /*!
     * \brief Set the value of the conservative variables withour reconstruction.
     * \param[in] val_u_i - Value of the conservative variable at point i.
     * \param[in] val_u_j - Value of the conservative variable at point j.
     */
    void SetConservative_ZeroOrder(double *val_u_i, double *val_u_j);
    
    /*!
     * \brief Set the value of the primitive variables.
     * \param[in] val_v_i - Value of the primitive variable at point i.
     * \param[in] val_v_j - Value of the primitive variable at point j.
     */
    void SetPrimitive(double *val_v_i, double *val_v_j);
    
    /*!
     * \brief Set the value of the primitive variables.
     * \param[in] val_v_i - Value of the primitive variable at point i.
     * \param[in] val_v_j - Value of the primitive variable at point j.
     */
    void SetSecondary(double *val_s_i, double *val_s_j);
    
    /*!
     * \brief Set the value of the conservative variables.
     * \param[in] val_u_0 - Value of the conservative variable at point 0.
     * \param[in] val_u_1 - Value of the conservative variable at point 1.
     * \param[in] val_u_2 - Value of the conservative variable at point 2.
     */
    void SetConservative(double *val_u_0, double *val_u_1, double *val_u_2);
    
    /*!
     * \brief Set the value of the conservative variables.
     * \param[in] val_u_0 - Value of the conservative variable at point 0.
     * \param[in] val_u_1 - Value of the conservative variable at point 1.
     * \param[in] val_u_2 - Value of the conservative variable at point 2.
     * \param[in] val_u_3 - Value of the conservative variable at point 3.
     */
    void SetConservative(double *val_u_0, double *val_u_1, double *val_u_2, double *val_u_3);
    
    /*!
     * \brief Set the gradient of the conservative variables.
     * \param[in] val_consvar_grad_i - Gradient of the conservative variable at point i.
     * \param[in] val_consvar_grad_j - Gradient of the conservative variable at point j.
     */
    void SetConsVarGradient(double **val_consvar_grad_i, double **val_consvar_grad_j);
    
    /*!
     * \brief Set the gradient of the conservative variables.
     * \param[in] val_consvar_grad_0 - Gradient of the conservative variable at point 0.
     * \param[in] val_consvar_grad_1 - Gradient of the conservative variable at point 1.
     * \param[in] val_consvar_grad_2 - Gradient of the conservative variable at point 2.
     */
    void SetConsVarGradient(double **val_consvar_grad_0,
                            double **val_consvar_grad_1,
                            double **val_consvar_grad_2);
    
    /*!
     * \brief Set the gradient of the conservative variables.
     * \param[in] val_consvar_grad_0 - Gradient of the conservative variable at point 0.
     * \param[in] val_consvar_grad_1 - Gradient of the conservative variable at point 1.
     * \param[in] val_consvar_grad_2 - Gradient of the conservative variable at point 2.
     * \param[in] val_consvar_grad_3 - Gradient of the conservative variable at point 3.
     */
    void SetConsVarGradient(double **val_consvar_grad_0,
                            double **val_consvar_grad_1,
                            double **val_consvar_grad_2,
                            double **val_consvar_grad_3);
    
    /*!
     * \brief Set the gradient of the conservative variables.
     * \param[in] val_consvar_grad - Gradient of the conservative variable which is a scalar.
     */
    void SetConsVarGradient(double **val_consvar_grad);
    
    /*!
     * \brief Set the gradient of the primitive variables.
     * \param[in] val_primvar_grad_i - Gradient of the primitive variable at point i.
     * \param[in] val_primvar_grad_j - Gradient of the primitive variable at point j.
     */
    void SetPrimVarGradient(double **val_primvar_grad_i,
                            double **val_primvar_grad_j);
    
    /*!
     * \brief Set the Limiter of the primitive variables.
     * \param[in] val_primvar_lim_i - Limiter of the primitive variable at point i.
     * \param[in] val_primvar_lim_j - Limiter of the primitive variable at point j.
     */
    void SetPrimVarLimiter(double *val_primvar_lim_i,
                           double *val_primvar_lim_j);
    
    /*!
     * \brief Set the value of the adjoint variable.
     * \param[in] val_psi_i - Value of the adjoint variable at point i.
     * \param[in] val_psi_j - Value of the adjoint variable at point j.
     */
    void SetAdjointVar(double *val_psi_i, double *val_psi_j);
    
    /*!
     * \brief Set the value of the linearized conservative variables.
     * \param[in] val_deltau_i - Value of the linearized conservative variable at point i.
     * \param[in] val_deltau_j - Value of the linearized conservative variable at point j.
     */
    void SetLinearizedVar(double *val_deltau_i, double *val_deltau_j);
    
    /*!
     * \brief Set the gradient of the adjoint variables.
     * \param[in] val_psivar_grad_i - Gradient of the adjoint variable at point i.
     * \param[in] val_psivar_grad_j - Gradient of the adjoint variable at point j.
     */
    void SetAdjointVarGradient(double **val_psivar_grad_i, double **val_psivar_grad_j);
    
    /*!
     * \brief Set the limiter of the adjoint variables.
     * \param[in] val_psivar_lim_i - Gradient of the adjoint variable at point i.
     * \param[in] val_psivar_lim_j - Gradient of the adjoint variable at point j.
     */
    void SetAdjointVarLimiter(double *val_psivar_lim_i, double *val_psivar_lim_j);
    
    /*!
     * \brief Set the value of the turbulent variable.
     * \param[in] val_turbvar_i - Value of the turbulent variable at point i.
     * \param[in] val_turbvar_j - Value of the turbulent variable at point j.
     */
    void SetTurbVar(double *val_turbvar_i, double *val_turbvar_j);
    
    /*!
     * \brief Set the value of the turbulent variable.
     * \param[in] val_transvar_i - Value of the turbulent variable at point i.
     * \param[in] val_transvar_j - Value of the turbulent variable at point j.
     */
    void SetTransVar(double *val_transvar_i, double *val_transvar_j);
    
    /*!
     * \brief Set the gradient of the turbulent variables.
     * \param[in] val_turbvar_grad_i - Gradient of the turbulent variable at point i.
     * \param[in] val_turbvar_grad_j - Gradient of the turbulent variable at point j.
     */
    void SetTurbVarGradient(double **val_turbvar_grad_i, double **val_turbvar_grad_j);
    
    /*!
     * \brief Set the gradient of the turbulent variables.
     * \param[in] val_turbvar_grad_i - Gradient of the turbulent variable at point i.
     * \param[in] val_turbvar_grad_j - Gradient of the turbulent variable at point j.
     */
    void SetTransVarGradient(double **val_transvar_grad_i, double **val_transvar_grad_j);
    
    /*!
     * \brief Set the value of the level set variable.
     * \param[in] val_levelsetvar_i - Value of the level set variable at point i.
     * \param[in] val_levelsetvar_j - Value of the level set variable at point j.
     */
    void SetLevelSetVar(double *val_levelsetvar_i, double *val_levelsetvar_j);
    
    /*!
     * \brief Set the gradient of the level set variables.
     * \param[in] val_levelsetvar_grad_i - Gradient of the level set variable at point i.
     * \param[in] val_levelsetvar_grad_j - Gradient of the level set variable at point j.
     */
    void SetLevelSetVarGradient(double **val_levelsetvar_grad_i, double **val_levelsetvar_grad_j);
    
    /*!
     * \brief Set the value of the adjoint turbulent variable.
     * \param[in] val_turbpsivar_i - Value of the adjoint turbulent variable at point i.
     * \param[in] val_turbpsivar_j - Value of the adjoint turbulent variable at point j.
     */
    void SetTurbAdjointVar(double *val_turbpsivar_i, double *val_turbpsivar_j);
    
    /*!
     * \brief Set the gradient of the adjoint turbulent variables.
     * \param[in] val_turbpsivar_grad_i - Gradient of the adjoint turbulent variable at point i.
     * \param[in] val_turbpsivar_grad_j - Gradient of the adjoint turbulent variable at point j.
     */
    void SetTurbAdjointGradient (double **val_turbpsivar_grad_i, double **val_turbpsivar_grad_j);
    
    /*!
     * \brief Set the value of the first blending function.
     * \param[in] val_F1_i - Value of the first Menter blending function at point i.
     * \param[in] val_F1_j - Value of the first Menter blending function at point j.
     */
    virtual void SetF1blending(double val_F1_i, double val_F1_j) {/* empty */};
    
    /*!
     * \brief Set the value of the second blending function.
     * \param[in] val_F1_i - Value of the second Menter blending function at point i.
     * \param[in] val_F1_j - Value of the second Menter blending function at point j.
     */
    virtual void SetF2blending(double val_F1_i, double val_F1_j) {/* empty */};
    
    /*!
     * \brief Set the value of the cross diffusion for the SST model.
     * \param[in] val_CDkw_i - Value of the cross diffusion at point i.
     * \param[in] val_CDkw_j - Value of the cross diffusion at point j.
     */
    virtual void SetCrossDiff(double val_CDkw_i, double val_CDkw_j) {/* empty */};
    
    /*!
     * \brief Set the gradient of the auxiliary variables.
     * \param[in] val_auxvargrad_i - Gradient of the auxiliary variable at point i.
     * \param[in] val_auxvargrad_j - Gradient of the auxiliary variable at point j.
     */
    void SetAuxVarGrad(double *val_auxvargrad_i, double *val_auxvargrad_j);
    
    /*!
     * \brief Set the diffusion coefficient
     * \param[in] val_diffusioncoeff_i - Value of the diffusion coefficients at i.
     * \param[in] val_diffusioncoeff_j - Value of the diffusion coefficients at j
     */
    void SetDiffusionCoeff(double* val_diffusioncoeff_i,
                           double* val_diffusioncoeff_j);
    
    /*!
     * \brief Set the laminar viscosity.
     * \param[in] val_laminar_viscosity_i - Value of the laminar viscosity at point i.
     * \param[in] val_laminar_viscosity_j - Value of the laminar viscosity at point j.
     */
    void SetLaminarViscosity(double val_laminar_viscosity_i,
                             double val_laminar_viscosity_j);
    
    /*!
     * \brief Set the thermal conductivity (translational/rotational)
     * \param[in] val_thermal_conductivity_i - Value of the thermal conductivity at point i.
     * \param[in] val_thermal_conductivity_j - Value of the thermal conductivity at point j.
     * \param[in] iSpecies - Value of the species.
     */
    void SetThermalConductivity(double val_thermal_conductivity_i,
                                double val_thermal_conductivity_j);
    
    /*!
     * \brief Set the thermal conductivity (translational/rotational)
     * \param[in] val_thermal_conductivity_i - Value of the thermal conductivity at point i.
     * \param[in] val_thermal_conductivity_j - Value of the thermal conductivity at point j.
     * \param[in] iSpecies - Value of the species.
     */
    void SetThermalConductivity_ve(double val_thermal_conductivity_ve_i,
                                   double val_thermal_conductivity_ve_j);
    
    /*!
     * \brief Set the eddy viscosity.
     * \param[in] val_eddy_viscosity_i - Value of the eddy viscosity at point i.
     * \param[in] val_eddy_viscosity_j - Value of the eddy viscosity at point j.
     */
    void SetEddyViscosity(double val_eddy_viscosity_i,
                          double val_eddy_viscosity_j);
    
    /*!
     * \brief Set the turbulent kinetic energy.
     * \param[in] val_turb_ke_i - Value of the turbulent kinetic energy at point i.
     * \param[in] val_turb_ke_j - Value of the turbulent kinetic energy at point j.
     */
    void SetTurbKineticEnergy(double val_turb_ke_i, double val_turb_ke_j);
    
    /*!
     * \brief Set the value of the distance from the nearest wall.
     * \param[in] val_dist_i - Value of of the distance from point i to the nearest wall.
     * \param[in] val_dist_j - Value of of the distance from point j to the nearest wall.
     */
    void SetDistance(double val_dist_i, double val_dist_j);
    
    /*!
     * \brief Set coordinates of the points.
     * \param[in] val_coord_i - Coordinates of the point i.
     * \param[in] val_coord_j - Coordinates of the point j.
     */
    void SetCoord(double *val_coord_i, double *val_coord_j);
    
    /*!
     * \overload
     * \param[in] val_coord_0 - Coordinates of the point 0.
     * \param[in] val_coord_1 - Coordinates of the point 1.
     * \param[in] val_coord_2 - Coordinates of the point 2.
     */
    void SetCoord(double *val_coord_0, double *val_coord_1, double *val_coord_2);
    
    /*!
     * \overload
     * \param[in] val_coord_0 - Coordinates of the point 0.
     * \param[in] val_coord_1 - Coordinates of the point 1.
     * \param[in] val_coord_2 - Coordinates of the point 2.
     * \param[in] val_coord_3 - Coordinates of the point 3.
     */
    void SetCoord(double *val_coord_0, double *val_coord_1, double *val_coord_2,
                  double *val_coord_3);
    
    /*!
     * \brief Set the velocity of the computational grid.
     * \param[in] val_gridvel_i - Grid velocity of the point i.
     * \param[in] val_gridvel_j - Grid velocity of the point j.
     */
    void SetGridVel(double *val_gridvel_i, double *val_gridvel_j);
    
    /*!
     * \brief Set the wind gust value.
     * \param[in] val_windgust_i - Wind gust of the point i.
     * \param[in] val_windgust_j - Wind gust of the point j.
     */
    void SetWindGust(double *val_windgust_i, double *val_windgust_j);
    
    /*!
     * \brief Set the wind gust derivatives values.
     * \param[in] val_windgust_i - Wind gust derivatives of the point i.
     * \param[in] val_windgust_j - Wind gust derivatives of the point j.
     */
    void SetWindGustDer(double *val_windgustder_i, double *val_windgustder_j);
    
    /*!
     * \brief Set the value of the pressure.
     * \param[in] val_pressure_i - Value of the pressure at point i.
     * \param[in] val_pressure_j - Value of the pressure at point j.
     */
    void SetPressure(double val_pressure_i, double val_pressure_j);
    
    /*!
     * \brief Set the value of the density for the incompressible solver.
     * \param[in] val_densityinc_i - Value of the pressure at point i.
     * \param[in] val_densityinc_j - Value of the pressure at point j.
     */
    void SetDensityInc(double val_densityinc_i, double val_densityinc_j);
    
    /*!
     * \brief Set the value of the beta for incompressible flows.
     * \param[in] val_betainc2_i - Value of beta for incompressible flows at point i.
     * \param[in] val_betainc2_j - Value of beta for incompressible flows at point j.
     */
    void SetBetaInc2(double val_betainc2_i, double val_betainc2_j);
    
    /*!
     * \brief Set the value of the sound speed.
     * \param[in] val_soundspeed_i - Value of the sound speed at point i.
     * \param[in] val_soundspeed_j - Value of the sound speed at point j.
     */
    void SetSoundSpeed(double val_soundspeed_i, double val_soundspeed_j);
    
    /*!
     * \brief Set the value of the temperature.
     * \param[in] val_temp_i - Value of the temperature at point i.
     * \param[in] val_temp_j - Value of the temperature at point j.
     */
    void SetTemperature(double val_temp_i, double val_temp_j);
    
    /*!
     * \brief Set the value of the species pressures.
     * \param[in] val_pressure_i - Value of the pressure at point i.
     * \param[in] val_pressure_j - Value of the pressure at point j.
     */
    void SetPressure(double* val_pressure_i, double* val_pressure_j);
    
    /*!
     * \brief Set the value of the enthalpy.
     * \param[in] val_enthalpy_i - Value of the enthalpy at point i.
     * \param[in] val_enthalpy_j - Value of the enthalpy at point j.
     */
    void SetEnthalpy(double val_enthalpy_i, double val_enthalpy_j);
    
    /*!
     * \brief Set the value of the spectral radius.
     * \param[in] val_lambda_i - Value of the spectral radius at point i.
     * \param[in] val_lambda_j - Value of the spectral radius at point j.
     */
    void SetLambda(double val_lambda_i, double val_lambda_j);
    
    /*!
     * \brief Set the value of undivided laplacian.
     * \param[in] val_und_lapl_i Undivided laplacian at point i.
     * \param[in] val_und_lapl_j Undivided laplacian at point j.
     */
    void SetUndivided_Laplacian(double *val_und_lapl_i, double *val_und_lapl_j);
    
    /*!
     * \brief Set the value of the pressure sensor.
     * \param[in] val_sensor_i Pressure sensor at point i.
     * \param[in] val_sensor_j Pressure sensor at point j.
     */
    void SetSensor(double val_sensor_i, double val_sensor_j);
    
    /*!
     * \brief Set the number of neighbor to a point.
     * \param[in] val_neighbor_i - Number of neighbor to point i.
     * \param[in] val_neighbor_j - Number of neighbor to point j.
     */
    void SetNeighbor(unsigned short val_neighbor_i, unsigned short val_neighbor_j);
    
    /*!
     * \brief Set the value of the normal vector to the face between two points.
     * \param[in] val_normal - Normal vector, the norm of the vector is the area of the face.
     */
    void SetNormal(double *val_normal);
    
    /*!
     * \brief Set the value of the volume of the control volume.
     * \param[in] val_volume Volume of the control volume.
     */
    void SetVolume(double val_volume);
    
    /*!
     * \brief Retrieves the value of the species density in the primitive variable vector.
     * \param[in] iRho_s
     */
    void SetRhosIndex(unsigned short val_Index);
    
    /*!
     * \brief Retrieves the value of the species density in the primitive variable vector.
     * \param[in] iRho_s
     */
    void SetRhoIndex(unsigned short val_Index);
    
    /*!
     * \brief Retrieves the value of the species density in the primitive variable vector.
     * \param[in] iRho_s
     */
    void SetPIndex(unsigned short val_Index);
    
    /*!
     * \brief Retrieves the value of the species density in the primitive variable vector.
     * \param[in] iRho_s
     */
    void SetTIndex(unsigned short val_Index);
    
    /*!
     * \brief Retrieves the value of the species density in the primitive variable vector.
     * \param[in] iRho_s
     */
    void SetTveIndex(unsigned short val_Index);
    
    /*!
     * \brief Retrieves the value of the velocity index in the primitive variable vector.
     * \param[in] i(rho*u)
     */
    void SetVelIndex(unsigned short val_Index);
    
    /*!
     * \brief Retrieves the value of the species density in the primitive variable vector.
     * \param[in] iRho_s
     */
    void SetHIndex(unsigned short val_Index);
    
    /*!
     * \brief Retrieves the value of the species density in the primitive variable vector.
     * \param[in] iRho_s
     */
    void SetAIndex(unsigned short val_Index);
    
    /*!
     * \brief Retrieves the value of the species density in the primitive variable vector.
     * \param[in] iRho_s
     */
    void SetRhoCvtrIndex(unsigned short val_Index);
    
    /*!
     * \brief Retrieves the value of the species density in the primitive variable vector.
     * \param[in] iRho_s
     */
    void SetRhoCvveIndex(unsigned short val_Index);
    
    /*!
     * \brief Sets the value of the derivative of pressure w.r.t. species density.
     * \param[in] iRho_s
     */
    void SetdPdU(double *val_dPdU_i, double *val_dPdU_j);
    
    /*!
     * \brief Sets the value of the derivative of temperature w.r.t. species density.
     * \param[in] iRho_s
     */
    void SetdTdU(double *val_dTdU_i, double *val_dTdU_j);
    
    /*!
     * \brief Sets the value of the derivative of vib-el. temperature w.r.t. species density.
     * \param[in] iRho_s
     */
    void SetdTvedU(double *val_dTvedU_i, double *val_dTvedU_j);
    
    /*!
     * \brief Get the inviscid fluxes.
     * \param[in] val_density - Value of the density.
     * \param[in] val_velocity - Value of the velocity.
     * \param[in] val_pressure - Value of the pressure.
     * \param[in] val_enthalpy - Value of the enthalpy.
     */
    void GetInviscidFlux(double val_density, double *val_velocity, double val_pressure, double val_enthalpy);
    
    /*!
     * \brief Get the viscous fluxes.
     * \param[in] val_primvar - Value of the primitive variables.
     * \param[in] val_gradprimvar - Gradient of the primitive variables.
     * \param[in] val_laminar_viscosity - Value of the laminar viscosity.
     * \param[in] val_eddy_viscosity - Value of the eddy viscosity.
     * \param[in] val_mach_inf - Value of the Mach number at the infinity.
     */
    void GetViscousFlux(double *val_primvar, double **val_gradprimvar,
                        double val_laminar_viscosity, double val_eddy_viscosity,
                        double val_mach_inf);
    
    /*!
     * \brief Compute the projected inviscid flux vector.
     * \param[in] val_density - Pointer to the density.
     * \param[in] val_velocity - Pointer to the velocity.
     * \param[in] val_pressure - Pointer to the pressure.
     * \param[in] val_enthalpy - Pointer to the enthalpy.
     * \param[in] val_normal - Normal vector, the norm of the vector is the area of the face.
     * \param[out] val_Proj_Flux - Pointer to the projected flux.
     */
    void GetInviscidProjFlux(double *val_density, double *val_velocity,
                             double *val_pressure, double *val_enthalpy,
                             double *val_normal, double *val_Proj_Flux);
    
    /*!
     * \brief Compute the projected inviscid flux vector.
     * \param[in] val_U - Conserved variables
     * \param[in] val_V - Primitive variables
     * \param[in] val_normal - Normal vector, the norm of the vector is the area of the face.
     * \param[out] val_Proj_Flux - Pointer to the projected flux.
     */
    void GetInviscidProjFlux(double *val_U, double *val_V, double *val_normal,
                             double *val_Proj_Flux);
    
    /*!
     * \brief Compute the projected inviscid flux vector for incompresible simulations
     * \param[in] val_density - Pointer to the density.
     * \param[in] val_velocity - Pointer to the velocity.
     * \param[in] val_pressure - Pointer to the pressure.
     * \param[in] val_betainc2 - Value of the artificial compresibility factor.
     * \param[in] val_normal - Normal vector, the norm of the vector is the area of the face.
     * \param[out] val_Proj_Flux - Pointer to the projected flux.
     */
    void GetInviscidArtCompProjFlux(double *val_density, double *val_velocity,
                                    double *val_pressure, double *val_betainc2,
                                    double *val_normal, double *val_Proj_Flux);
    
    /*!
     * \brief Compute the projected inviscid flux vector for incompresible simulations
     * \param[in] val_density - Pointer to the density.
     * \param[in] val_velocity - Pointer to the velocity.
     * \param[in] val_pressure - Pointer to the pressure.
     * \param[in] val_betainc2 - Value of the artificial compresibility factor.
     * \param[in] val_normal - Normal vector, the norm of the vector is the area of the face.
     * \param[out] val_Proj_Flux - Pointer to the projected flux.
     */
    void GetInviscidArtComp_FreeSurf_ProjFlux(double *val_density,
                                              double *val_velocity,
                                              double *val_pressure,
                                              double *val_betainc2,
                                              double *val_levelset,
                                              double *val_normal,
                                              double *val_Proj_Flux);
    
    
    /*!
     * \brief Compute the projection of the viscous fluxes into a direction.
     * \param[in] val_primvar - Primitive variables.
     * \param[in] val_gradprimvar - Gradient of the primitive variables.
     * \param[in] val_turb_ke - Turbulent kinetic energy
     * \param[in] val_normal - Normal vector, the norm of the vector is the area of the face.
     * \param[in] val_laminar_viscosity - Laminar viscosity.
     * \param[in] val_eddy_viscosity - Eddy viscosity.
     * \param[in] val_thermal_conductivity - Thermal Conductivity.
     * \param[in] val_eddy_conductivity - Eddy Conductivity.
     */
    
    void GetViscousProjFlux(double *val_primvar, double **val_gradprimvar,
                            double val_turb_ke, double *val_normal,
                            double val_laminar_viscosity,
                            double val_eddy_viscosity);
    /*!
     * \brief Compute the projection of the viscous fluxes into a direction for general fluid model.
     * \param[in] val_primvar - Primitive variables.
     * \param[in] val_gradprimvar - Gradient of the primitive variables.
     * \param[in] val_turb_ke - Turbulent kinetic energy
     * \param[in] val_normal - Normal vector, the norm of the vector is the area of the face.
     * \param[in] val_laminar_viscosity - Laminar viscosity.
     * \param[in] val_eddy_viscosity - Eddy viscosity.
     * \param[in] val_thermal_conductivity - Thermal Conductivity.
     * \param[in] val_heat_capacity_cp - Heat Capacity at constant pressure.
     */
    
    void GetViscousProjFlux(double *val_primvar, double **val_gradprimvar,
                            double val_turb_ke, double *val_normal,
                            double val_laminar_viscosity,
                            double val_eddy_viscosity,
                            double val_thermal_conductivity,
                            double val_heat_capacity_cp);
    
    
    
    /*!
     * * \brief Compute the projection of the viscous fluxes into a direction.
     * \brief Overloaded function for multiple species viscous calculations
     * \param[in] val_primvar - Primitive variables.
     * \param[in] val_gradprimvar - Gradient of the primitive variables.
     * \param[in] val_normal - Normal vector, the norm of the vector is the area of the face.
     * \param[in] val_diffusioncoeff
     * \param[in] val_therm_conductivity
     * \param[in] val_therm_conductivity_ve
     * \param[in] config
     */
    void GetViscousProjFlux(double *val_primvar,
                            double **val_gradprimvar,
                            double *val_normal,
                            double *val_diffusioncoeff,
                            double val_viscosity,
                            double val_therm_conductivity,
                            double val_therm_conductivity_ve,
                            CConfig *config);
    
    /*
     * \brief Compute the projection of the viscous fluxes into a direction (artificial compresibility method).
     * \param[in] val_primvar - Primitive variables.
     * \param[in] val_gradprimvar - Gradient of the primitive variables.
     * \param[in] val_normal - Normal vector, the norm of the vector is the area of the face.
     * \param[in] val_laminar_viscosity - Laminar viscosity.
     * \param[in] val_eddy_viscosity - Eddy viscosity.
     */
    
    void GetViscousArtCompProjFlux(double **val_gradprimvar,
                                   double *val_normal,
                                   double val_laminar_viscosity,
                                   double val_eddy_viscosity);
    
    /*!
     * \brief Compute the projection of the inviscid Jacobian matrices.
     * \param[in] val_velocity Pointer to the velocity.
     * \param[in] val_energy Value of the energy.
     * \param[in] val_normal - Normal vector, the norm of the vector is the area of the face.
     * \param[in] val_scale - Scale of the projection.
     * \param[out] val_Proj_Jac_tensor - Pointer to the projected inviscid Jacobian.
     */
    void GetInviscidProjJac(double *val_velocity, double *val_energy,
                            double *val_normal, double val_scale,
                            double **val_Proj_Jac_tensor);
    
    /*!
     * \brief Compute the projection of the inviscid Jacobian matrices (artificial compresibility).
     * \param[in] val_density - Value of the density.
     * \param[in] val_velocity - Pointer to the velocity.
     * \param[in] val_betainc2 - Value of the artificial compresibility factor.
     * \param[in] val_normal - Normal vector, the norm of the vector is the area of the face.
     * \param[in] val_scale - Scale of the projection.
     * \param[out] val_Proj_Jac_tensor - Pointer to the projected inviscid Jacobian.
     */
    void GetInviscidArtCompProjJac(double *val_density, double *val_velocity,
                                   double *val_betainc2, double *val_normal,
                                   double val_scale,
                                   double **val_Proj_Jac_tensor);
    
    /*!
     * \brief Compute the projection of the inviscid Jacobian matrices (artificial compresibility).
     * \param[in] val_density - Value of the density.
     * \param[in] val_velocity - Pointer to the velocity.
     * \param[in] val_betainc2 - Value of the artificial compresibility factor.
     * \param[in] val_normal - Normal vector, the norm of the vector is the area of the face.
     * \param[in] val_scale - Scale of the projection.
     * \param[out] val_Proj_Jac_tensor - Pointer to the projected inviscid Jacobian.
     */
    void GetInviscidArtComp_FreeSurf_ProjJac(double *val_density,
                                             double *val_ddensity,
                                             double *val_velocity,
                                             double *val_betainc2,
                                             double *val_levelset,
                                             double *val_normal,
                                             double val_scale,
                                             double **val_Proj_Jac_tensor);
    
    /*!
     * \brief Compute the projection of the inviscid Jacobian matrices for general fluid model.
     * \param[in] val_velocity Pointer to the velocity.
     * \param[in] val_energy Value of the energy.
     * \param[in] val_normal - Normal vector, the norm of the vector is the area of the face.
     * \param[in] val_scale - Scale of the projection.
     * \param[out] val_Proj_Jac_tensor - Pointer to the projected inviscid Jacobian.
     */
    void GetInviscidProjJac(double *val_velocity, double *val_enthalphy,
                            double *val_chi, double *val_kappa,
                            double *val_normal, double val_scale,
                            double **val_Proj_Jac_tensor);
    /*!
     * \overload
     * \brief Compute the projection of the inviscid Jacobian matrices.
     * \param[in] val_velocity Pointer to the velocity.
     * \param[in] val_energy Value of the energy.
     * \param[in] val_normal - Normal vector, the norm of the vector is the area of the face.
     * \param[in] val_scale - Scale of the projection.
     * \param[out] val_Proj_Jac_tensor - Pointer to the projected inviscid Jacobian.
     */
//    void GetInviscidProjJac(double **val_velocity, double *val_energy,
//                            double *val_normal, double val_scale,
//                            double **val_Proj_Jac_tensor);
    
    /*!
     * \overload
     * \brief Compute the projection of the inviscid Jacobian matrices for the two-temperature model.
     * \param[in] val_U - Vector conserved variables.
     * \param[in] val_V - Vector of primitive variables.
     * \param[in] val_dPdU - Vector of partial derivatives of pressure w.r.t. conserved vars.
     * \param[in] val_normal - Normal vector, the norm of the vector is the area of the face.
     * \param[in] val_scale - Scale of the projection.
     * \param[out] val_Proj_Jac_tensor - Pointer to the projected inviscid Jacobian.
     */
    void GetInviscidProjJac(double *val_U, double *val_V, double *val_dPdU,
                            double *val_normal, double val_scale,
                            double **val_Proj_Jac_Tensor);
    
    /*!
     * \brief TSL-Approximation of Viscous NS Jacobians.
     * \param[in] val_Mean_PrimVar - Mean value of the primitive variables.
     * \param[in] val_laminar_viscosity - Value of the laminar viscosity.
     * \param[in] val_eddy_viscosity - Value of the eddy viscosity.
     * \param[in] val_dist_ij - Distance between the points.
     * \param[in] val_normal - Normal vector, the norm of the vector is the area of the face.
     * \param[in] val_dS - Area of the face between two nodes.
     * \param[in] val_Proj_Visc_Flux - Pointer to the projected viscous flux.
     * \param[out] val_Proj_Jac_Tensor_i - Pointer to the projected viscous Jacobian at point i.
     * \param[out] val_Proj_Jac_Tensor_j - Pointer to the projected viscous Jacobian at point j.
     */
    void GetViscousProjJacs(double *val_Mean_PrimVar,
                            double val_laminar_viscosity,
                            double val_eddy_viscosity,
                            double val_dist_ij,
                            double *val_normal, double val_dS,
                            double *val_Proj_Visc_Flux,
                            double **val_Proj_Jac_Tensor_i,
                            double **val_Proj_Jac_Tensor_j);
    
    /*!
     * \brief TSL-Approximation of Viscous NS Jacobians for arbitrary equations of state.
     * \param[in] val_Mean_PrimVar - Mean value of the primitive variables.
     * \param[in] val_gradprimvar - Mean value of the gradient of the primitive variables.
     * \param[in] val_Mean_SecVar - Mean value of the secondary variables.
     * \param[in] val_laminar_viscosity - Value of the laminar viscosity.
     * \param[in] val_eddy_viscosity - Value of the eddy viscosity.
     * \param[in] val_thermal_conductivity - Value of the thermal conductivity.
     * \param[in] val_heat_capacity_cp - Value of the specific heat at constant pressure.
     * \param[in] val_dist_ij - Distance between the points.
     * \param[in] val_normal - Normal vector, the norm of the vector is the area of the face.
     * \param[in] val_dS - Area of the face between two nodes.
     * \param[in] val_Proj_Visc_Flux - Pointer to the projected viscous flux.
     * \param[out] val_Proj_Jac_Tensor_i - Pointer to the projected viscous Jacobian at point i.
     * \param[out] val_Proj_Jac_Tensor_j - Pointer to the projected viscous Jacobian at point j.
     */
    void GetViscousProjJacs(double *val_Mean_PrimVar,
                            double **val_gradprimvar,
                            double *val_Mean_SecVar,
                            double val_laminar_viscosity,
                            double val_eddy_viscosity,
                            double val_thermal_conductivity,
                            double val_heat_capacity_cp,
                            double val_dist_ij,
                            double *val_normal, double val_dS,
                            double *val_Proj_Visc_Flux,
                            double **val_Proj_Jac_Tensor_i,
                            double **val_Proj_Jac_Tensor_j);
    
    /*!
     * \brief Mapping between primitives variables P and conservatives variables C.
     * \param[in] val_Mean_PrimVar - Mean value of the primitive variables.
     * \param[in] val_Mean_PrimVar - Mean Value of the secondary variables.
     * \param[out] val_Jac_PC - Pointer to the Jacobian dPdC.
     */
    void GetPrimitive2Conservative (double *val_Mean_PrimVar,
                                    double *val_Mean_SecVar,
                                    double **val_Jac_PC);
    
    /*!
     * \brief TSL-Approximation of Viscous NS Jacobians.
     * \param[in] val_Mean_PrimVar - Mean value of the primitive variables.
     * \param[in] val_laminar_viscosity - Value of the laminar viscosity.
     * \param[in] val_thermal_conductivity
     * \param[in] val_dist_ij - Distance between the points.
     * \param[in] val_normal - Normal vector, the norm of the vector is the area of the face.
     * \param[in] val_dS - Area of the face between two nodes.
     * \param[in] val_Proj_Visc_Flux - Pointer to the projected viscous flux.
     * \param[out] val_Proj_Jac_Tensor_i - Pointer to the projected viscous Jacobian at point i.
     * \param[out] val_Proj_Jac_Tensor_j - Pointer to the projected viscous Jacobian at point j.
     */
    void GetViscousProjJacs(double *val_Mean_PrimVar,
                            double *val_diffusion_coeff,
                            double val_laminar_viscosity,
                            double val_thermal_conductivity,
                            double val_thermal_conductivity_ve,
                            double val_dist_ij,
                            double *val_normal, double val_dS,
                            double *val_Proj_Visc_Flux,
                            double **val_Proj_Jac_Tensor_i,
                            double **val_Proj_Jac_Tensor_j,
                            CConfig *config);
    
    /*!
     * \brief Compute the projection of the viscous Jacobian matrices.
     * \param[in] val_laminar_viscosity - Value of the laminar viscosity.
     * \param[in] val_eddy_viscosity - Value of the eddy viscosity.
     * \param[in] val_dist_ij - Distance between the points.
     * \param[in] val_normal - Normal vector, the norm of the vector is the area of the face.
     * \param[in] val_dS - Area of the face between two nodes.
     * \param[out] val_Proj_Jac_Tensor_i - Pointer to the projected viscous Jacobian at point i.
     * \param[out] val_Proj_Jac_Tensor_j - Pointer to the projected viscous Jacobian at point j.
     */
    void GetViscousArtCompProjJacs(double val_laminar_viscosity,
                                   double val_eddy_viscosity, double val_dist_ij,
                                   double *val_normal, double val_dS,
                                   double **val_Proj_Jac_Tensor_i,
                                   double **val_Proj_Jac_Tensor_j);
    
    /*!
     * \overload
     * \brief Computation of the matrix P for a generic fluid model
     * \param[in] val_density - Value of the density.
     * \param[in] val_velocity - Value of the velocity.
     * \param[in] val_soundspeed - Value of the sound speed.
     * \param[in] val_enthalpy - Value of the Enthalpy
     * \param[in] val_chi - Value of the derivative of Pressure with respect to the Density.
     * \param[in] val_kappa - Value of the derivative of Pressure with respect to the volume specific Static Energy.
     * \param[in] val_normal - Normal vector, the norm of the vector is the area of the face.
     * \param[out] val_p_tensor - Pointer to the P matrix.
     */
    void GetPMatrix(double *val_density, double *val_velocity,
                    double *val_soundspeed, double *val_enthalpy, double *val_chi, double *val_kappa,
                    double *val_normal, double **val_p_tensor);
    
    /*!
     * \brief Computation of the matrix P, this matrix diagonalize the conservative Jacobians in
     *        the form $P^{-1}(A.Normal)P=Lambda$.
     * \param[in] val_density - Value of the density.
     * \param[in] val_velocity - Value of the velocity.
     * \param[in] val_soundspeed - Value of the sound speed.
     * \param[in] val_normal - Normal vector, the norm of the vector is the area of the face.
     * \param[out] val_p_tensor - Pointer to the P matrix.
     */
    void GetPMatrix(double *val_density, double *val_velocity,
                    double *val_soundspeed, double *val_normal,
                    double **val_p_tensor);
    
    /*!
     * \overload
     * \brief Computation of the matrix P, this matrix diagonalize the conservative Jacobians in
     *        the form $P^{-1}(A.Normal)P=Lambda$.
     * \param[in] val_density - Value of the density.
     * \param[in] val_velocity - Value of the velocity.
     * \param[in] val_soundspeed - Value of the sound speed.
     * \param[in] val_normal - Normal vector, the norm of the vector is the area of the face.
     * \param[out] val_p_tensor - Pointer to the P matrix.
     */
//    void GetPMatrix(double *val_density, double **val_velocity,
//                    double *val_soundspeed, double *val_normal,
//                    double **val_p_tensor);
    
    /*!
     * \overload
     * \brief Computation of the matrix P, this matrix diagonalizes the conservative Jacobians
     *        in the form $P^{-1}(A.Normal)P=Lambda$.
     * \param[in] U - Vector of conserved variables (really only need rhoEve)
     * \param[in] V - Vector of primitive variables
     * \param[in] val_dPdU - Vector of derivatives of pressure w.r.t. conserved vars.
     * \param[in] val_normal - Normal vector, the norm of the vector is the area of the face.
     * \param[in] l - Tangential vector to face.
     * \param[in] m - Tangential vector to face (mutually orthogonal to val_normal & l).
     * \param[out] val_invp_tensor - Pointer to inverse of the P matrix.
     */
    void GetPMatrix(double *U, double *V, double *val_dPdU,
                    double *val_normal, double *l, double *m,
                    double **val_p_tensor) ;
    
    /*!
     * \brief Computation of the matrix Rinv*Pe.
     * \param[in] Beta2 - A variable in used to define Pe matrix.
     * \param[in] val_enthalpy - value of the enthalpy.
     * \param[in] val_soundspeed - value of the sound speed.
     * \param[in] val_density - value of the density.
     * \param[in] val_velocity - value of the velocity.
     * \param[out] val_invR_invPe - Pointer to the matrix of conversion from entropic to conserved variables.
     */
    void GetinvRinvPe(double Beta2, double val_enthalpy, double val_soundspeed,
                      double val_density, double* val_velocity,
                      double** val_invR_invPe);
    
    /*!
     * \brief Computation of the matrix R.
     * \param[in] val_pressure - value of the pressure.
     * \param[in] val_soundspeed - value of the sound speed.
     * \param[in] val_density - value of the density.
     * \param[in] val_velocity - value of the velocity.
     * \param[out] val_invR_invPe - Pointer to the matrix of conversion from entropic to conserved variables.
     */
    void GetRMatrix(double val_pressure, double val_soundspeed,
                    double val_density, double* val_velocity,
                    double** val_invR_invPe);
    
    /*!
     * \brief Computation of the matrix Td, this matrix diagonalize the preconditioned conservative Jacobians
     *        in the form $Tg |Lambda| Td = Pc{-1}|Pc (A.Normal)|$.
     * \param[in] Beta2 - A variable in used to define absPeJacobian matrix.
     * \param[in] r_hat - A variable in used to define absPeJacobian matrix.
     * \param[in] s_hat - A variable in used to define absPeJacobian matrix.
     * \param[in] t_hat - A variable in used to define absPeJacobian matrix.
     * \param[in] rB2a2 - A variable in used to define absPeJacobian matrix.
     * \param[in] val_Lambda - Eigenvalues of the Preconditioned Jacobian.
     * \param[in] val_normal - Normal vector, the norm of the vector is the area of the face.
     * \param[out] val_absPeJac - Pointer to the Preconditioned Jacobian matrix.
     */
    void GetPrecondJacobian(double Beta2, double r_hat, double s_hat, double t_hat, double rB2a2, double* val_Lambda, double* val_normal, double** val_absPeJac);
    
    /*!
     * \brief Computation of the matrix P (artificial compresibility), this matrix diagonalize the conservative Jacobians in
     *        the form $P^{-1}(A.Normal)P=Lambda$.
     * \param[in] val_density - Value of the density.
     * \param[in] val_velocity - Value of the velocity.
     * \param[in] val_betainv2 - Value of the compresibility factor.
     * \param[in] val_normal - Normal vector, the norm of the vector is the area of the face.
     * \param[out] val_p_tensor - Pointer to the P matrix.
     */
    void GetPArtCompMatrix(double *val_density, double *val_velocity,
                           double *val_betainv2, double *val_normal,
                           double **val_p_tensor);
    
    /*!
     * \brief Computation of the matrix P (artificial compresibility), this matrix diagonalize the conservative Jacobians in
     *        the form $P^{-1}(A.Normal)P=Lambda$.
     * \param[in] val_density - Value of the density.
     * \param[in] val_velocity - Value of the velocity.
     * \param[in] val_betainv2 - Value of the compresibility factor.
     * \param[in] val_normal - Normal vector, the norm of the vector is the area of the face.
     * \param[out] val_p_tensor - Pointer to the P matrix.
     */
    void GetPArtComp_FreeSurf_Matrix(double *val_density, double *val_ddensity,
                                     double *val_velocity, double *val_betainv2,
                                     double *val_levelset, double *val_normal,
                                     double **val_p_tensor);
    
    /*!
     * \brief Computation of the matrix P^{-1}, this matrix diagonalize the conservative Jacobians
     * in the form $P^{-1}(A.Normal)P=Lambda$.
     * \param[in] val_density - Value of the density.
     * \param[in] val_velocity - Value of the velocity.
     * \param[in] val_soundspeed - Value of the sound speed.
     * \param[in] val_normal - Normal vector, the norm of the vector is the area of the face.
     * \param[out] val_invp_tensor - Pointer to inverse of the P matrix.
     */
    void GetPMatrix_inv(double **val_invp_tensor, double *val_density,
                        double *val_velocity, double *val_soundspeed,
                        double *val_chi, double *val_kappa,
                        double *val_normal);
    
    /*!
     * \brief Computation of the matrix P^{-1}, this matrix diagonalize the conservative Jacobians
     *        in the form $P^{-1}(A.Normal)P=Lambda$.
     * \param[in] val_density - Value of the density.
     * \param[in] val_velocity - Value of the velocity.
     * \param[in] val_soundspeed - Value of the sound speed.
     * \param[in] val_normal - Normal vector, the norm of the vector is the area of the face.
     * \param[out] val_invp_tensor - Pointer to inverse of the P matrix.
     */
    void GetPMatrix_inv(double *val_density, double *val_velocity,
                        double *val_soundspeed, double *val_normal,
                        double **val_invp_tensor);
    
    /*!
     * \overload
     * \brief Computation of the matrix P^{-1}, this matrix diagonalize the conservative Jacobians
     *        in the form $P^{-1}(A.Normal)P=Lambda$.
     * \param[in] val_density - Value of the density.
     * \param[in] val_velocity - Value of the velocity.
     * \param[in] val_soundspeed - Value of the sound speed.
     * \param[in] val_normal - Normal vector, the norm of the vector is the area of the face.
     * \param[out] val_invp_tensor - Pointer to inverse of the P matrix.
     */
//    void GetPMatrix_inv(double *val_density, double **val_velocity,
//                        double *val_soundspeed, double *val_normal,
//                        double **val_invp_tensor);
    
    /*!
     * \overload
     * \brief Computation of the matrix P^{-1}, this matrix diagonalizes the conservative Jacobians
     *        in the form $P^{-1}(A.Normal)P=Lambda$.
     * \param[in] U - Vector of conserved variables.
     * \param[in] V - Vector of primitive variables.
     * \param[in] val_dPdU - Vector of derivatives of pressure w.r.t. conserved variables
     * \param[in] val_normal - Normal vector, the norm of the vector is the area of the face.
     * \param[in] l - Tangential vector to face.
     * \param[in] m - Tangential vector to face (mutually orthogonal to val_normal & l).
     * \param[out] val_invp_tensor - Pointer to inverse of the P matrix.
     */
    void GetPMatrix_inv(double *U, double *V, double *val_dPdU,
                        double *val_normal, double *l, double *m,
                        double **val_invp_tensor) ;
    
    /*!
     * \brief Computation of the matrix P^{-1} (artificial compresibility), this matrix diagonalize the conservative Jacobians
     *        in the form $P^{-1}(A.Normal)P=Lambda$.
     * \param[in] val_density - Value of the density.
     * \param[in] val_velocity - Value of the velocity.
     * \param[in] val_betainv2 - Value of the compresibility factor.
     * \param[in] val_normal - Normal vector, the norm of the vector is the area of the face.
     * \param[out] val_invp_tensor - Pointer to inverse of the P matrix.
     */
    void GetPArtCompMatrix_inv(double *val_density, double *val_velocity,
                               double *val_betainv2, double *val_normal,
                               double **val_invp_tensor);
    
    /*!
     * \brief Computation of the matrix P^{-1} (artificial compresibility), this matrix diagonalize the conservative Jacobians
     *        in the form $P^{-1}(A.Normal)P=Lambda$.
     * \param[in] val_density - Value of the density.
     * \param[in] val_velocity - Value of the velocity.
     * \param[in] val_betainv2 - Value of the compresibility factor.
     * \param[in] val_normal - Normal vector, the norm of the vector is the area of the face.
     * \param[out] val_invp_tensor - Pointer to inverse of the P matrix.
     */
    void GetPArtComp_FreeSurf_Matrix_inv(double *val_density,
                                         double *val_ddensity,
                                         double *val_velocity,
                                         double *val_betainv2,
                                         double *val_levelset,
                                         double *val_normal,
                                         double **val_invp_tensor);
    
    /*!
     * \brief Compute viscous residual and jacobian.
     */
    void GetAdjViscousFlux_Jac(double Pressure_i, double Pressure_j, double Density_i, double Density_j,
                               double ViscDens_i, double ViscDens_j, double *Velocity_i, double *Velocity_j,
                               double sq_vel_i, double sq_vel_j,
                               double XiDens_i, double XiDens_j, double **Mean_GradPhi, double *Mean_GradPsiE,
                               double dPhiE_dn, double *Normal, double *Edge_Vector, double dist_ij_2, double *val_residual_i,
                               double *val_residual_j,
                               double **val_Jacobian_ii, double **val_Jacobian_ij, double **val_Jacobian_ji,
                               double **val_Jacobian_jj, bool implicit);
    
    /*!
     * \brief Computation of the projected inviscid lambda (eingenvalues).
     * \param[in] val_velocity - Value of the velocity.
     * \param[in] val_soundspeed - Value of the sound speed.
     * \param[in] val_normal - Normal vector, the norm of the vector is the area of the face.
     * \param[in] val_Lambda_Vector - Pointer to Lambda matrix.
     */
    void GetJacInviscidLambda_fabs(double *val_velocity, double val_soundspeed,
                                   double *val_normal, double *val_Lambda_Vector);
    
    /*!
     * \brief Compute the numerical residual.
     * \param[out] val_residual - Pointer to the total residual.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void ComputeResidual(double *val_residual, CConfig *config);
    
    /*!
     * \overload
     * \param[out] val_residual_i - Pointer to the total residual at point i.
     * \param[out] val_residual_j - Pointer to the total residual at point j.
     */
    virtual void ComputeResidual(double *val_residual_i, double *val_residual_j);
    
    virtual void ComputeResidual_TransLM(double *val_residual,
                                         double **val_Jacobian_i,
                                         double **val_Jacobian_j, CConfig *config,
                                         double &gamma_sep) ;
    
    /*!
     * \overload
     * \param[out] val_residual_i - Pointer to the total residual at point i.
     * \param[out] val_residual_j - Pointer to the total residual at point j.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void ComputeResidual(double *val_residual_i,
                                 double *val_residual_j, CConfig *config);
    
    /*!
     * \overload
     * \param[out] val_residual - Pointer to the total residual.
     * \param[out] val_Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[out] val_Jacobian_j - Jacobian of the numerical method at node j (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    virtual void ComputeResidual(double *val_residual, double **val_Jacobian_i,
                                 double **val_Jacobian_j, CConfig *config);
    
    /*!
     * \overload
     * \param[out] val_residual - Pointer to the total residual.
     * \param[out] val_Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[out] val_Jacobian_j - Jacobian of the numerical method at node j (implicit computation).
     * \param[out] val_JacobianMeanFlow_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[out] val_JacobianMeanFlow_j - Jacobian of the numerical method at node j (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    virtual void ComputeResidual(double *val_residual, double **val_Jacobian_i,
                                 double **val_Jacobian_j,
                                 double **val_JacobianMeanFlow_i,
                                 double **val_JacobianMeanFlow_j,
                                 CConfig *config);
    
    /*!
     * \overload
     * \param[out] val_Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[out] val_Jacobian_j - Jacobian of the numerical method at node j (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    virtual void ComputeResidual(double **val_Jacobian_i, double **val_Jacobian_j,
                                 CConfig *config);
    
    /*!
     * \overload
     * \param[out] val_resconv - Pointer to the convective residual.
     * \param[out] val_resvisc - Pointer to the artificial viscosity residual.
     * \param[out] val_Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[out] val_Jacobian_j - Jacobian of the numerical method at node j (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    virtual void ComputeResidual(double *val_resconv, double *val_resvisc,
                                 double **val_Jacobian_i, double **val_Jacobian_j,
                                 CConfig *config);
    
    /*!
     * \overload
     * \param[out] val_residual_i - Pointer to the total residual at point i.
     * \param[out] val_residual_j - Pointer to the total viscosity residual at point j.
     * \param[out] val_Jacobian_ii - Jacobian of the numerical method at node i (implicit computation) from node i.
     * \param[out] val_Jacobian_ij - Jacobian of the numerical method at node i (implicit computation) from node j.
     * \param[out] val_Jacobian_ji - Jacobian of the numerical method at node j (implicit computation) from node i.
     * \param[out] val_Jacobian_jj - Jacobian of the numerical method at node j (implicit computation) from node j.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void ComputeResidual(double *val_residual_i, double *val_residual_j,
                                 double **val_Jacobian_ii,
                                 double **val_Jacobian_ij,
                                 double **val_Jacobian_ji,
                                 double **val_Jacobian_jj, CConfig *config);
    
    /*!
     * \overload
     * \param[out] val_resconv_i - Pointer to the convective residual at point i.
     * \param[out] val_resvisc_i - Pointer to the artificial viscosity residual at point i.
     * \param[out] val_resconv_j - Pointer to the convective residual at point j.
     * \param[out] val_resvisc_j - Pointer to the artificial viscosity residual at point j.
     * \param[out] val_Jacobian_ii - Jacobian of the numerical method at node i (implicit computation) from node i.
     * \param[out] val_Jacobian_ij - Jacobian of the numerical method at node i (implicit computation) from node j.
     * \param[out] val_Jacobian_ji - Jacobian of the numerical method at node j (implicit computation) from node i.
     * \param[out] val_Jacobian_jj - Jacobian of the numerical method at node j (implicit computation) from node j.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void ComputeResidual(double *val_resconv_i, double *val_resvisc_i,
                                 double *val_resconv_j, double *val_resvisc_j,
                                 double **val_Jacobian_ii,
                                 double **val_Jacobian_ij,
                                 double **val_Jacobian_ji,
                                 double **val_Jacobian_jj, CConfig *config);
    
    /*!
     * \overload
     * \param[out] val_stiffmatrix_elem - Stiffness matrix for Galerkin computation.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void ComputeResidual(double **val_stiffmatrix_elem, CConfig *config);
    
    /*!
     * \overload
     * \param[in] config - Definition of the particular problem.
     * \param[out] val_residual - residual of the source terms
     * \param[out] val_Jacobian_i - Jacobian of the source terms
     */
    virtual void ComputeResidual(double *val_residual, double **val_Jacobian_i,
                                 CConfig *config);
    
    /*!
     * \overload
     * \param[out] - Matrix for storing the constants to be used in the calculation of the equilibrium extent of reaction Keq.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void GetEq_Rxn_Coefficients(double **EqnRxnConstants, CConfig *config);
    
    /*!
     * \brief Residual for source term integration.
     * \param[out] val_residual - Pointer to the source residual containing chemistry terms.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void ComputeResidual_Axisymmetric(double *val_residual, CConfig *config);
    
    /*!
     * \brief Residual for source term integration.
     * \param[out] val_residual - Pointer to the source residual containing chemistry terms.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void ComputeResidual_Axisymmetric_ad(double *val_residual, double *val_residuald, CConfig *config);
    
    /*!
     * \brief Calculation of axisymmetric source term Jacobian
     * \param[out] val_Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    virtual void SetJacobian_Axisymmetric(double **val_Jacobian_i, CConfig *config);
    
    /*!
     * \brief Calculation of the translational-vibrational energy exchange source term
     * \param[in] config - Definition of the particular problem.
     * \param[out] val_residual - residual of the source terms
     * \param[out] val_Jacobian_i - Jacobian of the source terms
     */
    virtual void ComputeVibRelaxation(double *val_residual, double **val_Jacobian_i, CConfig *config);
    
    /*!
     * \brief Calculation of the chemistry source term
     * \param[in] config - Definition of the particular problem.
     * \param[out] val_residual - residual of the source terms
     * \param[out] val_Jacobian_i - Jacobian of the source terms
     */
    virtual void ComputeChemistry(double *val_residual, double **val_Jacobian_i, CConfig *config);
    
    /*!
     * \brief Calculates constants used for Keq correlation.
     * \param[out] A - Pointer to coefficient array.
     * \param[in] val_reaction - Reaction number indicator.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void GetKeqConstants(double *A, unsigned short val_reaction, CConfig *config);
    
    /*!
     * \brief Set intermittency for numerics (used in SA with LM transition model)
     */
    virtual void SetIntermittency(double intermittency_in);
    
    /*!
     * \brief Computes the viscous source term for the TNE2 adjoint problem
     * \param[in] config - Definition of the particular problem.
     * \param[out] val_residual - residual of the source terms
     */
    virtual void ComputeSourceViscous(double *val_residual, CConfig *config);
    
    /*!
     * \brief Residual for source term integration.
     * \param[in] val_production - Value of the Production.
     */
    virtual void SetProduction(double val_production);
    
    /*!
     * \brief Residual for source term integration.
     * \param[in] val_destruction - Value of the Destruction.
     */
    virtual void SetDestruction(double val_destruction);
    
    /*!
     * \brief Residual for source term integration.
     * \param[in] val_crossproduction - Value of the CrossProduction.
     */
    virtual void SetCrossProduction(double val_crossproduction);
    
    /*!
     * \brief Residual for source term integration.
     * \param[in] val_production - Value of the Production.
     */
    virtual double GetProduction(void);
    
    /*!
     * \brief Residual for source term integration.
     * \param[in] val_destruction - Value of the Destruction.
     */
    virtual double GetDestruction(void);
    
    /*!
     * \brief Residual for source term integration.
     * \param[in] val_crossproduction - Value of the CrossProduction.
     */
    virtual double GetCrossProduction(void);
    
    /*!
     * \overload
     * \param[out] val_Jacobian_i - Jacobian of the numerical method at node i
     * \param[in] config - Definition of the particular problem.
     */
    virtual void ComputeResidual(double **val_Jacobian_i,
                                 double *val_Jacobian_mui,
                                 double ***val_Jacobian_gradi, CConfig *config);
    
    /*!
     * \overload
     * \param[out] val_Jacobian_i - Jacobian of the numerical method at node i
     * \param[in] config - Definition of the particular problem.
     */
    virtual void ComputeResidual(double **val_Jacobian_i,
                                 double *val_Jacobian_mui,
                                 double ***val_Jacobian_gradi,
                                 double **val_Jacobian_j,
                                 double *val_Jacobian_muj,
                                 double ***val_Jacobian_gradj, CConfig *config);
    
    /*!
     * \brief Computing stiffness matrix of the Galerkin method.
     * \param[out] val_stiffmatrix_elem - Stiffness matrix for Galerkin computation.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void SetFEA_StiffMatrix2D(double **StiffMatrix_Elem, double CoordCorners[8][3], unsigned short nNodes);
    
    /*!
     * \brief Computing stiffness matrix of the Galerkin method.
     * \param[out] val_stiffmatrix_elem - Stiffness matrix for Galerkin computation.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void SetFEA_StiffMatrix3D(double **StiffMatrix_Elem, double CoordCorners[8][3], unsigned short nNodes);
    
    /*!
     * \brief Computes a basis of orthogonal vectors from a suppled vector
     * \param[in] config - Normal vector
     */
    void CreateBasis(double *val_Normal);
    
};

/*!
 * \class CUpwCUSP_Flow
 * \brief Class for centered scheme - CUSP.
 * \ingroup ConvDiscr
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CUpwCUSP_Flow : public CNumerics {
    
private:
    unsigned short iDim, iVar, jVar; /*!< \brief Iteration on dimension and variables. */
    double *Diff_U, *Diff_Flux, /*!< \brief Diference of conservative variables and undivided laplacians. */
    *Velocity_i, *Velocity_j, /*!< \brief Velocity at node 0 and 1. */
    *MeanVelocity, ProjVelocity, ProjVelocity_i, ProjVelocity_j,  /*!< \brief Mean and projected velocities. */
    Density_i, Density_j, Energy_i, Energy_j,  /*!< \brief Mean Density and energies. */
    sq_vel_i, sq_vel_j,   /*!< \brief Modulus of the velocity and the normal vector. */
    MeanDensity, MeanPressure, MeanEnthalpy, MeanEnergy, /*!< \brief Mean values of primitive variables. */
    Param_p, Param_Kappa_2, Param_Kappa_4, /*!< \brief Artificial dissipation parameters. */
    Local_Lambda_i, Local_Lambda_j, MeanLambda, /*!< \brief Local eingenvalues. */
    Phi_i, Phi_j, sc2, sc4, StretchingFactor, /*!< \brief Streching parameters. */
    *ProjFlux, *ProjFlux_i, *ProjFlux_j,  /*!< \brief Projected inviscid flux tensor. */
    Epsilon_2, Epsilon_4, cte_0, cte_1, /*!< \brief Artificial dissipation values. */
    LamdaNeg, LamdaPos, ModVelocity, Beta, Nu_c, U_i[5], U_j[5], MeanSoundSpeed, Mach,
    ProjGridVel_i, ProjGridVel_j, ProjGridVel, **Jacobian;  /*!< \brief Projected grid velocity. */
    bool implicit, /*!< \brief Implicit calculation. */
    grid_movement, /*!< \brief Modification for grid movement. */
    stretching; /*!< \brief Stretching factor. */
    
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimension of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CUpwCUSP_Flow(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CUpwCUSP_Flow(void);
    
    /*!
     * \brief Compute the flow residual using a JST method.
     * \param[out] val_residual - Pointer to the residual.
     * \param[out] val_Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[out] val_Jacobian_j - Jacobian of the numerical method at node j (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual, double **val_Jacobian_i, double **val_Jacobian_j,
                         CConfig *config);
};

/*!
 * \class CUpwRoe_Flow
 * \brief Class for solving an approximate Riemann solver of Roe for the flow equations.
 * \ingroup ConvDiscr
 * \author A. Bueno, F. Palacios
 * \version 3.2.9 "eagle"
 */
class CUpwRoe_Flow : public CNumerics {
private:
    bool implicit, grid_movement;
    double *Diff_U;
    double *Velocity_i, *Velocity_j, *RoeVelocity;
    double *ProjFlux_i, *ProjFlux_j;
    double *delta_wave, *delta_vel;
    double *Lambda, *Epsilon, MaxLambda, Delta, sign;
    double **P_Tensor, **invP_Tensor;
    double sq_vel, Proj_ModJac_Tensor_ij, Density_i, Energy_i, SoundSpeed_i, Pressure_i, Enthalpy_i,
    Density_j, Energy_j, SoundSpeed_j, Pressure_j, Enthalpy_j, R, RoeDensity, RoeEnthalpy, RoeSoundSpeed,
    ProjVelocity, ProjVelocity_i, ProjVelocity_j, proj_delta_vel, delta_p, delta_rho, RoeSoundSpeed2, kappa;
    unsigned short iDim, iVar, jVar, kVar;
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CUpwRoe_Flow(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CUpwRoe_Flow(void);
    
    /*!
     * \brief Compute the Roe's flux between two nodes i and j.
     * \param[out] val_residual - Pointer to the total residual.
     * \param[out] val_Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[out] val_Jacobian_j - Jacobian of the numerical method at node j (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual, double **val_Jacobian_i, double **val_Jacobian_j, CConfig *config);
};


/*!
 * \class CUpwGeneralRoe_Flow
 * \brief Class for solving an approximate Riemann solver of Roe for the flow equations for a general fluid model.
 * \ingroup ConvDiscr
 * \author S.Vitale, G.Gori, M.Pini
 * \version 3.2.9 "eagle"
 */
class CUpwGeneralRoe_Flow : public CNumerics {
private:
    bool implicit, grid_movement;
    double *Diff_U;
    double *Velocity_i, *Velocity_j, *RoeVelocity;
    double *ProjFlux_i, *ProjFlux_j;
    double *delta_wave, *delta_vel;
    double *Lambda, *Epsilon;
    double **P_Tensor, **invP_Tensor;
    double sq_vel, Proj_ModJac_Tensor_ij, Density_i, Energy_i, SoundSpeed_i, Pressure_i, Enthalpy_i,
    Density_j, Energy_j, SoundSpeed_j, Pressure_j, Enthalpy_j, R, RoeDensity, RoeEnthalpy, RoeSoundSpeed,
    ProjVelocity, ProjVelocity_i, ProjVelocity_j, proj_delta_vel, delta_p, delta_rho;
    unsigned short iDim, iVar, jVar, kVar;
    
    
    double StaticEnthalpy_i, StaticEnergy_i, StaticEnthalpy_j, StaticEnergy_j, Kappa_i, Kappa_j, Chi_i, Chi_j, Velocity2_i, Velocity2_j;
    double RoeKappa, RoeChi, RoeKappaStaticEnthalpy;
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CUpwGeneralRoe_Flow(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CUpwGeneralRoe_Flow(void);
    
    /*!
     * \brief Compute the Roe's flux between two nodes i and j.
     * \param[out] val_residual - Pointer to the total residual.
     * \param[out] val_Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[out] val_Jacobian_j - Jacobian of the numerical method at node j (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual, double **val_Jacobian_i, double **val_Jacobian_j, CConfig *config);
    
    /*!
     * \brief Compute the Average for a general fluid flux between two nodes i and j.
     * Using the approach of Vinokur and Montagne'
     */
    
    void ComputeRoeAverage();
};


/*!
 * \class CUpwMSW_Flow
 * \brief Class for solving a flux-vector splitting method by Steger & Warming, modified version.
 * \ingroup ConvDiscr
 * \author S. Copeland
 * \version 3.2.9 "eagle"
 */
class CUpwMSW_Flow : public CNumerics {
private:
    bool implicit;
    double *Diff_U;
    double *u_i, *u_j, *ust_i, *ust_j;
    double *Fc_i, *Fc_j;
    double *Lambda_i, *Lambda_j;
    double rhos_i, rhos_j, rhosst_i, rhosst_j;
    double *Ust_i, *Ust_j, *Vst_i, *Vst_j, *Velst_i, *Velst_j;
    double **P_Tensor, **invP_Tensor;
    unsigned short nPrimVar, nPrimVarGrad, nVar, nDim;
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CUpwMSW_Flow(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CUpwMSW_Flow(void);
    
    /*!
     * \brief Compute the Roe's flux between two nodes i and j.
     * \param[out] val_residual - Pointer to the total residual.
     * \param[out] val_Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[out] val_Jacobian_j - Jacobian of the numerical method at node j (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual, double **val_Jacobian_i, double **val_Jacobian_j, CConfig *config);
    
};

/*!
 * \class CUpwTurkel_Flow
 * \brief Class for solving an approximate Riemann solver of Roe with Turkel Preconditioning for the flow equations.
 * \ingroup ConvDiscr
 * \author A. K. Lonkar
 * \version 3.2.9 "eagle"
 */
class CUpwTurkel_Flow : public CNumerics {
private:
    bool implicit, grid_movement;
    double *Diff_U;
    double *Velocity_i, *Velocity_j, *RoeVelocity;
    double *ProjFlux_i, *ProjFlux_j;
    double *Lambda, *Epsilon;
    double **absPeJac, **invRinvPe, **R_Tensor, **Matrix, **Art_Visc;
    double sq_vel, Proj_ModJac_Tensor_ij, Density_i, Energy_i, SoundSpeed_i, Pressure_i, Enthalpy_i,
    Density_j, Energy_j, SoundSpeed_j, Pressure_j, Enthalpy_j, R, RoePressure, RoeDensity, RoeEnthalpy, RoeSoundSpeed,
    ProjVelocity, ProjVelocity_i, ProjVelocity_j;
    unsigned short iDim, iVar, jVar, kVar;
    double Beta, Beta_min, Beta_max;
    double r_hat, s_hat, t_hat, rhoB2a2, sqr_one_m_Betasqr_Lam1;
    double Beta2, one_m_Betasqr, one_p_Betasqr, sqr_two_Beta_c_Area;
    double local_Mach;
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CUpwTurkel_Flow(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CUpwTurkel_Flow(void);
    
    /*!
     * \brief Compute the Roe's flux between two nodes i and j.
     * \param[out] val_residual - Pointer to the total residual.
     * \param[out] val_Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[out] val_Jacobian_j - Jacobian of the numerical method at node j (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual, double **val_Jacobian_i, double **val_Jacobian_j, CConfig *config);
    
    /*!
     * \brief Get the Preconditioning Beta.
     * \return Beta - Value of the low Mach Preconditioner.
     */
    double GetPrecond_Beta();
};

/*!
 * \class CUpwArtComp_Flow
 * \brief Class for solving an approximate Riemann solver of Roe for the incompressible flow equations.
 * \ingroup ConvDiscr
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CUpwArtComp_Flow : public CNumerics {
private:
    bool implicit;
    bool gravity;
    double Froude;
    double *Diff_U;
    double *Velocity_i, *Velocity_j, *MeanVelocity;
    double *ProjFlux_i, *ProjFlux_j;
    double *Lambda, *Epsilon;
    double **P_Tensor, **invP_Tensor;
    double sq_vel, Proj_ModJac_Tensor_ij, Density_i, Energy_i, SoundSpeed_i, Pressure_i, Enthalpy_i,
    Density_j, Energy_j, SoundSpeed_j, Pressure_j, Enthalpy_j, R, MeanDensity, MeanEnthalpy, MeanSoundSpeed, MeanPressure, MeanBetaInc2,
    ProjVelocity, ProjVelocity_i, ProjVelocity_j, proj_delta_vel, delta_p, delta_rho, vn;
    unsigned short iDim, iVar, jVar, kVar;
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CUpwArtComp_Flow(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CUpwArtComp_Flow(void);
    
    /*!
     * \brief Compute the Roe's flux between two nodes i and j.
     * \param[out] val_residual - Pointer to the total residual.
     * \param[out] val_Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[out] val_Jacobian_j - Jacobian of the numerical method at node j (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual, double **val_Jacobian_i, double **val_Jacobian_j, CConfig *config);
};

/*!
 * \class CUpwArtComp_FreeSurf_Flow
 * \brief Class for solving an approximate Riemann solver of Roe for the incompressible flow equations.
 * \ingroup ConvDiscr
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CUpwArtComp_FreeSurf_Flow : public CNumerics {
private:
    bool implicit;
    bool gravity;
    double Froude;
    double *Diff_U;
    double *Velocity_i, *Velocity_j, *MeanVelocity;
    double *ProjFlux_i, *ProjFlux_j;
    double *Lambda, *Epsilon;
    double **P_Tensor, **invP_Tensor;
    double sq_vel, Proj_ModJac_Tensor_ij, Density_i, Pressure_i, LevelSet_i, dDensityInc_i, dDensityInc_j,
    Density_j, Pressure_j, LevelSet_j, MeanDensityInc, dMeanDensityInc, MeanPressure, MeanLevelSet, MeanBetaInc2,
    ProjVelocity, ProjVelocity_i, ProjVelocity_j, proj_delta_vel, Distance_i, Distance_j;
    unsigned short iDim, jDim, iVar, jVar, kVar;
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CUpwArtComp_FreeSurf_Flow(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CUpwArtComp_FreeSurf_Flow(void);
    
    /*!
     * \brief Compute the Roe's flux between two nodes i and j.
     * \param[out] val_residual - Pointer to the total residual.
     * \param[out] val_Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[out] val_Jacobian_j - Jacobian of the numerical method at node j (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual, double **val_Jacobian_i, double **val_Jacobian_j, CConfig *config);
};

/*!
 * \class CUpwRoe_AdjFlow
 * \brief Class for solving an approximate Riemann solver of Roe
 *        for the adjoint flow equations.
 * \ingroup ConvDiscr
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CUpwRoe_AdjFlow : public CNumerics {
private:
    double *Residual_Roe;
    double area, Sx, Sy, Sz, rarea, nx, ny, nz, rho_l, u_l, v_l, w_l, h_l, rho_r,
    u_r, v_r, w_r, h_r, psi1, psi2, psi3, psi4, psi5;
    double h, u, v, w, c, psi1_l, psi2_l, psi3_l, psi4_l, psi5_l,
    psi1_r, psi2_r, psi3_r, psi4_r, psi5_r, q_l, q_r, Q_l, Q_r, vn,
    rrho_l, weight, rweight1, cc;
    double l1psi, l2psi, absQ, absQp, absQm, q2, alpha, beta_u, beta_v, beta_w, Q, l1l2p, l1l2m, eta;
    double RoeDensity, RoeSoundSpeed, *RoeVelocity, *Lambda, *Velocity_i, *Velocity_j, **ProjFlux_i, **ProjFlux_j,
    Proj_ModJac_Tensor_ij, **Proj_ModJac_Tensor, Energy_i, Energy_j, **P_Tensor, **invP_Tensor;
    unsigned short iDim, iVar, jVar, kVar;
    bool implicit, grid_movement;
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CUpwRoe_AdjFlow(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CUpwRoe_AdjFlow(void);
    
    /*!
     * \brief Compute the adjoint Roe's flux between two nodes i and j.
     * \param[out] val_residual_i - Pointer to the total residual at point i.
     * \param[out] val_residual_j - Pointer to the total residual at point j.
     * \param[out] val_Jacobian_ii - Jacobian of the numerical method at node i (implicit computation) from node i.
     * \param[out] val_Jacobian_ij - Jacobian of the numerical method at node i (implicit computation) from node j.
     * \param[out] val_Jacobian_ji - Jacobian of the numerical method at node j (implicit computation) from node i.
     * \param[out] val_Jacobian_jj - Jacobian of the numerical method at node j (implicit computation) from node j.
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual_i, double *val_residual_j, double **val_Jacobian_ii,
                         double **val_Jacobian_ij, double **val_Jacobian_ji, double **val_Jacobian_jj, CConfig *config);
};

/*!
 * \class CUpwRoeArtComp_AdjFlow
 * \brief Class for solving an approximate Riemann solver of Roe
 *        for the adjoint flow equations.
 * \ingroup ConvDiscr
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CUpwRoeArtComp_AdjFlow : public CNumerics {
private:
    double Area, *Lambda, *Velocity_i, *Velocity_j, **Proj_Jac_Tensor_i, **Proj_Jac_Tensor_j,
    Proj_ModJac_Tensor_ij, **Proj_ModJac_Tensor, **P_Tensor, **invP_Tensor, MeanDensity,
    MeanPressure, MeanBetaInc2, ProjVelocity, *MeanVelocity, MeanSoundSpeed;
    unsigned short iDim, iVar, jVar, kVar;
    bool implicit;
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CUpwRoeArtComp_AdjFlow(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CUpwRoeArtComp_AdjFlow(void);
    
    /*!
     * \brief Compute the adjoint Roe's flux between two nodes i and j.
     * \param[out] val_residual_i - Pointer to the total residual at point i.
     * \param[out] val_residual_j - Pointer to the total residual at point j.
     * \param[out] val_Jacobian_ii - Jacobian of the numerical method at node i (implicit computation) from node i.
     * \param[out] val_Jacobian_ij - Jacobian of the numerical method at node i (implicit computation) from node j.
     * \param[out] val_Jacobian_ji - Jacobian of the numerical method at node j (implicit computation) from node i.
     * \param[out] val_Jacobian_jj - Jacobian of the numerical method at node j (implicit computation) from node j.
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual_i, double *val_residual_j, double **val_Jacobian_ii,
                         double **val_Jacobian_ij, double **val_Jacobian_ji, double **val_Jacobian_jj, CConfig *config);
};

/*!
 * \class CUpwAUSM_Flow
 * \brief Class for solving an approximate Riemann AUSM.
 * \ingroup ConvDiscr
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CUpwAUSM_Flow : public CNumerics {
private:
    bool implicit;
    double *Diff_U;
    double *Velocity_i, *Velocity_j, *RoeVelocity;
    double *ProjFlux_i, *ProjFlux_j;
    double *delta_wave, *delta_vel;
    double *Lambda, *Epsilon;
    double **P_Tensor, **invP_Tensor;
    double sq_vel, Proj_ModJac_Tensor_ij, Density_i, Energy_i, SoundSpeed_i, Pressure_i, Enthalpy_i,
    Density_j, Energy_j, SoundSpeed_j, Pressure_j, Enthalpy_j, R, RoeDensity, RoeEnthalpy, RoeSoundSpeed,
    ProjVelocity, ProjVelocity_i, ProjVelocity_j, proj_delta_vel, delta_p, delta_rho;
    unsigned short iDim, iVar, jVar, kVar;
    double mL, mR, mLP, mRM, mF, pLP, pRM, pF, Phi;
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CUpwAUSM_Flow(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CUpwAUSM_Flow(void);
    
    /*!
     * \brief Compute the Roe's flux between two nodes i and j.
     * \param[out] val_residual - Pointer to the total residual.
     * \param[out] val_Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[out] val_Jacobian_j - Jacobian of the numerical method at node j (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual, double **val_Jacobian_i, double **val_Jacobian_j, CConfig *config);
};

/*!
 * \class CUpwHLLC_Flow
 * \brief Class for solving an approximate Riemann AUSM.
 * \ingroup ConvDiscr
 * \author F. Palacios, based on the Joe code implementation
 * \version 3.2.9 "eagle"
 */
class CUpwHLLC_Flow : public CNumerics {
private:
    bool implicit;
    double *Diff_U;
    double *Velocity_i, *Velocity_j, *RoeVelocity;
    double *ProjFlux_i, *ProjFlux_j;
    double *delta_wave, *delta_vel;
    double *Lambda, *Epsilon;
    double **P_Tensor, **invP_Tensor;
    double sq_vel, sq_vel_i, sq_vel_j, Proj_ModJac_Tensor_ij, Density_i, Energy_i, SoundSpeed_i, Pressure_i, Enthalpy_i,
    Density_j, Energy_j, SoundSpeed_j, Pressure_j, Enthalpy_j, R, RoeDensity, RoeEnthalpy, RoeSoundSpeed,
    ProjVelocity, ProjVelocity_i, ProjVelocity_j, proj_delta_vel, delta_p, delta_rho;
    unsigned short iDim, iVar, jVar, kVar;
    double Rrho, tmp, velRoe[3], uRoe, gamPdivRho, sq_velRoe, cRoe, sL, sR, sM, pStar, invSLmSs, sLmuL, rhoSL, rhouSL[3],
    eSL, invSRmSs, sRmuR, rhoSR, rhouSR[3], eSR;
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CUpwHLLC_Flow(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CUpwHLLC_Flow(void);
    
    /*!
     * \brief Compute the Roe's flux between two nodes i and j.
     * \param[out] val_residual - Pointer to the total residual.
     * \param[out] val_Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[out] val_Jacobian_j - Jacobian of the numerical method at node j (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual, double **val_Jacobian_i, double **val_Jacobian_j, CConfig *config);
};

/*!
 * \class CUpwLin_TransLM
 * \brief Class for performing a linear upwind solver for the Spalart-Allmaras turbulence model equations with transition
 * \ingroup ConvDiscr
 * \author A. Aranake
 * \version 3.2.9 "eagle"
 */
class CUpwLin_TransLM : public CNumerics {
private:
    double *Velocity_i;
    double *Velocity_j;
    bool implicit, grid_movement, incompressible;
    double Density_i, Density_j, q_ij, a0, a1;
    unsigned short iDim;
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CUpwLin_TransLM(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CUpwLin_TransLM(void);
    
    /*!
     * \brief Compute the upwind flux between two nodes i and j.
     * \param[out] val_residual - Pointer to the total residual.
     * \param[out] val_Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[out] val_Jacobian_j - Jacobian of the numerical method at node j (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual (double *val_residual, double **val_Jacobian_i, double **val_Jacobian_j, CConfig *config);
};

/*!
 * \class CUpwLin_LevelSet
 * \brief Class for performing a linear upwind solver for the Level Set equations.
 * \ingroup ConvDiscr
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CUpwLin_LevelSet : public CNumerics {
private:
    bool implicit;
    double *Velocity_i;
    double *Velocity_j;
    
public:
    
//    /*!
//     * \brief Constructor of the class.
//     * \param[in] val_nDim - Number of dimensions of the problem.
//     * \param[in] val_nVar - Number of variables of the problem.
//     * \param[in] config - Definition of the particular problem.
//     */
//    CUpwLin_LevelSet(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
//    
//    /*!
//     * \brief Destructor of the class.
//     */
//    ~CUpwLin_LevelSet(void);
//    
//    /*!
//     * \brief Compute the upwind flux between two nodes i and j.
//     * \param[out] val_residual - Pointer to the total residual.
//     * \param[out] val_Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
//     * \param[out] val_Jacobian_j - Jacobian of the numerical method at node j (implicit computation).
//     * \param[in] config - Definition of the particular problem.
//     */
//    void ComputeResidual(double *val_residual, double **val_Jacobian_i, double **val_Jacobian_j,
//                         double **val_JacobianMeanFlow_i, double **val_JacobianMeanFlow_j, CConfig *config);
    
};

/*!
 * \class CUpwLin_AdjLevelSet
 * \brief Class for performing a linear upwind solver for the adjoint Level Set equations.
 * \ingroup ConvDiscr
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CUpwLin_AdjLevelSet : public CNumerics {
private:
    bool implicit;
    double *Velocity_i;
    double *Velocity_j;
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CUpwLin_AdjLevelSet(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CUpwLin_AdjLevelSet(void);
    
    /*!
     * \brief Compute the upwind flux between two nodes i and j.
     * \param[out] val_residual_i - Pointer to the total residual at node i.
     * \param[out] val_residual_j - Pointer to the total residual at node j.
     * \param[out] val_Jacobian_ii - Jacobian of the numerical method at node i (implicit computation).
     * \param[out] val_Jacobian_ij - Jacobian of the numerical method from node i to node j (implicit computation).
     * \param[out] val_Jacobian_ji - Jacobian of the numerical method from node j to node i (implicit computation).
     * \param[out] val_Jacobian_jj - Jacobian of the numerical method at node j (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual_i, double *val_residual_j, double **val_Jacobian_ii,
                         double **val_Jacobian_ij, double **val_Jacobian_ji, double **val_Jacobian_jj, CConfig *config);
};

/*!
 * \class CUpwLin_AdjTurb
 * \brief Class for performing a linear upwind solver for the adjoint turbulence equations.
 * \ingroup ConvDiscr
 * \author A. Bueno.
 * \version 3.2.9 "eagle"
 */
class CUpwLin_AdjTurb : public CNumerics {
private:
    double *Velocity_i;
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CUpwLin_AdjTurb(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CUpwLin_AdjTurb(void);
    
    /*!
     * \brief Compute the adjoint upwind flux between two nodes i and j.
     * \param[out] val_residual - Pointer to the total residual.
     * \param[out] val_Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[out] val_Jacobian_j - Jacobian of the numerical method at node j (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual (double *val_residual, double **val_Jacobian_i, double **val_Jacobian_j, CConfig *config);
};

/*!
 * \class CUpwSca_TurbSA
 * \brief Class for doing a scalar upwind solver for the Spalar-Allmaral turbulence model equations.
 * \ingroup ConvDiscr
 * \author A. Bueno.
 * \version 3.2.9 "eagle"
 */
class CUpwSca_TurbSA : public CNumerics {
private:
    double *Velocity_i, *Velocity_j;
    bool implicit, grid_movement, incompressible;
    double Density_i, Density_j, q_ij, a0, a1;
    unsigned short iDim;
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CUpwSca_TurbSA(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CUpwSca_TurbSA(void);
    
    /*!
     * \brief Compute the scalar upwind flux between two nodes i and j.
     * \param[out] val_residual - Pointer to the total residual.
     * \param[out] val_Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[out] val_Jacobian_j - Jacobian of the numerical method at node j (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual, double **val_Jacobian_i, double **val_Jacobian_j, CConfig *config);
};

/*!
 * \class CUpwSca_TurbML
 * \brief Class for doing a scalar upwind solver for the Spalar-Allmaral turbulence model equations.
 * \ingroup ConvDiscr
 * \author A. Bueno.
 * \version 3.2.9 "eagle"
 */
class CUpwSca_TurbML : public CNumerics {
private:
    double *Velocity_i, *Velocity_j;
    bool implicit, grid_movement, incompressible;
    double Density_i, Density_j, q_ij, a0, a1;
    unsigned short iDim;
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CUpwSca_TurbML(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CUpwSca_TurbML(void);
    
    /*!
     * \brief Compute the scalar upwind flux between two nodes i and j.
     * \param[out] val_residual - Pointer to the total residual.
     * \param[out] val_Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[out] val_Jacobian_j - Jacobian of the numerical method at node j (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual, double **val_Jacobian_i, double **val_Jacobian_j, CConfig *config);
};

/*!
 * \class CUpwSca_TurbSST
 * \brief Class for doing a scalar upwind solver for the Menter SST turbulence model equations.
 * \ingroup ConvDiscr
 * \author A. Campos.
 * \version 3.2.9 "eagle"
 */
class CUpwSca_TurbSST : public CNumerics {
private:
    double *Velocity_i, *Velocity_j;
    bool implicit, grid_movement, incompressible;
    double Density_i, Density_j,
    q_ij,
    a0, a1;
    unsigned short iDim;
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CUpwSca_TurbSST(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CUpwSca_TurbSST(void);
    
    /*!
     * \brief Compute the scalar upwind flux between two nodes i and j.
     * \param[out] val_residual - Pointer to the total residual.
     * \param[out] val_Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[out] val_Jacobian_j - Jacobian of the numerical method at node j (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual, double **val_Jacobian_i, double **val_Jacobian_j, CConfig *config);
};

/*!
 * \class CUpwSca_TransLM
 * \brief Class for doing a scalar upwind solver for the Spalart-Allmaras turbulence model equations with transition.
 * \ingroup ConvDiscr
 * \author A. Aranake.
 * \version 3.2.9 "eagle"
 */
class CUpwSca_TransLM : public CNumerics {
private:
    double *Velocity_i, *Velocity_j;
    bool implicit, grid_movement;
    double Density_i, Density_j,
    q_ij,
    a0, a1;
    unsigned short iDim;
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CUpwSca_TransLM(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CUpwSca_TransLM(void);
    
    /*!
     * \brief Compute the scalar upwind flux between two nodes i and j.
     * \param[out] val_residual - Pointer to the total residual.
     * \param[out] val_Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[out] val_Jacobian_j - Jacobian of the numerical method at node j (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual, double **val_Jacobian_i, double **val_Jacobian_j, CConfig *config);
};

/*!
 * \class CUpwSca_AdjTurb
 * \brief Class for doing a scalar upwind solver for the adjoint turbulence equations.
 * \ingroup ConvDiscr
 * \author A. Bueno.
 * \version 3.2.9 "eagle"
 */
class CUpwSca_AdjTurb : public CNumerics {
private:
    double *Velocity_i, *Velocity_j;
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CUpwSca_AdjTurb(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CUpwSca_AdjTurb(void);
    
    /*!
     * \param[out] val_residual_i - Pointer to the total residual at point i.
     * \param[out] val_residual_j - Pointer to the total viscosity residual at point j.
     * \param[out] val_Jacobian_ii - Jacobian of the numerical method at node i (implicit computation) from node i.
     * \param[out] val_Jacobian_ij - Jacobian of the numerical method at node i (implicit computation) from node j.
     * \param[out] val_Jacobian_ji - Jacobian of the numerical method at node j (implicit computation) from node i.
     * \param[out] val_Jacobian_jj - Jacobian of the numerical method at node j (implicit computation) from node j.
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual_i, double *val_residual_j, double **val_Jacobian_ii, double **val_Jacobian_ij,
                         double **val_Jacobian_ji, double **val_Jacobian_jj, CConfig *config);
};


/*!
 * \class CCentJST_Flow
 * \brief Class for centered shceme - JST.
 * \ingroup ConvDiscr
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CCentJST_KE_Flow : public CNumerics {
    
private:
    unsigned short iDim, iVar, jVar; /*!< \brief Iteration on dimension and variables. */
    double *Diff_U, *Diff_Lapl, /*!< \brief Diference of conservative variables and undivided laplacians. */
    *Velocity_i, *Velocity_j, /*!< \brief Velocity at node 0 and 1. */
    *MeanVelocity, ProjVelocity, ProjVelocity_i, ProjVelocity_j,  /*!< \brief Mean and projected velocities. */
    Density_i, Density_j, Energy_i, Energy_j,  /*!< \brief Mean Density and energies. */
    sq_vel_i, sq_vel_j,   /*!< \brief Modulus of the velocity and the normal vector. */
    MeanDensity, MeanPressure, MeanEnthalpy, MeanEnergy, /*!< \brief Mean values of primitive variables. */
    Param_p, Param_Kappa_2, Param_Kappa_4, /*!< \brief Artificial dissipation parameters. */
    Local_Lambda_i, Local_Lambda_j, MeanLambda, /*!< \brief Local eingenvalues. */
    Phi_i, Phi_j, sc2, sc4, StretchingFactor, /*!< \brief Streching parameters. */
    *ProjFlux,  /*!< \brief Projected inviscid flux tensor. */
    Epsilon_2, Epsilon_4, cte_0, cte_1, /*!< \brief Artificial dissipation values. */
    ProjGridVel_i, ProjGridVel_j, ProjGridVel;  /*!< \brief Projected grid velocity. */
    bool implicit, /*!< \brief Implicit calculation. */
    grid_movement, /*!< \brief Modification for grid movement. */
    stretching; /*!< \brief Stretching factor. */
    
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimension of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CCentJST_KE_Flow(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CCentJST_KE_Flow(void);
    
    /*!
     * \brief Compute the flow residual using a JST method.
     * \param[out] val_resconv - Pointer to the convective residual.
     * \param[out] val_resvisc - Pointer to the artificial viscosity residual.
     * \param[out] val_Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[out] val_Jacobian_j - Jacobian of the numerical method at node j (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual, double **val_Jacobian_i, double **val_Jacobian_j,
                         CConfig *config);
};

/*!
 * \class CCentJST_Flow
 * \brief Class for centered scheme - JST.
 * \ingroup ConvDiscr
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CCentJST_Flow : public CNumerics {
    
private:
    unsigned short iDim, iVar, jVar; /*!< \brief Iteration on dimension and variables. */
    double *Diff_U, *Diff_Lapl, /*!< \brief Diference of conservative variables and undivided laplacians. */
    *Velocity_i, *Velocity_j, /*!< \brief Velocity at node 0 and 1. */
    *MeanVelocity, ProjVelocity, ProjVelocity_i, ProjVelocity_j,  /*!< \brief Mean and projected velocities. */
    Density_i, Density_j, Energy_i, Energy_j,  /*!< \brief Mean Density and energies. */
    sq_vel_i, sq_vel_j,   /*!< \brief Modulus of the velocity and the normal vector. */
    MeanDensity, MeanPressure, MeanEnthalpy, MeanEnergy, /*!< \brief Mean values of primitive variables. */
    Param_p, Param_Kappa_2, Param_Kappa_4, /*!< \brief Artificial dissipation parameters. */
    Local_Lambda_i, Local_Lambda_j, MeanLambda, /*!< \brief Local eingenvalues. */
    Phi_i, Phi_j, sc2, sc4, StretchingFactor, /*!< \brief Streching parameters. */
    *ProjFlux,  /*!< \brief Projected inviscid flux tensor. */
    Epsilon_2, Epsilon_4, cte_0, cte_1, /*!< \brief Artificial dissipation values. */
    ProjGridVel_i, ProjGridVel_j, ProjGridVel;  /*!< \brief Projected grid velocity. */
    bool implicit, /*!< \brief Implicit calculation. */
    grid_movement, /*!< \brief Modification for grid movement. */
    stretching; /*!< \brief Stretching factor. */
    
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimension of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CCentJST_Flow(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CCentJST_Flow(void);
    
    /*!
     * \brief Compute the flow residual using a JST method.
     * \param[out] val_resconv - Pointer to the convective residual.
     * \param[out] val_resvisc - Pointer to the artificial viscosity residual.
     * \param[out] val_Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[out] val_Jacobian_j - Jacobian of the numerical method at node j (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual, double **val_Jacobian_i, double **val_Jacobian_j,
                         CConfig *config);
};

/*!
 * \class CCentJSTArtComp_Flow
 * \brief Class for centered scheme - JST (artificial compressibility).
 * \ingroup ConvDiscr
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CCentJSTArtComp_Flow : public CNumerics {
    
private:
    unsigned short iDim, iVar, jVar; /*!< \brief Iteration on dimension and variables. */
    double *Diff_U, *Diff_Lapl, /*!< \brief Diference of conservative variables and undivided laplacians. */
    *Velocity_i, *Velocity_j, /*!< \brief Velocity at node 0 and 1. */
    *MeanVelocity, ProjVelocity, ProjVelocity_i, ProjVelocity_j,  /*!< \brief Mean and projected velocities. */
    sq_vel_i, sq_vel_j,   /*!< \brief Modulus of the velocity and the normal vector. */
    MeanGravityForce, MeanDensity, MeanPressure, MeanEnthalpy, MeanEnergy, MeanBetaInc2, /*!< \brief Mean values of primitive variables. */
    Param_p, Param_Kappa_2, Param_Kappa_4, /*!< \brief Artificial dissipation parameters. */
    Local_Lambda_i, Local_Lambda_j, MeanLambda, /*!< \brief Local eingenvalues. */
    Phi_i, Phi_j, sc2, sc4, StretchingFactor, /*!< \brief Streching parameters. */
    *ProjFlux,  /*!< \brief Projected inviscid flux tensor. */
    Epsilon_2, Epsilon_4, cte_0, cte_1; /*!< \brief Artificial dissipation values. */
    bool implicit, /*!< \brief Implicit calculation. */
    grid_movement, /*!< \brief Modification for grid movement. */
    stretching, /*!< \brief Stretching factor. */
    gravity; /*!< \brief computation with gravity force. */
    double Froude; /*!< \brief Froude number. */
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimension of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CCentJSTArtComp_Flow(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CCentJSTArtComp_Flow(void);
    
    /*!
     * \brief Compute the flow residual using a JST method.
     * \param[out] val_resconv - Pointer to the convective residual.
     * \param[out] val_resvisc - Pointer to the artificial viscosity residual.
     * \param[out] val_Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[out] val_Jacobian_j - Jacobian of the numerical method at node j (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual, double **val_Jacobian_i, double **val_Jacobian_j,
                         CConfig *config);
};

/*!
 * \class CCentJST_AdjFlow
 * \brief Class for and adjoint centered scheme - JST.
 * \ingroup ConvDiscr
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CCentJST_AdjFlow : public CNumerics {
private:
    double *Diff_Psi, *Diff_Lapl;
    double *Velocity_i, *Velocity_j;
    double *MeanPhi;
    unsigned short iDim, jDim, iVar, jVar;
    double Residual, ProjVelocity_i, ProjVelocity_j, ProjPhi, ProjPhi_Vel, sq_vel, phis1, phis2;
    double MeanPsiRho, MeanPsiE, Param_p, Param_Kappa_4, Param_Kappa_2, Local_Lambda_i, Local_Lambda_j, MeanLambda;
    double Phi_i, Phi_j, sc4, StretchingFactor, Epsilon_4, Epsilon_2;
    bool implicit, stretching, grid_movement;
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CCentJST_AdjFlow(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CCentJST_AdjFlow(void);
    
    /*!
     * \brief Compute the adjoint flow residual using a JST method.
     * \param[out] val_resconv_i - Pointer to the convective residual at point i.
     * \param[out] val_resvisc_i - Pointer to the artificial viscosity residual at point i.
     * \param[out] val_resconv_j - Pointer to the convective residual at point j.
     * \param[out] val_resvisc_j - Pointer to the artificial viscosity residual at point j.
     * \param[out] val_Jacobian_ii - Jacobian of the numerical method at node i (implicit computation) from node i.
     * \param[out] val_Jacobian_ij - Jacobian of the numerical method at node i (implicit computation) from node j.
     * \param[out] val_Jacobian_ji - Jacobian of the numerical method at node j (implicit computation) from node i.
     * \param[out] val_Jacobian_jj - Jacobian of the numerical method at node j (implicit computation) from node j.
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual (double *val_resconv_i, double *val_resvisc_i, double *val_resconv_j, double *val_resvisc_j,
                          double **val_Jacobian_ii, double **val_Jacobian_ij, double **val_Jacobian_ji, double **val_Jacobian_jj,
                          CConfig *config);
};

/*!
 * \class CCentJSTArtComp_AdjFlow
 * \brief Class for and adjoint centered scheme - JST.
 * \ingroup ConvDiscr
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CCentJSTArtComp_AdjFlow : public CNumerics {
private:
    double sc2, *Diff_Psi, *Diff_Lapl;
    double *Velocity_i, *Velocity_j;
    double *MeanPhi, **Proj_Jac_Tensor_i, **Proj_Jac_Tensor_j;
    unsigned short iDim, jDim, iVar, jVar;
    double Residual, ProjVelocity_i, ProjVelocity_j, ProjPhi, ProjPhi_Vel, sq_vel, phis1, phis2;
    double MeanPsiRho, MeanPsiE, Param_p, Param_Kappa_4, Param_Kappa_2, Local_Lambda_i, Local_Lambda_j, MeanLambda;
    double Phi_i, Phi_j, sc4, StretchingFactor, Epsilon_4, Epsilon_2;
    bool implicit, stretching, grid_movement;
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CCentJSTArtComp_AdjFlow(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CCentJSTArtComp_AdjFlow(void);
    
    /*!
     * \brief Compute the adjoint flow residual using a JST method.
     * \param[out] val_resconv_i - Pointer to the convective residual at point i.
     * \param[out] val_resvisc_i - Pointer to the artificial viscosity residual at point i.
     * \param[out] val_resconv_j - Pointer to the convective residual at point j.
     * \param[out] val_resvisc_j - Pointer to the artificial viscosity residual at point j.
     * \param[out] val_Jacobian_ii - Jacobian of the numerical method at node i (implicit computation) from node i.
     * \param[out] val_Jacobian_ij - Jacobian of the numerical method at node i (implicit computation) from node j.
     * \param[out] val_Jacobian_ji - Jacobian of the numerical method at node j (implicit computation) from node i.
     * \param[out] val_Jacobian_jj - Jacobian of the numerical method at node j (implicit computation) from node j.
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual (double *val_resconv_i, double *val_resvisc_i, double *val_resconv_j, double *val_resvisc_j,
                          double **val_Jacobian_ii, double **val_Jacobian_ij, double **val_Jacobian_ji, double **val_Jacobian_jj,
                          CConfig *config);
};

/*!
 * \class CCentJST_LinFlow
 * \brief Class for linearized centered scheme - JST.
 * \ingroup ConvDiscr
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CCentJST_LinFlow : public CNumerics {
private:
    double *Diff_DeltaU, *Diff_Lapl;
    double *Velocity_i, *Velocity_j;
    double *MeanDeltaVel, *MeanVelocity;
    double **MeanJacobian;
    double **Jacobian_i, **Jacobian_j;
    unsigned short iDim, iVar, jVar;
    double sq_vel, Density_i, DensityEnergy_i, Energy_i, Pressure_i, Density_j, DensityEnergy_j, Energy_j,
    Pressure_j, Param_p, Param_Kappa_4, Local_Lambda_i, Local_Lambda_j, MeanLambda, sc4, StretchingFactor,
    Epsilon_4, MeanDeltaRho, MeanDeltaE, ProjVelocity_i, ProjVelocity_j, MeanDensity, MeanPressure,
    MeanEnthalpy, MeanEnergy, Phi_i, Phi_j;
    bool stretching;
    
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CCentJST_LinFlow(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CCentJST_LinFlow(void);
    
    /*!
     * \brief Compute the linearized flow residual using a JST method.
     * \param[out] val_resconv - Pointer to the convective residual.
     * \param[out] val_resvisc - Pointer to the artificial viscosity residual.
     * \param[out] val_Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[out] val_Jacobian_j - Jacobian of the numerical method at node j (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual (double *val_resconv, double *val_resvisc, double **val_Jacobian_i, double **val_Jacobian_j,
                          CConfig *config);
};

/*!
 * \class CCentLax_Flow
 * \brief Class for computing the Lax-Friedrich centered scheme.
 * \ingroup ConvDiscr
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CCentLax_Flow : public CNumerics {
private:
    unsigned short iDim, iVar, jVar; /*!< \brief Iteration on dimension and variables. */
    double *Diff_U, /*!< \brief Difference of conservative variables. */
    *Velocity_i, *Velocity_j, /*!< \brief Velocity at node 0 and 1. */
    *MeanVelocity, ProjVelocity, ProjVelocity_i, ProjVelocity_j,  /*!< \brief Mean and projected velocities. */
    *ProjFlux,  /*!< \brief Projected inviscid flux tensor. */
    Density_i, Density_j, Energy_i, Energy_j,  /*!< \brief Mean Density and energies. */
    sq_vel_i, sq_vel_j,   /*!< \brief Modulus of the velocity and the normal vector. */
    MeanDensity, MeanPressure, MeanEnthalpy, MeanEnergy, /*!< \brief Mean values of primitive variables. */
    Param_p, Param_Kappa_0, /*!< \brief Artificial dissipation parameters. */
    Local_Lambda_i, Local_Lambda_j, MeanLambda, /*!< \brief Local eingenvalues. */
    Phi_i, Phi_j, sc0, StretchingFactor, /*!< \brief Streching parameters. */
    Epsilon_0, cte; /*!< \brief Artificial dissipation values. */
    bool implicit, /*!< \brief Implicit calculation. */
    grid_movement, /*!< \brief Modification for grid movement. */
    stretching, ProjGridVel;
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimension of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CCentLax_Flow(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CCentLax_Flow(void);
    
    /*!
     * \brief Compute the flow residual using a Lax method.
     * \param[out] val_resconv - Pointer to the convective residual.
     * \param[out] val_resvisc - Pointer to the artificial viscosity residual.
     * \param[out] val_Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[out] val_Jacobian_j - Jacobian of the numerical method at node j (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual, double **val_Jacobian_i, double **val_Jacobian_j,
                         CConfig *config);
};

/*!
 * \class CCentLaxArtComp_Flow
 * \brief Class for computing the Lax-Friedrich centered scheme (artificial compressibility).
 * \ingroup ConvDiscr
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CCentLaxArtComp_Flow : public CNumerics {
private:
    unsigned short iDim, iVar, jVar; /*!< \brief Iteration on dimension and variables. */
    double *Diff_U, /*!< \brief Difference of conservative variables. */
    *Velocity_i, *Velocity_j, /*!< \brief Velocity at node 0 and 1. */
    *MeanVelocity, ProjVelocity, ProjVelocity_i, ProjVelocity_j,  /*!< \brief Mean and projected velocities. */
    *ProjFlux,  /*!< \brief Projected inviscid flux tensor. */
    sq_vel_i, sq_vel_j,   /*!< \brief Modulus of the velocity and the normal vector. */
    MeanGravityForce, MeanDensity, MeanPressure, MeanEnthalpy, MeanEnergy, MeanBetaInc2, /*!< \brief Mean values of primitive variables. */
    Param_p, Param_Kappa_0, /*!< \brief Artificial dissipation parameters. */
    Local_Lambda_i, Local_Lambda_j, MeanLambda, /*!< \brief Local eingenvalues. */
    Phi_i, Phi_j, sc0, StretchingFactor, /*!< \brief Streching parameters. */
    Epsilon_0, cte; /*!< \brief Artificial dissipation values. */
    bool implicit, /*!< \brief Implicit calculation. */
    grid_movement, /*!< \brief Modification for grid movement. */
    gravity; /*!< \brief Modification for for gravity force. */
    bool stretching;
    double Froude;
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimension of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CCentLaxArtComp_Flow(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CCentLaxArtComp_Flow(void);
    
    /*!
     * \brief Compute the flow residual using a Lax method.
     * \param[out] val_resconv - Pointer to the convective residual.
     * \param[out] val_resvisc - Pointer to the artificial viscosity residual.
     * \param[out] val_Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[out] val_Jacobian_j - Jacobian of the numerical method at node j (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual, double **val_Jacobian_i, double **val_Jacobian_j,
                         CConfig *config);
};

/*!
 * \class CCentLax_AdjFlow
 * \brief Class for computing the Lax-Friedrich adjoint centered scheme.
 * \ingroup ConvDiscr
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CCentLax_AdjFlow : public CNumerics {
private:
    double *Diff_Psi;
    double *Velocity_i, *Velocity_j;
    double *MeanPhi;
    unsigned short iDim, jDim, iVar, jVar;
    double Residual, ProjVelocity_i, ProjVelocity_j, ProjPhi, ProjPhi_Vel, sq_vel, phis1, phis2,
    MeanPsiRho, MeanPsiE, Param_p, Param_Kappa_0, Local_Lambda_i, Local_Lambda_j, MeanLambda,
    Phi_i, Phi_j, sc2, StretchingFactor, Epsilon_0, cte_0;
    bool implicit, stretching, grid_movement;
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CCentLax_AdjFlow(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CCentLax_AdjFlow(void);
    
    /*!
     * \brief Compute the adjoint flow residual using a Lax method.
     * \param[out] val_resconv_i - Pointer to the convective residual at point i.
     * \param[out] val_resvisc_i - Pointer to the artificial viscosity residual at point i.
     * \param[out] val_resconv_j - Pointer to the convective residual at point j.
     * \param[out] val_resvisc_j - Pointer to the artificial viscosity residual at point j.
     * \param[out] val_Jacobian_ii - Jacobian of the numerical method at node i (implicit computation) from node i.
     * \param[out] val_Jacobian_ij - Jacobian of the numerical method at node i (implicit computation) from node j.
     * \param[out] val_Jacobian_ji - Jacobian of the numerical method at node j (implicit computation) from node i.
     * \param[out] val_Jacobian_jj - Jacobian of the numerical method at node j (implicit computation) from node j.
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual (double *val_resconv_i, double *val_resvisc_i, double *val_resconv_j, double *val_resvisc_j,
                          double **val_Jacobian_ii, double **val_Jacobian_ij, double **val_Jacobian_ji, double **val_Jacobian_jj,
                          CConfig *config);
};

/*!
 * \class CCentLaxArtComp_AdjFlow
 * \brief Class for computing the Lax-Friedrich adjoint centered scheme.
 * \ingroup ConvDiscr
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CCentLaxArtComp_AdjFlow : public CNumerics {
private:
    double *Diff_Psi;
    double *Velocity_i, *Velocity_j;
    double *MeanPhi, **Proj_Jac_Tensor_i, **Proj_Jac_Tensor_j;
    unsigned short iDim, jDim, iVar, jVar;
    double Residual, ProjVelocity_i, ProjVelocity_j, ProjPhi, ProjPhi_Vel, sq_vel, phis1, phis2,
    MeanPsiRho, MeanPsiE, Param_p, Param_Kappa_0, Local_Lambda_i, Local_Lambda_j, MeanLambda,
    Phi_i, Phi_j, sc2, StretchingFactor, Epsilon_0, cte_0;
    bool implicit, stretching;
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CCentLaxArtComp_AdjFlow(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CCentLaxArtComp_AdjFlow(void);
    
    /*!
     * \brief Compute the adjoint flow residual using a Lax method.
     * \param[out] val_resconv_i - Pointer to the convective residual at point i.
     * \param[out] val_resvisc_i - Pointer to the artificial viscosity residual at point i.
     * \param[out] val_resconv_j - Pointer to the convective residual at point j.
     * \param[out] val_resvisc_j - Pointer to the artificial viscosity residual at point j.
     * \param[out] val_Jacobian_ii - Jacobian of the numerical method at node i (implicit computation) from node i.
     * \param[out] val_Jacobian_ij - Jacobian of the numerical method at node i (implicit computation) from node j.
     * \param[out] val_Jacobian_ji - Jacobian of the numerical method at node j (implicit computation) from node i.
     * \param[out] val_Jacobian_jj - Jacobian of the numerical method at node j (implicit computation) from node j.
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual (double *val_resconv_i, double *val_resvisc_i, double *val_resconv_j, double *val_resvisc_j,
                          double **val_Jacobian_ii, double **val_Jacobian_ij, double **val_Jacobian_ji, double **val_Jacobian_jj,
                          CConfig *config);
};

/*!
 * \class CCentLax_LinFlow
 * \brief Class for computing the Lax-Friedrich linearized centered scheme.
 * \ingroup ConvDiscr
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CCentLax_LinFlow : public CNumerics {
private:
    double *Diff_DeltaU;
    double *Velocity_i, *Velocity_j;
    double *MeanDeltaVel, *MeanVelocity;
    double **MeanJacobian;
    double **Jacobian_i;
    double **Jacobian_j;
    unsigned short iDim, iVar, jVar;
    double sq_vel, Density_i, DensityEnergy_i, Energy_i, Pressure_i, Density_j,
    DensityEnergy_j, Energy_j, Pressure_j, Param_p, Param_Kappa_0,
    Local_Lambda_i, Local_Lambda_j, MeanLambda, cte_0, StretchingFactor,
    Epsilon_i, MeanDeltaRho, MeanDeltaE, ProjVelocity_i, ProjVelocity_j,
    dS, MeanDensity, MeanPressure,
    MeanEnthalpy, MeanEnergy, Phi_i, Phi_j,
    sc2;
    bool stretching;
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CCentLax_LinFlow(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CCentLax_LinFlow(void);
    
    /*!
     * \brief Compute the linearized flow residual using a Lax method.
     * \param[out] val_resconv - Pointer to the convective residual.
     * \param[out] val_resvisc - Pointer to the artificial viscosity residual.
     * \param[out] val_Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[out] val_Jacobian_j - Jacobian of the numerical method at node j (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_resconv, double *val_resvisc, double **val_Jacobian_i, double **val_Jacobian_j, CConfig *config);
};

/*!
 * \class CAvgGrad_Flow
 * \brief Class for computing viscous term using the average of gradients.
 * \ingroup ViscDiscr
 * \author A. Bueno, and F. Palacios
 * \version 3.2.9 "eagle"
 */
class CAvgGrad_Flow : public CNumerics {
private:
    unsigned short iDim, iVar, jVar;	   /*!< \brief Iterators in dimension an variable. */
    double *Mean_PrimVar,				   /*!< \brief Mean primitive variables. */
    *PrimVar_i, *PrimVar_j,				   /*!< \brief Primitives variables at point i and 1. */
    **Mean_GradPrimVar,					   /*!< \brief Mean value of the gradient. */
    Mean_Laminar_Viscosity,                /*!< \brief Mean value of the viscosity. */
    Mean_Eddy_Viscosity,                   /*!< \brief Mean value of the eddy viscosity. */
    Mean_Thermal_Conductivity,             /*!< \brief Mean value of the thermal conductivity. */
    Mean_Cp,                               /*!< \brief Mean value of the Cp. */
    Mean_turb_ke,				/*!< \brief Mean value of the turbulent kinetic energy. */
    *ProjFlux,	/*!< \brief Projection of the viscous fluxes. */
    dist_ij;						/*!< \brief Length of the edge and face. */
    bool implicit; /*!< \brief Implicit calculus. */
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimension of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CAvgGrad_Flow(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CAvgGrad_Flow(void);
    
    /*!
     * \brief Compute the viscous flow residual using an average of gradients.
     * \param[out] val_residual - Pointer to the total residual.
     * \param[out] val_Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[out] val_Jacobian_j - Jacobian of the numerical method at node j (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual, double **val_Jacobian_i, double **val_Jacobian_j, CConfig *config);
};

/*!
 * \class CGeneralAvgGrad_Flow
 * \brief Class for computing viscous term using the average of gradients.
 * \ingroup ViscDiscr
 * \author M.Pini, S. Vitale
 * \version 3.2.1 "eagle"
 */

class CGeneralAvgGrad_Flow : public CNumerics {
private:
    unsigned short iDim, iVar, jVar;	   /*!< \brief Iterators in dimension an variable. */
    double *Mean_PrimVar,				   /*!< \brief Mean primitive variables. */
    *Mean_SecVar,        				   /*!< \brief Mean secondary variables. */
    *PrimVar_i, *PrimVar_j,				   /*!< \brief Primitives variables at point i and 1. */
    **Mean_GradPrimVar,					   /*!< \brief Mean value of the gradient. */
    Mean_Laminar_Viscosity,                /*!< \brief Mean value of the viscosity. */
    Mean_Eddy_Viscosity,                   /*!< \brief Mean value of the eddy viscosity. */
    Mean_Thermal_Conductivity,             /*!< \brief Mean value of the thermal conductivity. */
    Mean_Cp,                               /*!< \brief Mean value of the Cp. */
    Mean_turb_ke,				/*!< \brief Mean value of the turbulent kinetic energy. */
    *ProjFlux,	/*!< \brief Projection of the viscous fluxes. */
    dist_ij;						/*!< \brief Length of the edge and face. */
    bool implicit; /*!< \brief Implicit calculus. */
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimension of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CGeneralAvgGrad_Flow(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CGeneralAvgGrad_Flow(void);
    
    /*!
     * \brief Compute the viscous flow residual using an average of gradients.
     * \param[out] val_residual - Pointer to the total residual.
     * \param[out] val_Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[out] val_Jacobian_j - Jacobian of the numerical method at node j (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual, double **val_Jacobian_i, double **val_Jacobian_j, CConfig *config);
};

/*!
 * \class CAvgGradArtComp_Flow
 * \brief Class for computing viscous term using an average of gradients.
 * \ingroup ViscDiscr
 * \author A. Bueno, and F. Palacios
 * \version 3.2.9 "eagle"
 */
class CAvgGradArtComp_Flow : public CNumerics {
private:
    unsigned short iDim, iVar, jVar;	/*!< \brief Iterators in dimension an variable. */
    double **Mean_GradPrimVar,					/*!< \brief Mean value of the gradient. */
    Mean_Laminar_Viscosity, Mean_Eddy_Viscosity, /*!< \brief Mean value of the viscosity. */
    *ProjFlux,		/*!< \brief Projection of the viscous fluxes. */
    dist_ij;							/*!< \brief Length of the edge and face. */
    bool implicit;				/*!< \brief Implicit calculus. */
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimension of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CAvgGradArtComp_Flow(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CAvgGradArtComp_Flow(void);
    /*!
     * \brief Compute the viscous flow residual using an average of gradients.
     * \param[out] val_residual - Pointer to the total residual.
     * \param[out] val_Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[out] val_Jacobian_j - Jacobian of the numerical method at node j (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual, double **val_Jacobian_i, double **val_Jacobian_j, CConfig *config);
};

/*!
 * \class CAvgGrad_TurbSA
 * \brief Class for computing viscous term using average of gradients (Spalart-Allmaras Turbulence model).
 * \ingroup ViscDiscr
 * \author A. Bueno.
 * \version 3.2.9 "eagle"
 */
class CAvgGrad_TurbSA : public CNumerics {
private:
    
    double **Mean_GradTurbVar;
    double *Proj_Mean_GradTurbVar_Kappa, *Proj_Mean_GradTurbVar_Edge;
    double *Edge_Vector;
    bool implicit, incompressible;
    double sigma;
    double nu_i, nu_j, nu_e;
    double dist_ij_2;
    double proj_vector_ij;
    unsigned short iVar, iDim;
    double nu_hat_i;
    double nu_hat_j;
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CAvgGrad_TurbSA(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CAvgGrad_TurbSA(void);
    
    /*!
     * \brief Compute the viscous turbulence terms residual using an average of gradients.
     * \param[out] val_residual - Pointer to the total residual.
     * \param[out] Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[out] Jacobian_j - Jacobian of the numerical method at node j (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual, double **Jacobian_i, double **Jacobian_j, CConfig *config);
};

/*!
 * \class CAvgGrad_TurbSA_Neg
 * \brief Class for computing viscous term using average of gradients (Spalart-Allmaras Turbulence model).
 * \ingroup ViscDiscr
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CAvgGrad_TurbSA_Neg : public CNumerics {
private:
    
    double **Mean_GradTurbVar;
    double *Proj_Mean_GradTurbVar_Kappa, *Proj_Mean_GradTurbVar_Edge;
    double *Edge_Vector;
    bool implicit, incompressible;
    double sigma;
    double cn1, fn, Xi;
    double nu_i, nu_j, nu_ij, nu_tilde_ij, nu_e;
    double dist_ij_2;
    double proj_vector_ij;
    unsigned short iVar, iDim;
    double nu_hat_i;
    double nu_hat_j;
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CAvgGrad_TurbSA_Neg(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CAvgGrad_TurbSA_Neg(void);
    
    /*!
     * \brief Compute the viscous turbulence terms residual using an average of gradients.
     * \param[out] val_residual - Pointer to the total residual.
     * \param[out] Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[out] Jacobian_j - Jacobian of the numerical method at node j (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual, double **Jacobian_i, double **Jacobian_j, CConfig *config);
};

/*!
 * \class CAvgGrad_TurbML
 * \brief Class for computing viscous term using average of gradients (Spalart-Allmaras Turbulence model).
 * \ingroup ViscDiscr
 * \author A. Bueno.
 * \version 3.2.9 "eagle"
 */
class CAvgGrad_TurbML : public CNumerics {
private:
    double **Mean_GradTurbVar;
    double *Proj_Mean_GradTurbVar_Kappa, *Proj_Mean_GradTurbVar_Edge;
    double *Edge_Vector;
    bool implicit, incompressible;
    double sigma;
    double nu_i, nu_j, nu_e;
    double dist_ij_2;
    double proj_vector_ij;
    unsigned short iVar, iDim;
    double nu_hat_i;
    double nu_hat_j;
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CAvgGrad_TurbML(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CAvgGrad_TurbML(void);
    
    /*!
     * \brief Compute the viscous turbulence terms residual using an average of gradients.
     * \param[out] val_residual - Pointer to the total residual.
     * \param[out] Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[out] Jacobian_j - Jacobian of the numerical method at node j (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual, double **Jacobian_i, double **Jacobian_j, CConfig *config);
};

/*!
 * \class CAvgGrad_TransLM
 * \brief Class for computing viscous term using average of gradients (Spalart-Allmaras Turbulence model).
 * \ingroup ViscDiscr
 * \author A. Bueno.
 * \version 3.2.9 "eagle"
 */
class CAvgGrad_TransLM : public CNumerics {
private:
    double **Mean_GradTransVar;
    double *Proj_Mean_GradTransVar_Kappa, *Proj_Mean_GradTransVar_Edge;
    double *Edge_Vector;
    bool implicit, incompressible;
    double sigma;
    double nu_i, nu_j, nu_e;
    double dist_ij_2;
    double proj_vector_ij;
    unsigned short iVar, iDim;
    double nu_hat_i;
    double nu_hat_j;
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CAvgGrad_TransLM(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CAvgGrad_TransLM(void);
    
    /*!
     * \brief Compute the viscous turbulence terms residual using an average of gradients.
     * \param[out] val_residual - Pointer to the total residual.
     * \param[out] Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[out] Jacobian_j - Jacobian of the numerical method at node j (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual, double **Jacobian_i, double **Jacobian_j, CConfig *config);
};

/*!
 * \class CAvgGrad_AdjFlow
 * \brief Class for computing the adjoint viscous terms.
 * \ingroup ViscDiscr
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CAvgGrad_AdjFlow : public CNumerics {
private:
    double *Velocity_i;	/*!< \brief Auxiliary vector for storing the velocity of point i. */
    double *Velocity_j;	/*!< \brief Auxiliary vector for storing the velocity of point j. */
    double *Mean_Velocity;
    double *Mean_GradPsiE;	/*!< \brief Counter for dimensions of the problem. */
    double **Mean_GradPhi;	/*!< \brief Counter for dimensions of the problem. */
    double *Edge_Vector;	/*!< \brief Vector going from node i to node j. */
    bool implicit;			/*!< \brief Implicit calculus. */
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CAvgGrad_AdjFlow(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CAvgGrad_AdjFlow(void);
    
    /*!
     * \brief Residual computation.
     * \param[out] val_residual_i - Pointer to the total residual at point i.
     * \param[out] val_residual_j - Pointer to the total residual at point j.
     */
    void ComputeResidual(double *val_residual_i, double *val_residual_j,
                         double **val_Jacobian_ii, double **val_Jacobian_ij,
                         double **val_Jacobian_ji, double **val_Jacobian_jj, CConfig *config);
};

/*!
 * \class CAvgGradArtComp_AdjFlow
 * \brief Class for computing the adjoint viscous terms.
 * \ingroup ViscDiscr
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CAvgGradArtComp_AdjFlow : public CNumerics {
private:
    unsigned short iDim, iVar, jVar;	/*!< \brief Iterators in dimension an variable. */
    double **Mean_GradPsiVar,					/*!< \brief Mean value of the gradient. */
    Mean_Laminar_Viscosity, Mean_Eddy_Viscosity, /*!< \brief Mean value of the viscosity. */
    *ProjFlux,		/*!< \brief Projection of the viscous fluxes. */
    dist_ij;							/*!< \brief Length of the edge and face. */
    bool implicit;				/*!< \brief Implicit calculus. */
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CAvgGradArtComp_AdjFlow(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CAvgGradArtComp_AdjFlow(void);
    
    /*!
     * \brief Residual computation.
     * \param[out] val_residual_i - Pointer to the total residual at point i.
     * \param[out] val_residual_j - Pointer to the total residual at point j.
     */
    void ComputeResidual(double *val_residual_i, double *val_residual_j,
                         double **val_Jacobian_ii, double **val_Jacobian_ij,
                         double **val_Jacobian_ji, double **val_Jacobian_jj, CConfig *config);
};

/*!
 * \class CAvgGradCorrected_Flow
 * \brief Class for computing viscous term using the average of gradients with a correction.
 * \ingroup ViscDiscr
 * \author A. Bueno, and F. Palacios
 * \version 3.2.9 "eagle"
 */
class CAvgGradCorrected_Flow : public CNumerics {
private:
    unsigned short iDim, iVar, jVar;		/*!< \brief Iterators in dimension an variable. */
    double *Mean_PrimVar,					/*!< \brief Mean primitive variables. */
    *PrimVar_i, *PrimVar_j,				/*!< \brief Primitives variables at point i and 1. */
    *Edge_Vector,									/*!< \brief Vector form point i to point j. */
    **Mean_GradPrimVar, *Proj_Mean_GradPrimVar_Edge,	/*!< \brief Mean value of the gradient. */
    Mean_Laminar_Viscosity,      /*!< \brief Mean value of the laminar viscosity. */
    Mean_Eddy_Viscosity,         /*!< \brief Mean value of the eddy viscosity. */
    Mean_Thermal_Conductivity,   /*!< \brief Mean value of the thermal conductivity. */
    Mean_Cp,                     /*!< \brief Mean value of the specific heat. */
    Mean_turb_ke,				 /*!< \brief Mean value of the turbulent kinetic energy. */
    dist_ij_2,					 /*!< \brief Length of the edge and face. */
    *ProjFlux;	/*!< \brief Projection of the viscous fluxes. */
    bool implicit;			/*!< \brief Implicit calculus. */
    bool limiter;			/*!< \brief Viscous limiter. */
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimension of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CAvgGradCorrected_Flow(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CAvgGradCorrected_Flow(void);
    
    /*!
     * \brief Compute the viscous flow residual using an average of gradients with correction.
     * \param[out] val_residual - Pointer to the total residual.
     * \param[out] val_Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[out] val_Jacobian_j - Jacobian of the numerical method at node j (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual, double **val_Jacobian_i, double **val_Jacobian_j, CConfig *config);
};


/*!
 * \class CGeneralAvgGradCorrected_Flow
 * \brief Class for computing viscous term using the average of gradients with a correction.
 * \ingroup ViscDiscr
 * \author M. Pini, S. Vitale
 * \version 3.2.1 "eagle"
 */
class CGeneralAvgGradCorrected_Flow : public CNumerics {
private:
    unsigned short iDim, iVar, jVar;		/*!< \brief Iterators in dimension an variable. */
    double *Mean_PrimVar,					/*!< \brief Mean primitive variables. */
    *Mean_SecVar,			        		/*!< \brief Mean primitive variables. */
    *PrimVar_i, *PrimVar_j,			    	/*!< \brief Primitives variables at point i and 1. */
    *Edge_Vector,									/*!< \brief Vector form point i to point j. */
    **Mean_GradPrimVar, *Proj_Mean_GradPrimVar_Edge,	/*!< \brief Mean value of the gradient. */
    Mean_Laminar_Viscosity,      /*!< \brief Mean value of the laminar viscosity. */
    Mean_Eddy_Viscosity,         /*!< \brief Mean value of the eddy viscosity. */
    Mean_Thermal_Conductivity,   /*!< \brief Mean value of the thermal conductivity. */
    Mean_Cp,                     /*!< \brief Mean value of the specific heat. */
    Mean_turb_ke,				 /*!< \brief Mean value of the turbulent kinetic energy. */
    dist_ij_2,					 /*!< \brief Length of the edge and face. */
    *ProjFlux;	/*!< \brief Projection of the viscous fluxes. */
    bool implicit;			/*!< \brief Implicit calculus. */
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimension of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CGeneralAvgGradCorrected_Flow(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CGeneralAvgGradCorrected_Flow(void);
    
    /*!
     * \brief Compute the viscous flow residual using an average of gradients with correction.
     * \param[out] val_residual - Pointer to the total residual.
     * \param[out] val_Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[out] val_Jacobian_j - Jacobian of the numerical method at node j (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual, double **val_Jacobian_i, double **val_Jacobian_j, CConfig *config);
};

/*!
 * \class CAvgGradCorrectedArtComp_Flow
 * \brief Class for computing viscous term using an average of gradients with correction (artificial compresibility).
 * \ingroup ViscDiscr
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CAvgGradCorrectedArtComp_Flow : public CNumerics {
private:
    unsigned short iDim, iVar, jVar;	/*!< \brief Iterators in dimension an variable. */
    double *PrimVar_i, *PrimVar_j,			/*!< \brief Primitives variables at point i and 1. */
    *Edge_Vector,								/*!< \brief Vector form point i to point j. */
    **Mean_GradPrimVar, *Proj_Mean_GradPrimVar_Edge,	/*!< \brief Mean value of the gradient. */
    Mean_Laminar_Viscosity, Mean_Eddy_Viscosity,			/*!< \brief Mean value of the viscosity. */
    dist_ij_2,					/*!< \brief Length of the edge and face. */
    *ProjFlux;	/*!< \brief Projection of the viscous fluxes. */
    bool implicit;			/*!< \brief Implicit calculus. */
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimension of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CAvgGradCorrectedArtComp_Flow(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CAvgGradCorrectedArtComp_Flow(void);
    
    /*!
     * \brief Compute the viscous flow residual using an average of gradients with correction.
     * \param[out] val_residual - Pointer to the total residual.
     * \param[out] val_Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[out] val_Jacobian_j - Jacobian of the numerical method at node j (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual, double **val_Jacobian_i, double **val_Jacobian_j, CConfig *config);
};

/*!
 * \class CAvgGradCorrected_TurbSA
 * \brief Class for computing viscous term using average of gradients with correction (Spalart-Allmaras turbulence model).
 * \ingroup ViscDiscr
 * \author A. Bueno.
 * \version 3.2.9 "eagle"
 */
class CAvgGradCorrected_TurbSA : public CNumerics {
private:
    double **Mean_GradTurbVar;
    double *Proj_Mean_GradTurbVar_Kappa, *Proj_Mean_GradTurbVar_Edge, *Proj_Mean_GradTurbVar_Corrected;
    double *Edge_Vector;
    bool implicit, incompressible;
    double sigma, nu_i, nu_j, nu_e, dist_ij_2, proj_vector_ij, nu_hat_i, nu_hat_j;
    unsigned short iVar, iDim;
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CAvgGradCorrected_TurbSA(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CAvgGradCorrected_TurbSA(void);
    
    /*!
     * \brief Compute the viscous turbulent residual using an average of gradients with correction.
     * \param[out] val_residual - Pointer to the total residual.
     * \param[out] Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[out] Jacobian_j - Jacobian of the numerical method at node j (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual, double **Jacobian_i, double **Jacobian_j, CConfig *config);
};

/*!
 * \class CAvgGradCorrected_TurbSA_Neg
 * \brief Class for computing viscous term using average of gradients with correction (Spalart-Allmaras turbulence model).
 * \ingroup ViscDiscr
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CAvgGradCorrected_TurbSA_Neg : public CNumerics {
private:
    
    double **Mean_GradTurbVar;
    double *Proj_Mean_GradTurbVar_Kappa, *Proj_Mean_GradTurbVar_Edge, *Proj_Mean_GradTurbVar_Corrected;
    double *Edge_Vector;
    double sigma;
    double cn1, fn, Xi;
    double nu_ij, nu_tilde_ij;
    bool implicit, incompressible;
    double nu_i, nu_j, nu_e, dist_ij_2, proj_vector_ij, nu_hat_i, nu_hat_j;
    unsigned short iVar, iDim;
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CAvgGradCorrected_TurbSA_Neg(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CAvgGradCorrected_TurbSA_Neg(void);
    
    /*!
     * \brief Compute the viscous turbulent residual using an average of gradients with correction.
     * \param[out] val_residual - Pointer to the total residual.
     * \param[out] Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[out] Jacobian_j - Jacobian of the numerical method at node j (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual, double **Jacobian_i, double **Jacobian_j, CConfig *config);
};

/*!
 * \class CAvgGradCorrected_TurbML
 * \brief Class for computing viscous term using average of gradients with correction (Spalart-Allmaras turbulence model).
 * \ingroup ViscDiscr
 * \author A. Bueno.
 * \version 3.2.9 "eagle"
 */
class CAvgGradCorrected_TurbML : public CNumerics {
private:
    double **Mean_GradTurbVar;
    double *Proj_Mean_GradTurbVar_Kappa, *Proj_Mean_GradTurbVar_Edge, *Proj_Mean_GradTurbVar_Corrected;
    double *Edge_Vector;
    bool implicit, incompressible;
    double sigma, nu_i, nu_j, nu_e, dist_ij_2, proj_vector_ij, nu_hat_i, nu_hat_j;
    unsigned short iVar, iDim;
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CAvgGradCorrected_TurbML(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CAvgGradCorrected_TurbML(void);
    
    /*!
     * \brief Compute the viscous turbulent residual using an average of gradients with correction.
     * \param[out] val_residual - Pointer to the total residual.
     * \param[out] Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[out] Jacobian_j - Jacobian of the numerical method at node j (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual, double **Jacobian_i, double **Jacobian_j, CConfig *config);
};

/*!
 * \class CAvgGradCorrected_TransLM
 * \brief Class for computing viscous term using average of gradients with correction (Spalart-Allmaras turbulence model).
 * \ingroup ViscDiscr
 * \author A. Bueno.
 * \version 3.2.9 "eagle"
 */
class CAvgGradCorrected_TransLM : public CNumerics {
private:
    double **Mean_GradTurbVar;
    double *Proj_Mean_GradTurbVar_Kappa, *Proj_Mean_GradTurbVar_Edge, *Proj_Mean_GradTurbVar_Corrected;
    double *Edge_Vector;
    bool implicit, incompressible;
    double sigma, nu_i, nu_j, nu_e, dist_ij_2, proj_vector_ij, nu_hat_i, nu_hat_j;
    unsigned short iVar, iDim;
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CAvgGradCorrected_TransLM(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CAvgGradCorrected_TransLM(void);
    
    /*!
     * \brief Compute the viscous turbulent residual using an average of gradients with correction.
     * \param[out] val_residual - Pointer to the total residual.
     * \param[out] Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[out] Jacobian_j - Jacobian of the numerical method at node j (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual, double **Jacobian_i, double **Jacobian_j, CConfig *config);
};

/*!
 * \class CAvgGrad_TurbSST
 * \brief Class for computing viscous term using average of gradient with correction (Menter SST turbulence model).
 * \ingroup ViscDiscr
 * \author A. Bueno.
 * \version 3.2.9 "eagle"
 */
class CAvgGrad_TurbSST : public CNumerics {
private:
    double sigma_k1,                     /*!< \brief Constants for the viscous terms, k-w (1), k-eps (2)*/
    sigma_k2,
    sigma_om1,
    sigma_om2;
    
    double diff_kine,                     /*!< \brief Diffusivity for viscous terms of tke eq */
    diff_omega;                           /*!< \brief Diffusivity for viscous terms of omega eq */
    
    double *Edge_Vector,                  /*!< \brief Vector from node i to node j. */
    dist_ij_2,                            /*!< \brief |Edge_Vector|^2 */
    proj_vector_ij;                       /*!< \brief (Edge_Vector DOT normal)/|Edge_Vector|^2 */
    
    double **Mean_GradTurbVar,            /*!< \brief Average of gradients at cell face */
    *Proj_Mean_GradTurbVar_Normal,        /*!< \brief Mean_gradTurbVar DOT normal */
    *Proj_Mean_GradTurbVar_Edge,          /*!< \brief Mean_gradTurbVar DOT Edge_Vector */
    *Proj_Mean_GradTurbVar_Corrected;
    
    double F1_i, F1_j;                    /*!< \brief Menter's first blending function */
    
    bool implicit, incompressible;
    unsigned short iVar, iDim;
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CAvgGrad_TurbSST(unsigned short val_nDim, unsigned short val_nVar, double* constants, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CAvgGrad_TurbSST(void);
    
    /*!
     * \brief Sets value of first blending function.
     */
    void SetF1blending(double val_F1_i, double val_F1_j) { F1_i = val_F1_i; F1_j = val_F1_j;}
    
    /*!
     * \brief Compute the viscous turbulent residual using an average of gradients wtih correction.
     * \param[out] val_residual - Pointer to the total residual.
     * \param[out] Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[out] Jacobian_j - Jacobian of the numerical method at node j (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual, double **Jacobian_i, double **Jacobian_j, CConfig *config);
    
};

/*!
 * \class CAvgGradCorrected_TurbSST
 * \brief Class for computing viscous term using average of gradient with correction (Menter SST turbulence model).
 * \ingroup ViscDiscr
 * \author A. Bueno.
 * \version 3.2.9 "eagle"
 */
class CAvgGradCorrected_TurbSST : public CNumerics {
private:
    double sigma_k1,                     /*!< \brief Constants for the viscous terms, k-w (1), k-eps (2)*/
    sigma_k2,
    sigma_om1,
    sigma_om2;
    
    double diff_kine,                     /*!< \brief Diffusivity for viscous terms of tke eq */
    diff_omega;                           /*!< \brief Diffusivity for viscous terms of omega eq */
    
    double *Edge_Vector,                  /*!< \brief Vector from node i to node j. */
    dist_ij_2,                            /*!< \brief |Edge_Vector|^2 */
    proj_vector_ij;                       /*!< \brief (Edge_Vector DOT normal)/|Edge_Vector|^2 */
    
    double **Mean_GradTurbVar,            /*!< \brief Average of gradients at cell face */
    *Proj_Mean_GradTurbVar_Normal,        /*!< \brief Mean_gradTurbVar DOT normal */
    *Proj_Mean_GradTurbVar_Edge,          /*!< \brief Mean_gradTurbVar DOT Edge_Vector */
    *Proj_Mean_GradTurbVar_Corrected;
    
    double F1_i, F1_j;                    /*!< \brief Menter's first blending function */
    
    bool implicit, incompressible;
    unsigned short iVar, iDim;
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CAvgGradCorrected_TurbSST(unsigned short val_nDim, unsigned short val_nVar, double* constants, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CAvgGradCorrected_TurbSST(void);
    
    /*!
     * \brief Sets value of first blending function.
     */
    void SetF1blending(double val_F1_i, double val_F1_j) { F1_i = val_F1_i; F1_j = val_F1_j;}
    
    /*!
     * \brief Compute the viscous turbulent residual using an average of gradients wtih correction.
     * \param[out] val_residual - Pointer to the total residual.
     * \param[out] Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[out] Jacobian_j - Jacobian of the numerical method at node j (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual, double **Jacobian_i, double **Jacobian_j, CConfig *config);
    
};

/*!
 * \class CAvgGradCorrected_AdjFlow
 * \brief Class for computing the adjoint viscous terms, including correction.
 * \ingroup ViscDiscr
 * \author A. Bueno.
 * \version 3.2.9 "eagle"
 */
class CAvgGradCorrected_AdjFlow : public CNumerics {
private:
    double *Velocity_i;	/*!< \brief Auxiliary vector for storing the velocity of point i. */
    double *Velocity_j;	/*!< \brief Auxiliary vector for storing the velocity of point j. */
    double *Mean_Velocity;
    double **Mean_GradPsiVar;	/*!< \brief Counter for dimensions of the problem. */
    double *Edge_Vector;	/*!< \brief Vector going from node i to node j. */
    double *Proj_Mean_GradPsiVar_Edge;	/*!< \brief Projection of Mean_GradPsiVar onto Edge_Vector. */
    double *Mean_GradPsiE;	/*!< \brief Counter for dimensions of the problem. */
    double **Mean_GradPhi;	/*!< \brief Counter for dimensions of the problem. */
    bool implicit;          /*!< \brief Boolean controlling Jacobian calculations. */
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CAvgGradCorrected_AdjFlow(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CAvgGradCorrected_AdjFlow(void);
    
    /*!
     * \brief Compute the adjoint flow viscous residual in a non-conservative way using an average of gradients and derivative correction.
     * \param[out] val_residual_i - Pointer to the viscous residual at point i.
     * \param[out] val_residual_j - Pointer to the viscous residual at point j.
     * \param[out] val_Jacobian_ii - Jacobian of the numerical method at node i (implicit computation) from node i.
     * \param[out] val_Jacobian_ij - Jacobian of the numerical method at node i (implicit computation) from node j.
     * \param[out] val_Jacobian_ji - Jacobian of the numerical method at node j (implicit computation) from node i.
     * \param[out] val_Jacobian_jj - Jacobian of the numerical method at node j (implicit computation) from node j.
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual_i, double *val_residual_j, double **val_Jacobian_ii, double **val_Jacobian_ij,
                         double **val_Jacobian_ji, double **val_Jacobian_jj, CConfig *config);
};

/*!
 * \class CAvgGradCorrectedArtComp_AdjFlow
 * \brief Class for computing the adjoint viscous terms, including correction.
 * \ingroup ViscDiscr
 * \author F.Palacios
 * \version 3.2.9 "eagle"
 */
class CAvgGradCorrectedArtComp_AdjFlow : public CNumerics {
private:
    unsigned short iDim, iVar, jVar;	/*!< \brief Iterators in dimension an variable. */
    double *PsiVar_i, *PsiVar_j,			/*!< \brief Primitives variables at point i and 1. */
    *Edge_Vector,								/*!< \brief Vector form point i to point j. */
    **Mean_GradPsiVar, *Proj_Mean_GradPsiVar_Edge,	/*!< \brief Mean value of the gradient. */
    Mean_Laminar_Viscosity, Mean_Eddy_Viscosity,			/*!< \brief Mean value of the viscosity. */
    dist_ij_2,					/*!< \brief Length of the edge and face. */
    *ProjFlux;	/*!< \brief Projection of the viscous fluxes. */
    bool implicit;			/*!< \brief Implicit calculus. */
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CAvgGradCorrectedArtComp_AdjFlow(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CAvgGradCorrectedArtComp_AdjFlow(void);
    
    /*!
     * \brief Compute the adjoint flow viscous residual in a non-conservative way using an average of gradients and derivative correction.
     * \param[out] val_residual_i - Pointer to the viscous residual at point i.
     * \param[out] val_residual_j - Pointer to the viscous residual at point j.
     * \param[out] val_Jacobian_ii - Jacobian of the numerical method at node i (implicit computation) from node i.
     * \param[out] val_Jacobian_ij - Jacobian of the numerical method at node i (implicit computation) from node j.
     * \param[out] val_Jacobian_ji - Jacobian of the numerical method at node j (implicit computation) from node i.
     * \param[out] val_Jacobian_jj - Jacobian of the numerical method at node j (implicit computation) from node j.
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual (double *val_residual_i, double *val_residual_j, double **val_Jacobian_ii, double **val_Jacobian_ij,
                          double **val_Jacobian_ji, double **val_Jacobian_jj, CConfig *config);
};

/*!
 * \class CAvgGradCorrected_AdjTurb
 * \brief Class for adjoint turbulent using average of gradients with a correction.
 * \ingroup ViscDiscr
 * \author A. Bueno.
 * \version 3.2.9 "eagle"
 */
class CAvgGradCorrected_AdjTurb : public CNumerics {
private:
    double **Mean_GradTurbPsi;
    double *Proj_Mean_GradTurbPsi_Kappa, *Proj_Mean_GradTurbPsi_Edge, *Proj_Mean_GradTurbPsi_Corrected;
    double *Edge_Vector;
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CAvgGradCorrected_AdjTurb(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CAvgGradCorrected_AdjTurb(void);
    
    /*!
     * \brief Compute the adjoint turbulent residual using average of gradients and a derivative correction.
     * \param[out] val_residual - Pointer to the total residual.
     * \param[out] val_Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[out] val_Jacobian_j - Jacobian of the numerical method at node j (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    
    void ComputeResidual(double *val_residual, double **val_Jacobian_i, double **val_Jacobian_j, CConfig *config);
    
    /*!
     * \overload
     * \param[out] val_residual_i - Pointer to the total residual at point i.
     * \param[out] val_residual_j - Pointer to the total viscosity residual at point j.
     * \param[out] val_Jacobian_ii - Jacobian of the numerical method at node i (implicit computation) from node i.
     * \param[out] val_Jacobian_ij - Jacobian of the numerical method at node i (implicit computation) from node j.
     * \param[out] val_Jacobian_ji - Jacobian of the numerical method at node j (implicit computation) from node i.
     * \param[out] val_Jacobian_jj - Jacobian of the numerical method at node j (implicit computation) from node j.
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual_i, double *val_residual_j, double **val_Jacobian_ii, double **val_Jacobian_ij,
                         double **val_Jacobian_ji, double **val_Jacobian_jj, CConfig *config);
};

/*!
 * \class CAvgGrad_AdjTurb
 * \brief Class for adjoint turbulent using average of gradients with a correction.
 * \ingroup ViscDiscr
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CAvgGrad_AdjTurb : public CNumerics {
private:
    double **Mean_GradTurbPsi;
    double *Proj_Mean_GradTurbPsi_Kappa, *Proj_Mean_GradTurbPsi_Edge, *Proj_Mean_GradTurbPsi_Corrected;
    double *Edge_Vector;
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CAvgGrad_AdjTurb(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CAvgGrad_AdjTurb(void);
    
    /*!
     * \brief Compute the adjoint turbulent residual using average of gradients and a derivative correction.
     * \param[out] val_residual - Pointer to the total residual.
     * \param[out] val_Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[out] val_Jacobian_j - Jacobian of the numerical method at node j (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    
    void ComputeResidual(double *val_residual, double **val_Jacobian_i, double **val_Jacobian_j, CConfig *config);
    
    /*!
     * \overload
     * \param[out] val_residual_i - Pointer to the total residual at point i.
     * \param[out] val_residual_j - Pointer to the total viscosity residual at point j.
     * \param[out] val_Jacobian_ii - Jacobian of the numerical method at node i (implicit computation) from node i.
     * \param[out] val_Jacobian_ij - Jacobian of the numerical method at node i (implicit computation) from node j.
     * \param[out] val_Jacobian_ji - Jacobian of the numerical method at node j (implicit computation) from node i.
     * \param[out] val_Jacobian_jj - Jacobian of the numerical method at node j (implicit computation) from node j.
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual_i, double *val_residual_j, double **val_Jacobian_ii, double **val_Jacobian_ij,
                         double **val_Jacobian_ji, double **val_Jacobian_jj, CConfig *config);
};

/*!
 * \class CGalerkin_Flow
 * \brief Class for computing the stiffness matrix of the Galerkin method.
 * \ingroup ViscDiscr
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CGalerkin_Flow : public CNumerics {
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CGalerkin_Flow(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CGalerkin_Flow(void);
    
    /*!
     * \brief Computing stiffness matrix of the Galerkin method.
     * \param[out] val_stiffmatrix_elem - Stiffness matrix for Galerkin computation.
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual (double **val_stiffmatrix_elem, CConfig *config);
};

/*!
 * \class CGalerkin_FEA
 * \brief Class for computing the stiffness matrix of the Galerkin method.
 * \ingroup ViscDiscr
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CGalerkin_FEA : public CNumerics {
    double E;				/*!< \brief Young's modulus of elasticity. */
    double Nu;			/*!< \brief Poisson's ratio. */
    double Mu;			/*!< \brief Lame's coeficient. */
    double Lambda;	/*!< \brief Lame's coeficient. */
    double Density;	/*!< \brief Material density. */
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CGalerkin_FEA(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CGalerkin_FEA(void);
    
    /*!
     * \brief Shape functions and derivative of the shape functions
     * \param[in] Xi - Local coordinates.
     * \param[in] Eta - Local coordinates.
     * \param[in] Mu - Local coordinates.
     * \param[in] CoordCorners[8][3] - Coordiantes of the corners.
     * \param[in] shp[8][4] - Shape function information
     */
    double ShapeFunc_Triangle(double Xi, double Eta, double CoordCorners[8][3], double DShapeFunction[8][4]);
    
    /*!
     * \brief Shape functions and derivative of the shape functions
     * \param[in] Xi - Local coordinates.
     * \param[in] Eta - Local coordinates.
     * \param[in] Mu - Local coordinates.
     * \param[in] CoordCorners[8][3] - Coordiantes of the corners.
     * \param[in] shp[8][4] - Shape function information
     */
    double ShapeFunc_Rectangle(double Xi, double Eta, double CoordCorners[8][3], double DShapeFunction[8][4]);
    
    /*!
     * \brief Shape functions and derivative of the shape functions
     * \param[in] Xi - Local coordinates.
     * \param[in] Eta - Local coordinates.
     * \param[in] Mu - Local coordinates.
     * \param[in] CoordCorners[8][3] - Coordiantes of the corners.
     * \param[in] shp[8][4] - Shape function information
     */
    double ShapeFunc_Tetra(double Xi, double Eta, double Mu, double CoordCorners[8][3], double DShapeFunction[8][4]);
    
    /*!
     * \brief Shape functions and derivative of the shape functions
     * \param[in] Xi - Local coordinates.
     * \param[in] Eta - Local coordinates.
     * \param[in] Mu - Local coordinates.
     * \param[in] CoordCorners[8][3] - Coordiantes of the corners.
     * \param[in] shp[8][4] - Shape function information
     */
    double ShapeFunc_Prism(double Xi, double Eta, double Mu, double CoordCorners[8][3], double DShapeFunction[8][4]);
    
    /*!
     * \brief Shape functions and derivative of the shape functions
     * \param[in] Xi - Local coordinates.
     * \param[in] Eta - Local coordinates.
     * \param[in] Mu - Local coordinates.
     * \param[in] CoordCorners[8][3] - Coordiantes of the corners.
     * \param[in] shp[8][4] - Shape function information
     */
    double ShapeFunc_Pyram(double Xi, double Eta, double Mu, double CoordCorners[8][3], double DShapeFunction[8][4]);
    
    /*!
     * \brief Shape functions and derivative of the shape functions
     * \param[in] Xi - Local coordinates.
     * \param[in] Eta - Local coordinates.
     * \param[in] Mu - Local coordinates.
     * \param[in] CoordCorners[8][3] - Coordiantes of the corners.
     * \param[in] shp[8][4] - Shape function information
     */
    double ShapeFunc_Hexa(double Xi, double Eta, double Mu, double CoordCorners[8][3], double DShapeFunction[8][4]);
    
    /*!
     * \brief Computing stiffness matrix of the Galerkin method.
     * \param[out] val_stiffmatrix_elem - Stiffness matrix for Galerkin computation.
     * \param[in] config - Definition of the particular problem.
     */
    void SetFEA_StiffMatrix2D(double **StiffMatrix_Elem, double CoordCorners[8][3], unsigned short nNodes);
    
    /*!
     * \brief Computing stiffness matrix of the Galerkin method.
     * \param[out] val_stiffmatrix_elem - Stiffness matrix for Galerkin computation.
     * \param[in] config - Definition of the particular problem.
     */
    void SetFEA_StiffMatrix3D(double **StiffMatrix_Elem, double CoordCorners[8][3], unsigned short nNodes);
    
};

/*!
 * \class CSourceNothing
 * \brief Dummy class.
 * \ingroup SourceDiscr
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CSourceNothing : public CNumerics {
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CSourceNothing(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CSourceNothing(void);
};

/*!
 * \class CSourcePieceWise_TurbSA
 * \brief Class for integrating the source terms of the Spalart-Allmaras turbulence model equation.
 * \ingroup SourceDiscr
 * \author A. Bueno.
 * \version 3.2.9 "eagle"
 */
class CSourcePieceWise_TurbSA : public CNumerics {
private:
    double cv1_3;
    double k2;
    double cb1;
    double cw2;
    double ct3;
    double ct4;
    double cw3_6;
    double cb2_sigma;
    double sigma;
    double cb2;
    double cw1;
    double DivVelocity;
    unsigned short iDim;
    double nu, Ji, fv1, fv2, ft2, Omega, S, Shat, inv_Shat, dist_i_2, Ji_2, Ji_3, inv_k2_d2;
    double r, g, g_6, glim, fw;
    double norm2_Grad;
    double dfv1, dfv2, dShat;
    double dr, dg, dfw;;
    double nu_hat_i;
    double grad_nu_hat;
    double prod_grads;
    bool incompressible;
    bool transition;
    bool rotating_frame;
    double div;
    double beta, gamma_sep, gamma_eff, intermittency;
    double Freattach, r_t, s1;
    double Production, Destruction, CrossProduction;
    
    SpalartAllmarasInputs* SAInputs;
    SpalartAllmarasConstants* SAConstants;
    int nResidual;
    int nJacobian;
    double* testResidual;
    double* testJacobian;
    double** DUiDXj;
    double* DNuhatDXj;
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CSourcePieceWise_TurbSA(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CSourcePieceWise_TurbSA(void);
    
    /*!
     * \brief Residual for source term integration.
     * \param[out] val_residual - Pointer to the total residual.
     * \param[out] val_Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[out] val_Jacobian_j - Jacobian of the numerical method at node j (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual, double **val_Jacobian_i, double **val_Jacobian_j, CConfig *config);
    
    /*!
     * \brief Residual for source term integration.
     * \param[in] intermittency_in - Value of the intermittency.
     */
    void SetIntermittency(double intermittency_in);
    
    /*!
     * \brief Residual for source term integration.
     * \param[in] val_production - Value of the Production.
     */
    void SetProduction(double val_production);
    
    /*!
     * \brief Residual for source term integration.
     * \param[in] val_destruction - Value of the Destruction.
     */
    void SetDestruction(double val_destruction);
    
    /*!
     * \brief Residual for source term integration.
     * \param[in] val_crossproduction - Value of the CrossProduction.
     */
    void SetCrossProduction(double val_crossproduction);
    
    /*!
     * \brief ______________.
     */
    double GetProduction(void);
    
    /*!
     * \brief  ______________.
     */
    double GetDestruction(void);
    
    /*!
     * \brief  ______________.
     */
    double GetCrossProduction(void);
};

/*!
 * \class CSourcePieceWise_TurbSA_Neg
 * \brief Class for integrating the source terms of the Spalart-Allmaras turbulence model equation.
 * \ingroup SourceDiscr
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CSourcePieceWise_TurbSA_Neg : public CNumerics {
private:
    double cv1_3;
    double k2;
    double cb1;
    double cw2;
    double ct3;
    double ct4;
    double cw3_6;
    double cb2_sigma;
    double sigma;
    double cb2;
    double cw1;
    double DivVelocity;
    unsigned short iDim;
    double nu, Ji, fv1, fv2, ft2, Omega, S, Shat, inv_Shat, dist_i_2, Ji_2, Ji_3, inv_k2_d2;
    double r, g, g_6, glim, fw;
    double norm2_Grad;
    double dfv1, dfv2, dShat;
    double dr, dg, dfw;;
    double nu_hat_i;
    double grad_nu_hat;
    double prod_grads;
    bool incompressible;
    bool transition;
    bool rotating_frame;
    double div;
    double beta, gamma_sep, gamma_eff, intermittency;
    double Freattach, r_t, s1;
    double Production, Destruction, CrossProduction;
    
    SpalartAllmarasInputs* SAInputs;
    SpalartAllmarasConstants* SAConstants;
    int nResidual;
    int nJacobian;
    double* testResidual;
    double* testJacobian;
    double** DUiDXj;
    double* DNuhatDXj;
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CSourcePieceWise_TurbSA_Neg(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CSourcePieceWise_TurbSA_Neg(void);
    
    /*!
     * \brief Residual for source term integration.
     * \param[out] val_residual - Pointer to the total residual.
     * \param[out] val_Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[out] val_Jacobian_j - Jacobian of the numerical method at node j (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual, double **val_Jacobian_i, double **val_Jacobian_j, CConfig *config);
    
    /*!
     * \brief Residual for source term integration.
     * \param[in] intermittency_in - Value of the intermittency.
     */
    void SetIntermittency(double intermittency_in);
    
    /*!
     * \brief Residual for source term integration.
     * \param[in] val_production - Value of the Production.
     */
    void SetProduction(double val_production);
    
    /*!
     * \brief Residual for source term integration.
     * \param[in] val_destruction - Value of the Destruction.
     */
    void SetDestruction(double val_destruction);
    
    /*!
     * \brief Residual for source term integration.
     * \param[in] val_crossproduction - Value of the CrossProduction.
     */
    void SetCrossProduction(double val_crossproduction);
    
    /*!
     * \brief ______________.
     */
    double GetProduction(void);
    
    /*!
     * \brief  ______________.
     */
    double GetDestruction(void);
    
    /*!
     * \brief  ______________.
     */
    double GetCrossProduction(void);
};

/*!
 * \class CSourcePieceWise_TurbML
 * \brief Class for integrating the source terms of the Spalart-Allmaras turbulence model equation.
 * \ingroup SourceDiscr
 * \author A. Bueno.
 * \version 3.2.9 "eagle"
 */
class CSourcePieceWise_TurbML : public CNumerics {
private:
    double cv1_3;
    double k2;
    double cb1;
    double cw2;
    double cw3_6;
    double cb2_sigma;
    double sigma;
    double cb2;
    double cw1;
    double DivVelocity, Vorticity;
    unsigned short iDim;
    double nu, Ji, fv1, fv2, Omega, S, Shat, inv_Shat, dist_i_2, Ji_2, Ji_3, inv_k2_d2;
    double r, g, g_6, glim;
    double norm2_Grad;
    double dfv1, dfv2, dShat;
    double dr, dg, dfw;;
    double nu_hat_i;
    double grad_nu_hat;
    double prod_grads;
    bool incompressible;
    bool transition;
    bool rotating_frame;
    double div, StrainMag;
    double beta, gamma_sep, gamma_eff, intermittency;
    double Freattach, r_t, s1;
    double Production, Destruction, CrossProduction;
    CScalePredictor* MLModel;
    
    double uInfinity;
    
    
    SpalartAllmarasInputs* SAInputs;
    SpalartAllmarasConstants* SAConstants;
    
    int nResidual;
    int nJacobian;
    
    string featureset;
    
    //double* testResidual;
    //double* testJacobian;
    double** DUiDXj;
    double* DNuhatDXj;
    
public:
    
    bool isInBL;
    double fw;
    double fWake;
    SpalartAllmarasOtherOutputs* SAOtherOutputs;
    
    double *SAResidual;
    double * SANondimResidual;
    double* Residual;
    double * NondimResidual;
    double *ResidualDiff;
    double *NondimResidualDiff;
    double* SAJacobian;
    CSANondimInputs* SANondimInputs;
    double NuhatGradNorm;
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CSourcePieceWise_TurbML(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CSourcePieceWise_TurbML(void);
    
    /*!
     * \brief Residual for source term integration.
     * \param[out] val_residual - Pointer to the total residual.
     * \param[out] val_Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[out] val_Jacobian_j - Jacobian of the numerical method at node j (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual, double **val_Jacobian_i, double **val_Jacobian_j, CConfig *config);
    
    /*!
     * \brief Residual for source term integration.
     * \param[in] intermittency_in - Value of the intermittency.
     */
    void SetIntermittency(double intermittency_in);
    
    /*!
     * \brief Residual for source term integration.
     * \param[in] val_production - Value of the Production.
     */
    void SetProduction(double val_production);
    
    /*!
     * \brief Residual for source term integration.
     * \param[in] val_destruction - Value of the Destruction.
     */
    void SetDestruction(double val_destruction);
    
    /*!
     * \brief Residual for source term integration.
     * \param[in] val_crossproduction - Value of the CrossProduction.
     */
    void SetCrossProduction(double val_crossproduction);
    
    /*!
     * \brief Residual for source term integration.
     * \param[in] val_production - Value of the Production.
     */
    double GetProduction(void);
    
    /*!
     * \brief Residual for source term integration.
     * \param[in] val_destruction - Value of the Destruction.
     */
    double GetDestruction(void);
    
    /*!
     * \brief Residual for source term integration.
     * \param[in] val_crossproduction - Value of the CrossProduction.
     */
    double GetCrossProduction(void);
    
    double SAProduction, SADestruction, SACrossProduction, SASource, MLProduction, MLDestruction, MLCrossProduction, MLSource, SourceDiff;
    
    int NumResidual();
};

/*!
 * \class CSourcePieceWise_TransLM
 * \brief Class for integrating the source terms of the Spalart-Allmaras turbulence model equation.
 * \ingroup SourceDiscr
 * \author A. Bueno.
 * \version 3.2.9 "eagle"
 */
class CSourcePieceWise_TransLM : public CNumerics {
private:
    
    /*-- SA model constants --*/
    double cv1_3;
    double k2;
    double cb1;
    double cw2;
    double cw3_6;
    double sigma;
    double cb2;
    double cw1;
    
    /*-- gamma-theta model constants --*/
    double c_e1;
    double c_a1;
    double c_e2;
    double c_a2;
    double sigmaf;
    double s1;
    double c_theta;
    double sigmat;
    double REth_Inf;
    
    /*-- Correlation constants --*/
    double flen_global;
    double alpha_global;
    double DivVelocity, Vorticity;
    unsigned short iDim;
    double nu, Ji, fv1, fv2, Omega, Shat, dist_0_2, Ji_2, Ji_3;
    double r, g, g_6, glim, fw;
    double norm2_Grad;
    double dfv1, dfv2, dShat;
    double dr, dg, dfw;;
    double nu_hat_i;
    double grad_nu_hat;
    double prod_grads;
    bool implicit;
    
public:
    bool debugme; // For debugging only, remove this. -AA
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CSourcePieceWise_TransLM(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CSourcePieceWise_TransLM(void);
    
    /*!
     * \brief Residual for source term integration.
     * \param[out] val_residual - Pointer to the total residual.
     * \param[out] val_Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[out] val_Jacobian_j - Jacobian of the numerical method at node j (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual_TransLM(double *val_residual, double **val_Jacobian_i, double **val_Jacobian_j, CConfig *config, double &gamma_sep);
    
    void CSourcePieceWise_TransLM__ComputeResidual_TransLM_d(double *TransVar_i, double *TransVar_id, double *val_residual, double *val_residuald, CConfig *config);
};

/*!
 * \class CSourcePieceWise_TurbSST
 * \brief Class for integrating the source terms of the Menter SST turbulence model equations.
 * \ingroup SourceDiscr
 * \author A. Campos.
 * \version 3.2.9 "eagle"
 */
class CSourcePieceWise_TurbSST : public CNumerics {
private:
    double F1_i,
    F1_j,
    F2_i,
    F2_j;
    
    double alfa_1,
    alfa_2,
    beta_1,
    beta_2,
    sigma_omega_1,
    sigma_omega_2,
    beta_star,
    a1;
    
    double CDkw_i, CDkw_j,
    norm2_Grad;
    
    bool incompressible;
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CSourcePieceWise_TurbSST(unsigned short val_nDim, unsigned short val_nVar, double* constants, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CSourcePieceWise_TurbSST(void);
    
    /*!
     * \brief Set the value of the first blending function.
     * \param[in] val_F1_i - Value of the first blending function at point i.
     * \param[in] val_F1_j - Value of the first blending function at point j.
     */
    void SetF1blending(double val_F1_i, double val_F1_j);
    
    /*!
     * \brief Set the value of the second blending function.
     * \param[in] val_F2_i - Value of the second blending function at point i.
     * \param[in] val_F2_j - Value of the second blending function at point j.
     */
    void SetF2blending(double val_F2_i, double val_F2_j);
    
    /*!
     * \brief Set the value of the cross diffusion for the SST model.
     * \param[in] val_CDkw_i - Value of the cross diffusion at point i.
     * \param[in] val_CDkw_j - Value of the cross diffusion at point j.
     */
    virtual void SetCrossDiff(double val_CDkw_i, double val_CDkw_j);
    
    /*!
     * \brief Residual for source term integration.
     * \param[out] val_residual - Pointer to the total residual.
     * \param[out] val_Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[out] val_Jacobian_j - Jacobian of the numerical method at node j (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual, double **val_Jacobian_i, double **val_Jacobian_j, CConfig *config);
    
};

/*!
 * \class CSourcePieceWise_FreeSurface
 * \brief Class for the source term integration of the gravity force.
 * \ingroup SourceDiscr
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CSourcePieceWise_FreeSurface : public CNumerics {
    double U_ref, L_ref, Froude;
    bool implicit, incompressible;
    
public:
    
//    /*!
//     * \param[in] val_nDim - Number of dimensions of the problem.
//     * \param[in] val_nVar - Number of variables of the problem.
//     * \param[in] config - Definition of the particular problem.
//     */
//    CSourcePieceWise_FreeSurface(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
//    
//    /*!
//     * \brief Destructor of the class.
//     */
//    ~CSourcePieceWise_FreeSurface(void);
//    
//    /*!
//     * \brief Source term integration for the poissonal potential.
//     * \param[out] val_residual - Pointer to the total residual.
//     * \param[out] val_Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
//     * \param[out] val_Jacobian_j - Jacobian of the numerical method at node j (implicit computation).
//     * \param[in] config - Definition of the particular problem.
//     */
//    void ComputeResidual(double *val_residual, double **val_Jacobian_i, double **val_Jacobian_j,  CConfig *config);
};

/*!
 * \class CSourceGravity
 * \brief Class for the source term integration of the gravity force.
 * \ingroup SourceDiscr
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CSourceGravity : public CNumerics {
    double Froude;
    bool compressible, incompressible, freesurface;
    
public:
    
    /*!
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CSourceGravity(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CSourceGravity(void);
    
    /*!
     * \brief Source term integration for the poissonal potential.
     * \param[out] val_residual - Pointer to the total residual.
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual, CConfig *config);
};

/*!
 * \class CSourceViscous_AdjFlow
 * \brief Class for source term integration in adjoint problem.
 * \ingroup SourceDiscr
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CSourceViscous_AdjFlow : public CNumerics {
private:
    double *Velocity, *GradDensity, *GradInvDensity, *dPoDensity2, *alpha, *beta, *Sigma_5_vec;
    double **GradVel_o_Rho, **sigma, **Sigma_phi, **Sigma_5_Tensor, **Sigma;
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CSourceViscous_AdjFlow(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CSourceViscous_AdjFlow(void);
    
    /*!
     * \brief Source term integration of the flow adjoint equation.
     * \param[out] val_residual - Pointer to the total residual.
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual (double *val_residual, CConfig *config);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_phi - Value of the adjoint velocity.
     */
    //void SetPhi_Old(double *val_phi);
    
};

/*!
 * \class CSourcePieceWise_AdjTurb
 * \brief Class for source term integration of the adjoint turbulent equation.
 * \ingroup SourceDiscr
 * \author A. Bueno.
 * \version 3.2.9 "eagle"
 */
class CSourcePieceWise_AdjTurb : public CNumerics {
private:
    double **tau, *Velocity;
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CSourcePieceWise_AdjTurb(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CSourcePieceWise_AdjTurb(void);
    
    /*!
     * \brief Source term integration of the adjoint turbulence equation.
     * \param[out] val_residual - Pointer to the total residual.
     * \param[out] val_Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[out] val_Jacobian_j - Jacobian of the numerical method at node j (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual, double **val_Jacobian_i, double **val_Jacobian_j, CConfig *config);
};

/*!
 * \class CSourcePieceWise_AdjElec
 * \brief Class for source term integration of the adjoint poisson potential equation.
 * \ingroup SourceDiscr
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CSourcePieceWise_AdjElec : public CNumerics {
public:
    
//    /*!
//     * \brief Constructor of the class.
//     * \param[in] val_nDim - Number of dimensions of the problem.
//     * \param[in] val_nVar - Number of variables of the problem.
//     * \param[in] config - Definition of the particular problem.
//     */
//    CSourcePieceWise_AdjElec(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
//    
//    /*!
//     * \brief Destructor of the class.
//     */
//    ~CSourcePieceWise_AdjElec(void);
//    
//    /*!
//     * \brief Source term integration of the adjoint poisson potential equation.
//     * \param[out] val_residual - Pointer to the total residual.
//     * \param[in] config - Definition of the particular problem.
//     */
//    void ComputeResidual(double *val_residual, CConfig *config);
};

/*!
 * \class CSourcePieceWise_LevelSet
 * \brief Class for source term integration of the adjoint level set equation.
 * \ingroup SourceDiscr
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CSourcePieceWise_LevelSet : public CNumerics {
public:
    
//    /*!
//     * \brief Constructor of the class.
//     * \param[in] val_nDim - Number of dimensions of the problem.
//     * \param[in] val_nVar - Number of variables of the problem.
//     * \param[in] config - Definition of the particular problem.
//     */
//    CSourcePieceWise_LevelSet(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
//    
//    /*!
//     * \brief Destructor of the class.
//     */
//    ~CSourcePieceWise_LevelSet(void);
//    
//    /*!
//     * \brief Source term integration of the adjoint poisson potential equation.
//     * \param[out] val_residual - Pointer to the total residual.
//     * \param[in] config - Definition of the particular problem.
//     */
//    void ComputeResidual(double *val_residual, CConfig *config);
};

/*!
 * \class CSourcePieceWise_AdjLevelSet
 * \brief Class for source term integration of the adjoint level set equation.
 * \ingroup SourceDiscr
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CSourcePieceWise_AdjLevelSet : public CNumerics {
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CSourcePieceWise_AdjLevelSet(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CSourcePieceWise_AdjLevelSet(void);
    
    /*!
     * \brief Source term integration of the adjoint poisson potential equation.
     * \param[out] val_residual - Pointer to the total residual.
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual, CConfig *config);
};

/*!
 * \class CSourcePieceWise_LinElec
 * \brief Class for source term integration of the linearized poisson potential equation.
 * \ingroup SourceDiscr
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CSourcePieceWise_LinElec : public CNumerics {
public:
    
//    /*!
//     * \brief Constructor of the class.
//     * \param[in] val_nDim - Number of dimensions of the problem.
//     * \param[in] val_nVar - Number of variables of the problem.
//     * \param[in] config - Definition of the particular problem.
//     */
//    CSourcePieceWise_LinElec(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
//    
//    /*!
//     * \brief Destructor of the class.
//     */
//    ~CSourcePieceWise_LinElec(void);
//    
//    /*!
//     * \brief Source term integration of the linearized poisson potential equation.
//     * \param[out] val_residual - Pointer to the total residual.
//     * \param[in] config - Definition of the particular problem.
//     */
//    void ComputeResidual(double *val_residual, CConfig *config);
};

/*!
 * \class CSourceConservative_AdjFlow
 * \brief Class for source term integration in adjoint problem using a conservative scheme.
 * \ingroup SourceDiscr
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CSourceConservative_AdjFlow : public CNumerics {
private:
    double *Velocity, *Residual_i, *Residual_j, *Mean_Residual;
    double **Mean_PrimVar_Grad;
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CSourceConservative_AdjFlow(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CSourceConservative_AdjFlow(void);
    
    /*!
     * \brief Source term integration using a conservative scheme.
     * \param[out] val_residual - Pointer to the total residual.
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual, CConfig *config);
};

/*!
 * \class CSourceConservative_AdjTurb
 * \brief Class for source term integration in adjoint turbulent problem using a conservative scheme.
 * \ingroup SourceDiscr
 * \author A. Bueno.
 * \version 3.2.9 "eagle"
 */
class CSourceConservative_AdjTurb : public CNumerics {
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CSourceConservative_AdjTurb(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CSourceConservative_AdjTurb(void);
    
    /*!
     * \brief Source term integration using a conservative scheme.
     * \param[out] val_residual - Pointer to the total residual.
     * \param[out] val_Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[out] val_Jacobian_j - Jacobian of the numerical method at node j (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual, double **val_Jacobian_i, double **val_Jacobian_j, CConfig *config);
};

/*!
 * \class CSourceRotatingFrame_Flow
 * \brief Class for a rotating frame source term.
 * \ingroup SourceDiscr
 * \author F. Palacios, T. Economon.
 * \version 3.2.9 "eagle"
 */
class CSourceRotatingFrame_Flow : public CNumerics {
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CSourceRotatingFrame_Flow(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CSourceRotatingFrame_Flow(void);
    
    /*!
     * \brief Residual of the rotational frame source term.
     * \param[out] val_residual - Pointer to the total residual.
     * \param[out] val_Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual, double **val_Jacobian_i, CConfig *config);
};

/*!
 * \class CSourceRotatingFrame_AdjFlow
 * \brief Source term class for rotating frame adjoint.
 * \ingroup SourceDiscr
 * \author T. Economon.
 * \version 3.2.9 "eagle"
 */
class CSourceRotatingFrame_AdjFlow : public CNumerics {
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CSourceRotatingFrame_AdjFlow(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CSourceRotatingFrame_AdjFlow(void);
    
    /*!
     * \brief Residual of the adjoint rotating frame source term.
     * \param[out] val_residual - Pointer to the total residual.
     * \param[out] val_Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual, double **val_Jacobian_i, CConfig *config);
};

/*!
 * \class CSourceAxisymmetric_Flow
 * \brief Class for source term for solving axisymmetric problems.
 * \ingroup SourceDiscr
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CSourceAxisymmetric_Flow : public CNumerics {
private:
    bool compressible, incompressible, freesurface;
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CSourceAxisymmetric_Flow(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CSourceAxisymmetric_Flow(void);
    
    /*!
     * \brief Residual of the rotational frame source term.
     * \param[out] val_residual - Pointer to the total residual.
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual, double **Jacobian_i, CConfig *config);
    
};

/*!
 * \class CSourceAxisymmetric_AdjFlow
 * \brief Class for source term for solving axisymmetric problems.
 * \ingroup SourceDiscr
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CSourceAxisymmetric_AdjFlow : public CNumerics {
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CSourceAxisymmetric_AdjFlow(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CSourceAxisymmetric_AdjFlow(void);
    
    /*!
     * \brief Residual of the rotational frame source term.
     * \param[out] val_residual - Pointer to the total residual.
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual, double **Jacobian_i, CConfig *config);
    
    
private:
    bool incompressible;
};

/*!
 * \class CSourceWindGust
 * \brief Class for a source term due to a wind gust.
 * \ingroup SourceDiscr
 * \author S. Padrón
 * \version 3.2.9 "eagle"
 */
class CSourceWindGust : public CNumerics {
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CSourceWindGust(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CSourceWindGust(void);
    
    /*!
     * \brief Residual of the wind gust source term.
     * \param[out] val_residual - Pointer to the total residual.
     * \param[out] val_Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual, double **val_Jacobian_i, CConfig *config);
};

/*!
 * \class CSource_Template
 * \brief Dummy class.
 * \ingroup SourceDiscr
 * \author A. Lonkar.
 * \version 3.2.9 "eagle"
 */
class CSource_Template : public CNumerics {
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config -  Name of the input config file
     *
     */
    CSource_Template(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    
    /*!
     * \brief Residual for source term integration.
     * \param[out] val_residual - Pointer to the total residual.
     * \param[out] val_Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual, double **val_Jacobian_i, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CSource_Template(void);
};

/*!
 * \class CConvectiveTemplate
 * \brief Class for setting up new method for spatial discretization of convective terms in flow Equations
 * \ingroup ConvDiscr
 * \author A. Lonkar
 * \version 3.2.9 "eagle"
 */
class CConvective_Template : public CNumerics {
private:
    
    /* define private variables here */
    bool implicit;
    double *Diff_U;
    double *Velocity_i, *Velocity_j, *RoeVelocity;
    double *ProjFlux_i, *ProjFlux_j;
    double *delta_wave, *delta_vel;
    double *Lambda, *Epsilon;
    double **P_Tensor, **invP_Tensor;
    double sq_vel, Proj_ModJac_Tensor_ij, Density_i, Energy_i, SoundSpeed_i, Pressure_i, Enthalpy_i,
    Density_j, Energy_j, SoundSpeed_j, Pressure_j, Enthalpy_j, R, RoeDensity, RoeEnthalpy, RoeSoundSpeed,
    ProjVelocity, ProjVelocity_i, ProjVelocity_j, proj_delta_vel, delta_p, delta_rho;
    unsigned short iDim, iVar, jVar, kVar;
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CConvective_Template(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CConvective_Template(void);
    
    /*!
     * \brief Compute the Roe's flux between two nodes i and j.
     * \param[out] val_residual - Pointer to the total residual.
     * \param[out] val_Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[out] val_Jacobian_j - Jacobian of the numerical method at node j (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual, double **val_Jacobian_i, double **val_Jacobian_j, CConfig *config);
};

/*!
 * \class CViscous_Template
 * \brief Class for computing viscous term using average of gradients.
 * \ingroup ViscDiscr
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CViscous_Template : public CNumerics {
private:
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimension of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CViscous_Template(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CViscous_Template(void);
    
    /*!
     * \brief Compute the viscous flow residual using an average of gradients.
     * \param[out] val_residual - Pointer to the total residual.
     * \param[out] val_Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[out] val_Jacobian_j - Jacobian of the numerical method at node j (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual, double **val_Jacobian_i, double **val_Jacobian_j, CConfig *config);
};

/*!
 * \class CUpwRoe_TNE2
 * \brief Class for evaluating the Riemann problem using Roe's scheme for a two-temperature model.
 * \ingroup ConvDiscr
 * \author S. R. Copeland
 * \version 2.0.6
 */
class CUpwRoe_TNE2 : public CNumerics {
private:
    bool implicit, ionization;
    double *Diff_U;
    double *RoeU, *RoeV;
    double *ProjFlux_i, *ProjFlux_j;
    double *Lambda, *Epsilon;
    double **P_Tensor, **invP_Tensor;
    double RoeSoundSpeed;
    double ProjVelocity, ProjVelocity_i, ProjVelocity_j;
    double Proj_ModJac_Tensor_ij, R;
    double *RoedPdU;
    unsigned short nSpecies, nPrimVar, nPrimVarGrad, nVar, nDim;
    //  CVariable *var;
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CUpwRoe_TNE2(unsigned short val_nDim, unsigned short val_nVar,
                 unsigned short val_nPrimVar, unsigned short val_nPrimVarGrad,
                 CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CUpwRoe_TNE2(void);
    
    /*!
     * \brief Compute the Roe's flux between two nodes i and j.
     * \param[out] val_residual - Pointer to the total residual.
     * \param[out] val_Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[out] val_Jacobian_j - Jacobian of the numerical method at node j (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual, double **val_Jacobian_i, double **val_Jacobian_j, CConfig *config);
    
};


/*!
 * \class CUpwMSW_TNE2
 * \brief Class for solving a flux-vector splitting method by Steger & Warming, modified version.
 * \ingroup ConvDiscr
 * \author S. Copeland
 * \version 3.2.9 "eagle"
 */
class CUpwMSW_TNE2 : public CNumerics {
private:
    bool ionization, implicit;
    double *Diff_U;
    double *u_i, *u_j, *ust_i, *ust_j;
    double *Fc_i, *Fc_j;
    double *Lambda_i, *Lambda_j;
    double *rhos_i, *rhos_j, *rhosst_i, *rhosst_j;
    double *Ust_i, *Ust_j, *Vst_i, *Vst_j;
    double *dPdUst_i, *dPdUst_j;
    double **P_Tensor, **invP_Tensor;
    unsigned short nSpecies, nPrimVar, nPrimVarGrad, nVar, nDim;
    
    //  CVariable *var;
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] val_nPrimVar
     * \param[in] val_nPrimVarGrad
     * \param[in] config - Definition of the particular problem.
     */
    CUpwMSW_TNE2(unsigned short val_nDim, unsigned short val_nVar,
                 unsigned short val_nPrimVar, unsigned short val_nPrimVarGrad,
                 CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CUpwMSW_TNE2(void);
    
    /*!
     * \brief Compute the Roe's flux between two nodes i and j.
     * \param[out] val_residual - Pointer to the total residual.
     * \param[out] val_Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[out] val_Jacobian_j - Jacobian of the numerical method at node j (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual, double **val_Jacobian_i, double **val_Jacobian_j, CConfig *config);
    
};

/*!
 * \class CUpwAUSM_TNE2
 * \brief Class for solving an approximate Riemann AUSM.
 * \ingroup ConvDiscr
 * \author F. Palacios
 * \version 2.0.6
 */
class CUpwAUSM_TNE2 : public CNumerics {
private:
    bool implicit, ionization;
    double *FcL, *FcR, *FcLR;
    double *dmLP, *dmRM, *dpLP, *dpRM;
    double *daL, *daR;
    double *rhos_i, *u_i;
    double *rhos_j, *u_j;
    double a_i, P_i, h_i, ProjVel_i;
    double a_j, P_j, h_j, ProjVel_j;
    double sq_vel, Proj_ModJac_Tensor_ij;
    unsigned short nSpecies, nVar, nDim;
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CUpwAUSM_TNE2(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CUpwAUSM_TNE2(void);
    
    /*!
     * \brief Compute the Roe's flux between two nodes i and j.
     * \param[out] val_residual - Pointer to the total residual.
     * \param[out] val_Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[out] val_Jacobian_j - Jacobian of the numerical method at node j (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual, double **val_Jacobian_i, double **val_Jacobian_j, CConfig *config);
};

/*!
 * \class CUpwAUSM_TNE2
 * \brief Class for solving an approximate Riemann AUSM.
 * \ingroup ConvDiscr
 * \author F. Palacios
 * \version 2.0.6
 */
class CUpwAUSMPWplus_TNE2 : public CNumerics {
private:
    bool implicit, ionization;
    double *FcL, *FcR;
    double *dmLdL, *dmLdR, *dmRdL, *dmRdR;
    double *dmLPdL, *dmLPdR, *dmRMdL, *dmRMdR;
    double *dmbLPdL, *dmbLPdR, *dmbRMdL, *dmbRMdR;
    double *dpLPdL, *dpLPdR, *dpRMdL, *dpRMdR;
    double *dHnL, *dHnR;
    double *daL, *daR;
    double *rhos_i, *u_i;
    double *rhos_j, *u_j;
    double *dPdU_i, *dPdU_j;
    unsigned short nSpecies, nVar, nDim;
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CUpwAUSMPWplus_TNE2(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CUpwAUSMPWplus_TNE2(void);
    
    /*!
     * \brief Compute the Roe's flux between two nodes i and j.
     * \param[out] val_residual - Pointer to the total residual.
     * \param[out] val_Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[out] val_Jacobian_j - Jacobian of the numerical method at node j (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual, double **val_Jacobian_i, double **val_Jacobian_j, CConfig *config);
};


/*!
 * \class CCentLax_TNE2
 * \brief Class for computing the Lax-Friedrich centered scheme.
 * \ingroup ConvDiscr
 * \author F. Palacios
 * \version 2.0.6
 */
class CCentLax_TNE2 : public CNumerics {
private:
    unsigned short iDim, iVar, jVar; /*!< \brief Iteration on dimension and variables. */
    double *Diff_U; /*!< \brief Difference of conservative variables. */
    double *MeanU, *MeanV;
    double *MeandPdU;
    double *ProjFlux;  /*!< \brief Projected inviscid flux tensor. */
    double Param_p, Param_Kappa_0; /*!< \brief Artificial dissipation parameters. */
    double Local_Lambda_i, Local_Lambda_j, MeanLambda; /*!< \brief Local eigenvalues. */
    double Phi_i, Phi_j, sc0, StretchingFactor; /*!< \brief Streching parameters. */
    double Epsilon_0, cte; /*!< \brief Artificial dissipation values. */
    //    double *dPdrhos, dPdrhoE, dPdrhoEve; /*!< \brief Partial derivative of pressure w.r.t. conserved quantities. */
    bool implicit; /*!< \brief Implicit time integration. */
    bool ionization;  /*!< \brief Charged species with the mixture. */
    bool stretching;
    unsigned short nSpecies, nVar, nPrimVar, nPrimVarGrad, nDim;
    
    //  CVariable *var;
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimension of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CCentLax_TNE2(unsigned short val_nDim, unsigned short val_nVar,
                  unsigned short val_nPrimVar, unsigned short val_nPrimVarGrad,
                  CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CCentLax_TNE2(void);
    
    /*!
     * \brief Compute the flow residual using a Lax method.
     * \param[out] val_resconv - Pointer to the convective residual.
     * \param[out] val_resvisc - Pointer to the artificial viscosity residual.
     * \param[out] val_Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[out] val_Jacobian_j - Jacobian of the numerical method at node j (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_resconv, double *val_resvisc, double **val_Jacobian_i, double **val_Jacobian_j,
                         CConfig *config);
};

/*!
 * \class CAvgGrad_Flow
 * \brief Class for computing viscous term using the average of gradients.
 * \ingroup ViscDiscr
 * \author S. R. Copeland
 * \version 3.2.9 "eagle"
 */
class CAvgGrad_TNE2 : public CNumerics {
private:
    unsigned short iDim, iVar, nPrimVar, nPrimVarGrad;		/*!< \brief Iterators in dimension an variable. */
    double *Mean_PrimVar,					/*!< \brief Mean primitive variables. */
    *PrimVar_i, *PrimVar_j,				/*!< \brief Primitives variables at point i and 1. */
    **Mean_GradPrimVar,						/*!< \brief Mean value of the gradient. */
    *Mean_Diffusion_Coeff, /*!< \brief Mean value of the species diffusion coefficient. */
    Mean_Laminar_Viscosity, /*!< \brief Mean value of the viscosity. */
    Mean_Thermal_Conductivity, /*!< \brief Mean value of the thermal conductivity. */
    Mean_Thermal_Conductivity_ve, /*!< \brief Mean value of the vib-el. thermal conductivity. */
    
    *ProjFlux,	/*!< \brief Projection of the viscous fluxes. */
    dist_ij;						/*!< \brief Length of the edge and face. */
    bool implicit; /*!< \brief Implicit calculus. */
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimension of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] val_nPrimVar - Number of primitive variables of the problem.
     * \param[in] val_nPrimVarGrad - Number of variables in the primitive variable gradient.
     * \param[in] config - Definition of the particular problem.
     */
    CAvgGrad_TNE2(unsigned short val_nDim,
                  unsigned short val_nVar,
                  unsigned short val_nPrimVar,
                  unsigned short val_nPrimVarGrad,
                  CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CAvgGrad_TNE2(void);
    
    /*!
     * \brief Compute the viscous flow residual using an average of gradients.
     * \param[out] val_residual - Pointer to the total residual.
     * \param[out] val_Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[out] val_Jacobian_j - Jacobian of the numerical method at node j (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual,
                         double **val_Jacobian_i,
                         double **val_Jacobian_j,
                         CConfig *config);
};


/*!
 * \class CAvgGrad_Flow
 * \brief Class for computing viscous term using the average of gradients.
 * \ingroup ViscDiscr
 * \author S. R. Copeland
 * \version 3.2.9 "eagle"
 */
class CAvgGradCorrected_TNE2 : public CNumerics {
private:
    unsigned short iDim, iVar, nPrimVar, nPrimVarGrad;		/*!< \brief Iterators in dimension an variable. */
    double *Mean_PrimVar,					/*!< \brief Mean primitive variables. */
    *PrimVar_i, *PrimVar_j,				/*!< \brief Primitives variables at point i and 1. */
    **Mean_GradPrimVar,						/*!< \brief Mean value of the gradient. */
    *Edge_Vector,
    *Proj_Mean_GradPrimVar_Edge,  /*!< \brief Mean value of the gradient. */
    *Mean_Diffusion_Coeff, /*!< \brief Mean value of the species diffusion coefficient. */
    Mean_Laminar_Viscosity, /*!< \brief Mean value of the viscosity. */
    Mean_Thermal_Conductivity, /*!< \brief Mean value of the thermal conductivity. */
    Mean_Thermal_Conductivity_ve, /*!< \brief Mean value of the vib-el. thermal conductivity. */
    
    *ProjFlux,	/*!< \brief Projection of the viscous fluxes. */
    dist_ij;						/*!< \brief Length of the edge and face. */
    bool implicit; /*!< \brief Implicit calculus. */
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimension of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] val_nPrimVar - Number of primitive variables of the problem.
     * \param[in] val_nPrimVarGrad - Number of variables in the primitive variable gradient.
     * \param[in] config - Definition of the particular problem.
     */
    CAvgGradCorrected_TNE2(unsigned short val_nDim,
                           unsigned short val_nVar,
                           unsigned short val_nPrimVar,
                           unsigned short val_nPrimVarGrad,
                           CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CAvgGradCorrected_TNE2(void);
    
    /*!
     * \brief Compute the viscous flow residual using an average of gradients.
     * \param[out] val_residual - Pointer to the total residual.
     * \param[out] val_Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[out] val_Jacobian_j - Jacobian of the numerical method at node j (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual,
                         double **val_Jacobian_i,
                         double **val_Jacobian_j,
                         CConfig *config);
};


/*!
 * \class CSource_TNE2
 * \brief Class for two-temperature model source terms.
 * \ingroup SourceDiscr
 * \author S. Copeland
 * \version 2.0.6
 */
class CSource_TNE2 : public CNumerics {
private:
    bool   implicit, ionization;
    unsigned short nSpecies, nVar, nPrimVar, nPrimVarGrad;
    int    *alphak, *betak;
    double *X; // Mole fraction
    double **RxnConstantTable;
    double *dkf, *dkb, *dRfok, *dRbok, *A;
    double *eves, *Cvvs, *Cves;
    //  CVariable *var;
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CSource_TNE2(unsigned short val_nDim,
                 unsigned short val_nVar,
                 unsigned short val_nPrimVar,
                 unsigned short val_nPrimVarGrad,
                 CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CSource_TNE2(void);
    
    /*!
     * \brief Source residual of the chemistry.
     * \param[out] val_residual - Pointer to the total residual.
     * \param[out] val_Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeChemistry(double *val_residual, double **val_Jacobian_i, CConfig *config);
    
    /*!
     * \brief Calculates constants used for Keq correlation.
     * \param[out] A - Pointer to coefficient array.
     * \param[in] val_reaction - Reaction number indicator.
     * \param[in] config - Definition of the particular problem.
     */
    void GetKeqConstants(double *A, unsigned short val_reaction, CConfig *config);
    
    /*!
     * \brief Residual of the rotational frame source term.
     * \param[out] val_residual - Pointer to the total residual.
     * \param[out] val_Jacobian_i - Jacobian of the numerical method at node i (implicit computation).
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeVibRelaxation(double *val_residual, double **val_Jacobian_i, CConfig *config);
};


/*!
 * \class CUpwRoe_AdjTNE2
 * \brief Class for solving an approximate Riemann solver of Roe
 *        for the adjoint flow equations.
 * \ingroup ConvDiscr
 * \author F. Palacios
 * \version 2.0.6
 */
class CUpwRoe_AdjTNE2 : public CNumerics {
private:
    bool implicit;
    unsigned short nVar, nPrimVar, nPrimVarGrad, nSpecies;
    double *MeanU, *MeanV, *MeandPdU;
    double *DiffPsi;
    double *UnitNormal;
    double *Lambda;
    double **Ai, **Aj;
    double **P, **invP, **PLPinv;
    
    //  CVariable *var;
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CUpwRoe_AdjTNE2(unsigned short val_nDim, unsigned short val_nVar,
                    unsigned short val_nPrimVar, unsigned short val_nPrimVarGrad,
                    CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CUpwRoe_AdjTNE2(void);
    
    /*!
     * \brief Compute the adjoint Roe's flux between two nodes i and j.
     * \param[out] val_residual_i - Pointer to the total residual at point i.
     * \param[out] val_residual_j - Pointer to the total residual at point j.
     * \param[out] val_Jacobian_ii - Jacobian of the numerical method at node i (implicit computation) from node i.
     * \param[out] val_Jacobian_ij - Jacobian of the numerical method at node i (implicit computation) from node j.
     * \param[out] val_Jacobian_ji - Jacobian of the numerical method at node j (implicit computation) from node i.
     * \param[out] val_Jacobian_jj - Jacobian of the numerical method at node j (implicit computation) from node j.
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual_i, double *val_residual_j,
                         double **val_Jacobian_ii, double **val_Jacobian_ij,
                         double **val_Jacobian_ji, double **val_Jacobian_jj,
                         CConfig *config);
};

/*!
 * \class CUpwSW_AdjTNE2
 * \brief Class for solving an approximate Riemann solver of Roe
 *        for the adjoint flow equations.
 * \ingroup ConvDiscr
 * \author F. Palacios
 * \version 2.0.6
 */
class CUpwSW_AdjTNE2 : public CNumerics {
private:
    bool implicit;
    unsigned short nVar, nPrimVar, nPrimVarGrad, nSpecies;
    double *DiffPsi;
    double *UnitNormal;
    double *Lambda_i, *Lambda_j;
    double **P, **invP, **PLPinv;
    double **Ai, **Aj;
    
    //  CVariable *var;
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CUpwSW_AdjTNE2(unsigned short val_nDim, unsigned short val_nVar,
                   unsigned short val_nPrimVar, unsigned short val_nPrimVarGrad,
                   CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CUpwSW_AdjTNE2(void);
    
    /*!
     * \brief Compute the adjoint Roe's flux between two nodes i and j.
     * \param[out] val_residual_i - Pointer to the total residual at point i.
     * \param[out] val_residual_j - Pointer to the total residual at point j.
     * \param[out] val_Jacobian_ii - Jacobian of the numerical method at node i (implicit computation) from node i.
     * \param[out] val_Jacobian_ij - Jacobian of the numerical method at node i (implicit computation) from node j.
     * \param[out] val_Jacobian_ji - Jacobian of the numerical method at node j (implicit computation) from node i.
     * \param[out] val_Jacobian_jj - Jacobian of the numerical method at node j (implicit computation) from node j.
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual(double *val_residual_i, double *val_residual_j,
                         double **val_Jacobian_ii, double **val_Jacobian_ij,
                         double **val_Jacobian_ji, double **val_Jacobian_jj,
                         CConfig *config);
};


/*!
 * \class CCentJST_AdjTNE2
 * \brief Class for and adjoint centered scheme - JST.
 * \ingroup ConvDiscr
 * \author F. Palacios
 * \version 2.0.6
 */
class CCentJST_AdjTNE2 : public CNumerics {
private:
    double *Diff_Psi, *Diff_Lapl;
    double *Velocity_i, *Velocity_j;
    double *MeanPhi;
    unsigned short iDim, jDim, iVar, jVar;
    double Residual, ProjVelocity_i, ProjVelocity_j, ProjPhi, ProjPhi_Vel, sq_vel, phis1, phis2;
    double MeanPsiRho, MeanPsiE, Param_p, Param_Kappa_4, Param_Kappa_2, Local_Lambda_i, Local_Lambda_j, MeanLambda;
    double Phi_i, Phi_j, sc4, StretchingFactor, Epsilon_4, Epsilon_2;
    bool implicit, stretching, grid_movement, rotating_frame;
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CCentJST_AdjTNE2(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CCentJST_AdjTNE2(void);
    
    /*!
     * \brief Compute the adjoint flow residual using a JST method.
     * \param[out] val_resconv_i - Pointer to the convective residual at point i.
     * \param[out] val_resvisc_i - Pointer to the artificial viscosity residual at point i.
     * \param[out] val_resconv_j - Pointer to the convective residual at point j.
     * \param[out] val_resvisc_j - Pointer to the artificial viscosity residual at point j.
     * \param[out] val_Jacobian_ii - Jacobian of the numerical method at node i (implicit computation) from node i.
     * \param[out] val_Jacobian_ij - Jacobian of the numerical method at node i (implicit computation) from node j.
     * \param[out] val_Jacobian_ji - Jacobian of the numerical method at node j (implicit computation) from node i.
     * \param[out] val_Jacobian_jj - Jacobian of the numerical method at node j (implicit computation) from node j.
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual (double *val_resconv_i, double *val_resvisc_i, double *val_resconv_j, double *val_resvisc_j,
                          double **val_Jacobian_ii, double **val_Jacobian_ij, double **val_Jacobian_ji, double **val_Jacobian_jj,
                          CConfig *config);
};


/*!
 * \class CCentLax_AdjTNE2
 * \brief Class for computing the Lax-Friedrich adjoint centered scheme.
 * \ingroup ConvDiscr
 * \author F. Palacios
 * \version 2.0.6
 */
class CCentLax_AdjTNE2 : public CNumerics {
private:
    bool implicit;
    unsigned short nVar, nPrimVar, nPrimVarGrad, nSpecies, nDim;
    double *DiffPsi, *MeanPsi;
    double Param_p, Param_Kappa_0;
    double **Proj_Jac_Tensor_i, **Proj_Jac_Tensor_j;
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CCentLax_AdjTNE2(unsigned short val_nDim, unsigned short val_nVar,
                     unsigned short val_nPrimVar, unsigned short val_nPrimVarGrad,
                     CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CCentLax_AdjTNE2(void);
    
    /*!
     * \brief Compute the adjoint flow residual using a Lax method.
     * \param[out] val_resconv_i - Pointer to the convective residual at point i.
     * \param[out] val_resvisc_i - Pointer to the artificial viscosity residual at point i.
     * \param[out] val_resconv_j - Pointer to the convective residual at point j.
     * \param[out] val_resvisc_j - Pointer to the artificial viscosity residual at point j.
     * \param[out] val_Jacobian_ii - Jacobian of the numerical method at node i (implicit computation) from node i.
     * \param[out] val_Jacobian_ij - Jacobian of the numerical method at node i (implicit computation) from node j.
     * \param[out] val_Jacobian_ji - Jacobian of the numerical method at node j (implicit computation) from node i.
     * \param[out] val_Jacobian_jj - Jacobian of the numerical method at node j (implicit computation) from node j.
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeResidual (double *val_resconv_i, double *val_resvisc_i,
                          double *val_resconv_j, double *val_resvisc_j,
                          double **val_Jacobian_ii, double **val_Jacobian_ij,
                          double **val_Jacobian_ji, double **val_Jacobian_jj,
                          CConfig *config);
};

/*!
 * \class CAvgGrad_AdjTNE2
 * \brief Class for computing the adjoint viscous terms.
 * \ingroup ViscDiscr
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CAvgGrad_AdjTNE2 : public CNumerics {
private:
    double *vel, *vel_i, *vel_j;
    double *Mean_GradPsiE;	/*!< \brief Mean gradient in the adjoint  energy between nodes i and j. */
    double *Mean_GradPsiEve; /*!< \brief Mean gradient in the adjoint vibrational energy between nodes i and j. */
    double **Mean_GradPhi;	/*!< \brief Counter for dimensions of the problem. */
    double **Mean_GPsi;  /*!< \brief Mean gradient of the adjoint variables. */
    double *Edge_Vector;	/*!< \brief Vector going from node i to node j. */
    double **SigmaPhi;
    double **SigmaPsiE;
    bool implicit;			/*!< \brief Implicit calculus. */
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CAvgGrad_AdjTNE2(unsigned short val_nDim, unsigned short val_nVar, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CAvgGrad_AdjTNE2(void);
    
    /*!
     * \brief Residual computation.
     * \param[out] val_residual_i - Pointer to the total residual at point i.
     * \param[out] val_residual_j - Pointer to the total residual at point j.
     */
    void ComputeResidual(double *val_residual_i, double *val_residual_j,
                         double **val_Jacobian_ii, double **val_Jacobian_ij,
                         double **val_Jacobian_ji, double **val_Jacobian_jj, CConfig *config);
};

/*!
 * \class CSource_AdjTNE2
 * \brief Class for adjoint two-temperature model source terms.
 * \ingroup SourceDiscr
 * \author S. Copeland
 * \version 2.0.6
 */
class CSource_AdjTNE2 : public CNumerics {
private:
    bool   implicit;
    unsigned short nSpecies, nVar, nPrimVar, nPrimVarGrad;
    double *rhos, *vel;
    double *GInvRho, **GVeloRho, **tau, **eta, **pi, **zeta;
    double *GPhiGInvRho, *GPsiEZetaTau;
    double **Av2, **Av3, **Av4;
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] val_nDim - Number of dimensions of the problem.
     * \param[in] val_nVar - Number of variables of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CSource_AdjTNE2(unsigned short val_nDim,
                    unsigned short val_nVar,
                    unsigned short val_nPrimVar,
                    unsigned short val_nPrimVarGrad,
                    CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CSource_AdjTNE2(void);
    
    /*!
     * \brief Source residual of the chemistry.
     * \param[out] val_residual - Pointer to the total residual.
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeSourceViscous(double *val_residual, CConfig *config);
    
    /*!
     * \brief Residual of the rotational frame source term.
     * \param[out] val_residual - Pointer to the total residual.
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeSourceConservative(double *val_residual, CConfig *config);
};


/* Solver_Structure.h--------------------------------------------------------
 *
 *
 *
 *
 ---------------------------------------------------------------------*/

/*!
 * \class CSolver
 * \brief Main class for defining the PDE solution, it requires
 * a child class for each particular solver (Euler, Navier-Stokes, etc.)
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CSolver {
protected:
    unsigned short IterLinSolver;	/*!< \brief Linear solver iterations. */
    unsigned short nVar,					/*!< \brief Number of variables of the problem. */
    nPrimVar,                     /*!< \brief Number of primitive variables of the problem. */
    nPrimVarGrad,                 /*!< \brief Number of primitive variables of the problem in the gradient computation. */
    nSecondaryVar,                     /*!< \brief Number of primitive variables of the problem. */
    nSecondaryVarGrad,                 /*!< \brief Number of primitive variables of the problem in the gradient computation. */
    nDim;													/*!< \brief Number of dimensions of the problem. */
    unsigned long nPoint;					/*!< \brief Number of points of the computational grid. */
    unsigned long nPointDomain; 	/*!< \brief Number of points of the computational grid. */
    double Max_Delta_Time,	/*!< \brief Maximum value of the delta time for all the control volumes. */
    Min_Delta_Time;					/*!< \brief Minimum value of the delta time for all the control volumes. */
    double *Residual_RMS,	/*!< \brief Vector with the mean residual for each variable. */
    *Residual_Max,        /*!< \brief Vector with the maximal residual for each variable. */
    *Residual,						/*!< \brief Auxiliary nVar vector. */
    *Residual_i,					/*!< \brief Auxiliary nVar vector for storing the residual at point i. */
    *Residual_j;					/*!< \brief Auxiliary nVar vector for storing the residual at point j. */
    unsigned long *Point_Max; /*!< \brief Vector with the maximal residual for each variable. */
    double **Point_Max_Coord; /*!< \brief Vector with pointers to the coords of the maximal residual for each variable. */
    double *Solution,		/*!< \brief Auxiliary nVar vector. */
    *Solution_i,				/*!< \brief Auxiliary nVar vector for storing the solution at point i. */
    *Solution_j;				/*!< \brief Auxiliary nVar vector for storing the solution at point j. */
    double *Vector,	/*!< \brief Auxiliary nDim vector. */
    *Vector_i,			/*!< \brief Auxiliary nDim vector to do the reconstruction of the variables at point i. */
    *Vector_j;			/*!< \brief Auxiliary nDim vector to do the reconstruction of the variables at point j. */
    double *Res_Conv,	/*!< \brief Auxiliary nVar vector for storing the convective residual. */
    *Res_Visc,				/*!< \brief Auxiliary nVar vector for storing the viscous residual. */
    *Res_Sour,				/*!< \brief Auxiliary nVar vector for storing the viscous residual. */
    *Res_Conv_i,		  /*!< \brief Auxiliary vector for storing the convective residual at point i. */
    *Res_Visc_i,			/*!< \brief Auxiliary vector for storing the viscous residual at point i. */
    *Res_Conv_j,			/*!< \brief Auxiliary vector for storing the convective residual at point j. */
    *Res_Visc_j;			/*!< \brief Auxiliary vector for storing the viscous residual at point j. */
    double **Jacobian_i,	/*!< \brief Auxiliary matrices for storing point to point Jacobians at point i. */
    **Jacobian_j;			    /*!< \brief Auxiliary matrices for storing point to point Jacobians at point j. */
    double **Jacobian_ii,	/*!< \brief Auxiliary matrices for storing point to point Jacobians. */
    **Jacobian_ij,			  /*!< \brief Auxiliary matrices for storing point to point Jacobians. */
    **Jacobian_ji,			  /*!< \brief Auxiliary matrices for storing point to point Jacobians. */
    **Jacobian_jj;			  /*!< \brief Auxiliary matrices for storing point to point Jacobians. */
    
    double **Smatrix,	/*!< \brief Auxiliary structure for computing gradients by least-squares */
    **cvector;			 /*!< \brief Auxiliary structure for computing gradients by least-squares */
    
    unsigned short nOutputVariables;  /*!< \brief Number of variables to write. */
    
public:
    
    CSysVector LinSysSol;		/*!< \brief vector to store iterative solution of implicit linear system. */
    CSysVector LinSysRes;		/*!< \brief vector to store iterative residual of implicit linear system. */
    CSysVector LinSysAux;		/*!< \brief vector to store iterative residual of implicit linear system. */
    CSysMatrix Jacobian; /*!< \brief Complete sparse Jacobian structure for implicit computations. */
    
    CSysMatrix StiffMatrix; /*!< \brief Sparse structure for storing the stiffness matrix in Galerkin computations, and grid movement. */
    
    CSysVector OutputVariables;		/*!< \brief vector to store the extra variables to be written. */
    string* OutputHeadingNames; /*< \brief vector of strings to store the headings for the exra variables */
    
    CVariable** node;	/*!< \brief Vector which the define the variables for each problem. */
    CVariable* node_infty; /*!< \brief CVariable storing the free stream conditions. */
    
    /*!
     * \brief Constructor of the class.
     */
    CSolver(void);
    
    /*!
     * \brief Destructor of the class.
     */
    virtual ~CSolver(void);
    
    /*!
     * \brief Set number of linear solver iterations.
     * \param[in] val_iterlinsolver - Number of linear iterations.
     */
    void SetIterLinSolver(unsigned short val_iterlinsolver);
    
    /*!
     * \brief Set number of linear solver iterations.
     * \param[in] val_iterlinsolver - Number of linear iterations.
     */
    virtual void Set_MPI_Solution(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Set number of linear solver iterations.
     * \param[in] val_iterlinsolver - Number of linear iterations.
     */
    virtual void Set_MPI_Primitive(CGeometry *geometry, CConfig *config);
    
    //  /*!
    //	 * \brief Set number of linear solver iterations.
    //	 * \param[in] val_iterlinsolver - Number of linear iterations.
    //	 */
    //	virtual void Set_MPI_Secondary(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Set the value of the max residual and RMS residual.
     * \param[in] val_iterlinsolver - Number of linear iterations.
     */
    void SetResidual_RMS(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Set number of linear solver iterations.
     * \param[in] val_iterlinsolver - Number of linear iterations.
     */
    virtual void Set_MPI_Solution_Old(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Impose the send-receive boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void Set_MPI_Solution_Limiter(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Impose the send-receive boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void Set_MPI_Primitive_Limiter(CGeometry *geometry, CConfig *config);
    
    //  /*!
    //	 * \brief Impose the send-receive boundary condition.
    //	 * \param[in] geometry - Geometrical definition of the problem.
    //	 * \param[in] config - Definition of the particular problem.
    //	 */
    //  virtual void Set_MPI_Secondary_Limiter(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Set the fluid solver nondimensionalization.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void SetNondimensionalization(CGeometry *geometry, CConfig *config, unsigned short iMesh);
    
    /*!
     * \brief Compute the pressure at the infinity.
     * \return Value of the pressure at the infinity.
     */
    virtual CFluidModel* GetFluidModel(void);
    
    /*!
     * \brief Get number of linear solver iterations.
     * \return Number of linear solver iterations.
     */
    unsigned short GetIterLinSolver(void);
    
    /*!
     * \brief Get the value of the maximum delta time.
     * \return Value of the maximum delta time.
     */
    double GetMax_Delta_Time(void);
    
    /*!
     * \brief Get the value of the minimum delta time.
     * \return Value of the minimum delta time.
     */
    double GetMin_Delta_Time(void);
    
    /*!
     * \brief Get the value of the maximum delta time.
     * \return Value of the maximum delta time.
     */
    virtual double GetMax_Delta_Time(unsigned short val_Species);
    
    /*!
     * \brief Get the value of the minimum delta time.
     * \return Value of the minimum delta time.
     */
    virtual double GetMin_Delta_Time(unsigned short val_Species);
    
    /*!
     * \brief Get the number of variables of the problem.
     */
    unsigned short GetnVar(void);
    
    /*!
     * \brief Get the number of variables of the problem.
     */
    unsigned short GetnPrimVar(void);
    
    /*!
     * \brief Get the number of variables of the problem.
     */
    unsigned short GetnPrimVarGrad(void);
    
    /*!
     * \brief Get the number of variables of the problem.
     */
    unsigned short GetnSecondaryVar(void);
    
    /*!
     * \brief Get the number of variables of the problem.
     */
    unsigned short GetnSecondaryVarGrad(void);
    
    /*!
     * \brief Get the number of variables of the problem.
     */
    unsigned short GetnOutputVariables(void);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iRKStep - Current step of the Runge-Kutta iteration.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     * \param[in] RunTime_EqSystem - System of equations which is going to be solved.
     */
    virtual void SetResidual_DualTime(CGeometry *geometry, CSolver **solver_container, CConfig *config,
                                      unsigned short iRKStep, unsigned short iMesh, unsigned short RunTime_EqSystem);
    
    /*!
     * \brief Set the maximal residual, this is useful for the convergence history.
     * \param[in] val_var - Index of the variable.
     * \param[in] val_residual - Value of the residual to store in the position <i>val_var</i>.
     */
    void SetRes_RMS(unsigned short val_var, double val_residual);
    
    /*!
     * \brief Adds the maximal residual, this is useful for the convergence history.
     * \param[in] val_var - Index of the variable.
     * \param[in] val_residual - Value of the residual to store in the position <i>val_var</i>.
     */
    void AddRes_RMS(unsigned short val_var, double val_residual);
    
    /*!
     * \brief Get the maximal residual, this is useful for the convergence history.
     * \param[in] val_var - Index of the variable.
     * \return Value of the biggest residual for the variable in the position <i>val_var</i>.
     */
    double GetRes_RMS(unsigned short val_var);
    
    /*!
     * \brief Set the maximal residual, this is useful for the convergence history.
     * \param[in] val_var - Index of the variable.
     * \param[in] val_residual - Value of the residual to store in the position <i>val_var</i>.
     */
    void SetRes_Max(unsigned short val_var, double val_residual, unsigned long val_point);
    
    /*!
     * \brief Adds the maximal residual, this is useful for the convergence history.
     * \param[in] val_var - Index of the variable.
     * \param[in] val_residual - Value of the residual to store in the position <i>val_var</i>.
     * \param[in] val_point - Value of the point index for the max residual.
     * \param[in] val_coord - Location (x, y, z) of the max residual point.
     */
    void AddRes_Max(unsigned short val_var, double val_residual, unsigned long val_point, double* val_coord);
    
    /*!
     * \brief Get the maximal residual, this is useful for the convergence history.
     * \param[in] val_var - Index of the variable.
     * \return Value of the biggest residual for the variable in the position <i>val_var</i>.
     */
    double GetRes_Max(unsigned short val_var);
    
    /*!
     * \brief Get the maximal residual, this is useful for the convergence history.
     * \param[in] val_var - Index of the variable.
     * \return Value of the biggest residual for the variable in the position <i>val_var</i>.
     */
    unsigned long GetPoint_Max(unsigned short val_var);
    
    /*!
     * \brief Get the location of the maximal residual, this is useful for the convergence history.
     * \param[in] val_var - Index of the variable.
     * \return Pointer to the location (x, y, z) of the biggest residual for the variable <i>val_var</i>.
     */
    double* GetPoint_Max_Coord(unsigned short val_var);
    
    /*!
     * \brief Set Value of the residual if there is a grid movement.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void SetGrid_Movement_Residual(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Compute the Green-Gauss gradient of the auxiliary variable.
     * \param[in] geometry - Geometrical definition of the problem.
     */
    void SetAuxVar_Gradient_GG(CGeometry *geometry);
    
    /*!
     * \brief Compute the Least Squares gradient of the auxiliary variable.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void SetAuxVar_Gradient_LS(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Compute the Least Squares gradient of an auxiliar variable on the profile surface.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void SetAuxVar_Surface_Gradient(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Compute the Green-Gauss gradient of the solution.
     * \param[in] geometry - Geometrical definition of the problem.
     */
    void SetSolution_Gradient_GG(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Compute the Least Squares gradient of the solution.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void SetSolution_Gradient_LS(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief MPI gradients.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void Set_MPI_Solution_Gradient(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Compute the Least Squares gradient of the grid velocity.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void SetGridVel_Gradient(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Compute slope limiter.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void SetSolution_Limiter(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void SetPrimitive_Limiter(CGeometry *geometry, CConfig *config);
    
    //	/*!
    //	 * \brief A virtual member.
    //	 * \param[in] geometry - Geometrical definition of the problem.
    //	 * \param[in] config - Definition of the particular problem.
    //	 */
    //	virtual void SetSecondary_Limiter(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Compute the pressure laplacian using in a incompressible solver.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] PressureLaplacian - Pressure laplacian.
     */
    void SetPressureLaplacian(CGeometry *geometry, double *PressureLaplacian);
    
    /*!
     * \brief Set the old solution variables to the current solution value for Runge-Kutta iteration.
     * \param[in] geometry - Geometrical definition of the problem.
     */
    void Set_OldSolution(CGeometry *geometry);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     * \param[in] Iteration - Index of the current iteration.
     */
    virtual void SetTime_Step(CGeometry *geometry, CSolver **solver_container, CConfig *config,
                              unsigned short iMesh, unsigned long Iteration);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     */
    virtual void Postprocessing(CGeometry *geometry, CSolver **solver_container, CConfig *config,
                                unsigned short iMesh);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     * \param[in] iRKStep - Current step of the Runge-Kutta iteration.
     */
    virtual void Centered_Residual(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics,
                                   CConfig *config, unsigned short iMesh, unsigned short iRKStep);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     */
    virtual void Upwind_Residual(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics,
                                 CConfig *config, unsigned short iMesh);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iRKStep - Current step of the Runge-Kutta iteration.
     * \param[in] RunTime_EqSystem - System of equations which is going to be solved.
     */
    virtual void Preprocessing(CGeometry *geometry, CSolver **solver_container, CConfig *config, unsigned short iMesh, unsigned short iRKStep, unsigned short RunTime_EqSystem, bool Output);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void SetUndivided_Laplacian(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void Set_MPI_Undivided_Laplacian(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void SetMax_Eigenvalue(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void Set_MPI_MaxEigenvalue(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void SetDissipation_Switch(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void Set_MPI_Dissipation_Switch(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    virtual void BC_Euler_Wall(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics, CConfig *config,
                               unsigned short val_marker);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    virtual void BC_Normal_Displacement(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics, CConfig *config,
                                        unsigned short val_marker);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    virtual void BC_Flow_Load(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics, CConfig *config,
                              unsigned short val_marker);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    virtual void BC_Normal_Load(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics, CConfig *config,
                                unsigned short val_marker);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    virtual void BC_Pressure(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics, CConfig *config,
                             unsigned short val_marker);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    virtual void BC_Interface_Boundary(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics, CConfig *config);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    virtual void BC_NearField_Boundary(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics, CConfig *config);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    virtual void BC_ActDisk_Boundary(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics, CConfig *config);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    virtual void BC_Isothermal_Wall(CGeometry *geometry,
                                    CSolver **solver_container,
                                    CNumerics *conv_numerics,
                                    CNumerics *visc_numerics,
                                    CConfig *config,
                                    unsigned short val_marker);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    virtual void BC_IsothermalCatalytic_Wall(CGeometry *geometry,
                                             CSolver **solver_container,
                                             CNumerics *conv_numerics,
                                             CNumerics *visc_numerics,
                                             CConfig *config,
                                             unsigned short val_marker);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    virtual void BC_IsothermalNonCatalytic_Wall(CGeometry *geometry,
                                                CSolver **solver_container,
                                                CNumerics *conv_numerics,
                                                CNumerics *visc_numerics,
                                                CConfig *config,
                                                unsigned short val_marker);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    virtual void BC_HeatFlux_Wall(CGeometry *geometry, CSolver **solver_container,
                                  CNumerics *conv_numerics,
                                  CNumerics *visc_numerics, CConfig *config,
                                  unsigned short val_marker);
    
    /*!
     * \brief Impose a constant heat-flux condition at the wall.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method for convective terms.
     * \param[in] visc_numerics - Description of the numerical method for viscous terms.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    virtual void BC_HeatFluxCatalytic_Wall(CGeometry *geometry,
                                           CSolver **solver_container,
                                           CNumerics *conv_numerics,
                                           CNumerics *visc_numerics,
                                           CConfig *config,
                                           unsigned short val_marker);
    
    /*!
     * \brief Impose a constant heat-flux condition at the wall.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method for convective terms.
     * \param[in] visc_numerics - Description of the numerical method for viscous terms.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    virtual void BC_HeatFluxNonCatalytic_Wall(CGeometry *geometry,
                                              CSolver **solver_container,
                                              CNumerics *conv_numerics,
                                              CNumerics *visc_numerics,
                                              CConfig *config,
                                              unsigned short val_marker);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    virtual void BC_Dirichlet(CGeometry *geometry, CSolver **solver_container, CConfig *config,
                              unsigned short val_marker);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    virtual void BC_Neumann(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics, CConfig *config,
                            unsigned short val_marker);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    virtual void BC_Far_Field(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics, CConfig *config,
                              unsigned short val_marker);
    
    /*!
     * \brief Impose via the residual the Euler boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    virtual void BC_Sym_Plane(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics, CConfig *config, unsigned short val_marker);
    
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    virtual void BC_Riemann(CGeometry *geometry, CSolver **solver_container,
                            CNumerics *conv_numerics, CNumerics *visc_numerics, CConfig *config, unsigned short val_marker);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    virtual void BC_Inlet(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics,
                          CConfig *config, unsigned short val_marker);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    virtual void BC_Supersonic_Inlet(CGeometry *geometry, CSolver **solver_container,
                                     CNumerics *conv_numerics, CNumerics *visc_numerics, CConfig *config, unsigned short val_marker);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    virtual void BC_Supersonic_Outlet(CGeometry *geometry, CSolver **solver_container,
                                      CNumerics *conv_numerics, CNumerics *visc_numerics, CConfig *config, unsigned short val_marker);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    virtual void BC_Custom(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics,
                           CConfig *config, unsigned short val_marker);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    virtual void BC_Outlet(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics,
                           CConfig *config, unsigned short val_marker);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    virtual void BC_Engine_Inflow(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics, CConfig *config, unsigned short val_marker);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    virtual void BC_Engine_Bleed(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics, CConfig *config, unsigned short val_marker);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    virtual void BC_Engine_Exhaust(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics, CConfig *config, unsigned short val_marker);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    virtual void BC_Dielec(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics,
                           CConfig *config, unsigned short val_marker);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    virtual void BC_Electrode(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics,
                              CConfig *config, unsigned short val_marker);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iRKStep - Current step of the Runge-Kutta iteration.
     */
    virtual void ExplicitRK_Iteration(CGeometry *geometry, CSolver **solver_container, CConfig *config,
                                      unsigned short iRKStep);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void ExplicitEuler_Iteration(CGeometry *geometry, CSolver **solver_container, CConfig *config);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void ImplicitEuler_Iteration(CGeometry *geometry, CSolver **solver_container, CConfig *config);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     */
    virtual void Compute_Residual(CGeometry *geometry, CSolver **solver_container, CConfig *config,
                                  unsigned short iMesh);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void Inviscid_Forces(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void Inviscid_DeltaForces(CGeometry *geometry, CSolver **solver_container, CConfig *config);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void Viscous_Forces(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void Viscous_DeltaForces(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void Wave_Strength(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void SetPrimitive_Gradient_GG(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void SetPrimitive_Gradient_LS(CGeometry *geometry, CConfig *config);
    
    //	/*!
    //	 * \brief A virtual member.
    //	 * \param[in] geometry - Geometrical definition of the problem.
    //	 * \param[in] config - Definition of the particular problem.
    //	 */
    //	virtual void SetSecondary_Gradient_GG(CGeometry *geometry, CConfig *config);
    
    //	/*!
    //	 * \brief A virtual member.
    //	 * \param[in] geometry - Geometrical definition of the problem.
    //	 * \param[in] config - Definition of the particular problem.
    //	 */
    //	virtual void SetSecondary_Gradient_LS(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void Set_MPI_Primitive_Gradient(CGeometry *geometry, CConfig *config);
    
    //  /*!
    //	 * \brief A virtual member.
    //	 * \param[in] geometry - Geometrical definition of the problem.
    //	 * \param[in] config - Definition of the particular problem.
    //	 */
    //	virtual void Set_MPI_Secondary_Gradient(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void SetPrimitive_Limiter_MPI(CGeometry *geometry, CConfig *config);
    
    //  /*!
    //	 * \brief A virtual member.
    //	 * \param[in] geometry - Geometrical definition of the problem.
    //	 * \param[in] config - Definition of the particular problem.
    //	 */
    //	virtual void SetSecondary_Limiter_MPI(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief A virtual member.
     * \param[in] iPoint - Index of the grid point.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void SetPreconditioner(CConfig *config, unsigned short iPoint);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     * \param[in] iRKStep - Current step of the Runge-Kutta iteration.
     */
    virtual void Viscous_Residual(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics,
                                  CConfig *config, unsigned short iMesh, unsigned short iRKStep);
    
    /*!
     * \brief A virtual member.
     * \param[in] StiffMatrix_Elem - Stiffness matrix of an element
     */
    virtual void AddStiffMatrix(double **StiffMatrix_Elem, unsigned long Point_0, unsigned long Point_1, unsigned long Point_2, unsigned long Point_3 );
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     */
    virtual void Source_Residual(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics, CNumerics *second_numerics,
                                 CConfig *config, unsigned short iMesh);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     */
    virtual void Source_Template(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics,
                                 CConfig *config, unsigned short iMesh);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \param[in] val_vertex - Vertex of the marker <i>val_marker</i> where the coefficient is evaluated.
     * \param[in] val_sensitivity - Value of the sensitivity coefficient.
     */
    virtual void SetCSensitivity(unsigned short val_marker, unsigned short val_vertex, double val_sensitivity);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void SetForceProj_Vector(CGeometry *geometry, CSolver **solver_container, CConfig *config);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void SetIntBoundary_Jump(CGeometry *geometry, CSolver **solver_container, CConfig *config);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_Total_CDrag - Value of the total drag coefficient.
     */
    virtual void SetTotal_CDrag(double val_Total_CDrag);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_Total_CLift - Value of the total lift coefficient.
     */
    virtual void SetTotal_CLift(double val_Total_CLift);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_Total_CT - Value of the total thrust coefficient.
     */
    virtual void SetTotal_CT(double val_Total_CT);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_Total_CQ - Value of the total torque coefficient.
     */
    virtual void SetTotal_CQ(double val_Total_CQ);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_Total_Heat - Value of the total heat load.
     */
    virtual void SetTotal_HeatFlux(double val_Total_Heat);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_Total_MaxHeat - Value of the total heat load.
     */
    virtual void SetTotal_MaxHeatFlux(double val_Total_MaxHeat);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void SetDistance(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void Inviscid_Sensitivity(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics, CConfig *config);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void Smooth_Sensitivity(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics, CConfig *config);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void Viscous_Sensitivity(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics, CConfig *config);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \return Value of the lift coefficient (inviscid contribution) on the surface <i>val_marker</i>.
     */
    virtual double GetCLift_Inv(unsigned short val_marker);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \return Value of the lift coefficient (viscous contribution) on the surface <i>val_marker</i>.
     */
    virtual double GetCLift_Visc(unsigned short val_marker);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \return Value of the z moment coefficient (inviscid contribution) on the surface <i>val_marker</i>.
     */
    virtual double GetCMz_Inv(unsigned short val_marker);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \return Value of the z moment coefficient (viscous contribution) on the surface <i>val_marker</i>.
     */
    virtual double GetCMz_Visc(unsigned short val_marker);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \return Value of the lift coefficient on the surface <i>val_marker</i>.
     */
    virtual double GetSurface_CLift(unsigned short val_marker);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \return Value of the drag coefficient on the surface <i>val_marker</i>.
     */
    virtual double GetSurface_CDrag(unsigned short val_marker);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \return Value of the side force coefficient on the surface <i>val_marker</i>.
     */
    virtual double GetSurface_CSideForce(unsigned short val_marker);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \return Value of the side force coefficient on the surface <i>val_marker</i>.
     */
    virtual double GetSurface_CEff(unsigned short val_marker);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \return Value of the x force coefficient on the surface <i>val_marker</i>.
     */
    virtual double GetSurface_CFx(unsigned short val_marker);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \return Value of the y force coefficient on the surface <i>val_marker</i>.
     */
    virtual double GetSurface_CFy(unsigned short val_marker);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \return Value of the z force coefficient on the surface <i>val_marker</i>.
     */
    virtual double GetSurface_CFz(unsigned short val_marker);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \return Value of the x moment coefficient on the surface <i>val_marker</i>.
     */
    virtual double GetSurface_CMx(unsigned short val_marker);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \return Value of the y moment coefficient on the surface <i>val_marker</i>.
     */
    virtual double GetSurface_CMy(unsigned short val_marker);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \return Value of the z moment coefficient on the surface <i>val_marker</i>.
     */
    virtual double GetSurface_CMz(unsigned short val_marker);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \return Value of the lift coefficient on the surface <i>val_marker</i>.
     */
    virtual double GetSurface_CLift_Inv(unsigned short val_marker);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \return Value of the drag coefficient on the surface <i>val_marker</i>.
     */
    virtual double GetSurface_CDrag_Inv(unsigned short val_marker);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \return Value of the side force coefficient on the surface <i>val_marker</i>.
     */
    virtual double GetSurface_CSideForce_Inv(unsigned short val_marker);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \return Value of the side force coefficient on the surface <i>val_marker</i>.
     */
    virtual double GetSurface_CEff_Inv(unsigned short val_marker);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \return Value of the x force coefficient on the surface <i>val_marker</i>.
     */
    virtual double GetSurface_CFx_Inv(unsigned short val_marker);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \return Value of the y force coefficient on the surface <i>val_marker</i>.
     */
    virtual double GetSurface_CFy_Inv(unsigned short val_marker);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \return Value of the z force coefficient on the surface <i>val_marker</i>.
     */
    virtual double GetSurface_CFz_Inv(unsigned short val_marker);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \return Value of the x moment coefficient on the surface <i>val_marker</i>.
     */
    virtual double GetSurface_CMx_Inv(unsigned short val_marker);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \return Value of the y moment coefficient on the surface <i>val_marker</i>.
     */
    virtual double GetSurface_CMy_Inv(unsigned short val_marker);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \return Value of the z moment coefficient on the surface <i>val_marker</i>.
     */
    virtual double GetSurface_CMz_Inv(unsigned short val_marker);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \return Value of the lift coefficient (viscous contribution) on the surface <i>val_marker</i>.
     */
    virtual double GetCSideForce_Visc(unsigned short val_marker);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \return Value of the drag coefficient (inviscid contribution) on the surface <i>val_marker</i>.
     */
    virtual double GetCDrag_Inv(unsigned short val_marker);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \return Value of the mass flow rate on the surface <i>val_marker</i>.
     */
    virtual double GetInflow_MassFlow(unsigned short val_marker);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \return Value of the mass flow rate on the surface <i>val_marker</i>.
     */
    virtual double GetExhaust_MassFlow(unsigned short val_marker);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \return Value of the fan face pressure on the surface <i>val_marker</i>.
     */
    virtual double GetInflow_Pressure(unsigned short val_marker);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \return Value of the fan face mach on the surface <i>val_marker</i>.
     */
    virtual double GetInflow_Mach(unsigned short val_marker);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \return Value of the sideforce coefficient (inviscid contribution) on the surface <i>val_marker</i>.
     */
    virtual double GetCSideForce_Inv(unsigned short val_marker);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \return Value of the efficiency coefficient (inviscid contribution) on the surface <i>val_marker</i>.
     */
    virtual double GetCEff_Inv(unsigned short val_marker);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \return Value of the drag coefficient (viscous contribution) on the surface <i>val_marker</i>.
     */
    virtual double GetCDrag_Visc(unsigned short val_marker);
    
    /*!
     * \brief A virtual member.
     * \return Value of the lift coefficient (inviscid + viscous contribution).
     */
    virtual double GetTotal_CLift(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the sideforce coefficient (inviscid + viscous contribution).
     */
    virtual double GetTotal_CSideForce(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the efficiency coefficient (inviscid + viscous contribution).
     */
    virtual double GetTotal_CEff(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the thrust coefficient (force in the -x direction, inviscid + viscous contribution).
     */
    virtual double GetTotal_CT(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the torque coefficient (moment in the -x direction, inviscid + viscous contribution).
     */
    virtual double GetTotal_CQ(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the heat load (integrated heat flux).
     */
    virtual double GetTotal_HeatFlux(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the heat load (integrated heat flux).
     */
    virtual double GetTotal_MaxHeatFlux(void);
    
    /*!
     * \brief Provide the total (inviscid + viscous) non dimensional drag coefficient.
     * \return Value of the drag coefficient (inviscid + viscous contribution).
     */
    virtual double Get_PressureDrag(void);
    
    /*!
     * \brief Provide the total (inviscid + viscous) non dimensional drag coefficient.
     * \return Value of the drag coefficient (inviscid + viscous contribution).
     */
    virtual double Get_ViscDrag(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the rotor Figure of Merit (FM) (inviscid + viscous contribution).
     */
    virtual double GetTotal_CMerit(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the Equivalent Area coefficient (inviscid + viscous contribution).
     */
    virtual double GetTotal_CEquivArea(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the difference of the presure and the target pressure.
     */
    virtual double GetTotal_CpDiff(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the difference of the heat and the target heat.
     */
    virtual double GetTotal_HeatFluxDiff(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the Free Surface coefficient (inviscid + viscous contribution).
     */
    virtual double GetTotal_CFreeSurface(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the FEA coefficient (inviscid + viscous contribution).
     */
    virtual double GetTotal_CFEA(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the Near-Field Pressure coefficient (inviscid + viscous contribution).
     */
    virtual double GetTotal_CNearFieldOF(void);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_cequivarea - Value of the Equivalent Area coefficient.
     */
    virtual void SetTotal_CEquivArea(double val_cequivarea);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_pressure - Value of the difference between pressure and the target pressure.
     */
    virtual void SetTotal_CpDiff(double val_pressure);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_pressure - Value of the difference between heat and the target heat.
     */
    virtual void SetTotal_HeatFluxDiff(double val_heat);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_cfreesurface - Value of the Free Surface coefficient.
     */
    virtual void SetTotal_CFreeSurface(double val_cfreesurface);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_cfea - Value of the FEA coefficient.
     */
    virtual void SetTotal_CFEA(double val_cfea);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_cnearfieldpress - Value of the Near-Field pressure coefficient.
     */
    virtual void SetTotal_CNearFieldOF(double val_cnearfieldpress);
    
    /*!
     * \brief A virtual member.
     * \return Value of the linearized lift coefficient (inviscid contribution).
     */
    virtual double GetTotal_CDeltaLift(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the drag coefficient (inviscid + viscous contribution).
     */
    virtual double GetTotal_CDrag(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the moment x coefficient (inviscid + viscous contribution).
     */
    virtual double GetTotal_CMx(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the moment y coefficient (inviscid + viscous contribution).
     */
    virtual double GetTotal_CMy(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the moment y coefficient (inviscid + viscous contribution).
     */
    virtual double GetTotal_CMz(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the force x coefficient (inviscid + viscous contribution).
     */
    virtual double GetTotal_CFx(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the force y coefficient (inviscid + viscous contribution).
     */
    virtual double GetTotal_CFy(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the force y coefficient (inviscid + viscous contribution).
     */
    virtual double GetTotal_CFz(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the wave strength.
     */
    virtual double GetTotal_CWave(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the wave strength.
     */
    virtual double GetTotal_CHeat(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the linearized drag coefficient (inviscid contribution).
     */
    virtual double GetTotal_CDeltaDrag(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the lift coefficient (inviscid contribution).
     */
    virtual double GetAllBound_CLift_Inv(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the drag coefficient (inviscid contribution).
     */
    virtual double GetAllBound_CDrag_Inv(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the drag coefficient (inviscid contribution).
     */
    virtual double GetAllBound_CSideForce_Inv(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the drag coefficient (inviscid contribution).
     */
    virtual double GetAllBound_CEff_Inv(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the drag coefficient (inviscid contribution).
     */
    virtual double GetAllBound_CMx_Inv(void);
    /*!
     * \brief A virtual member.
     * \return Value of the drag coefficient (inviscid contribution).
     */
    virtual double GetAllBound_CMy_Inv(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the drag coefficient (inviscid contribution).
     */
    virtual double GetAllBound_CMz_Inv(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the drag coefficient (inviscid contribution).
     */
    virtual double GetAllBound_CFx_Inv(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the drag coefficient (inviscid contribution).
     */
    virtual double GetAllBound_CFy_Inv(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the drag coefficient (inviscid contribution).
     */
    virtual double GetAllBound_CFz_Inv(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the lift coefficient (viscous contribution).
     */
    virtual double GetAllBound_CLift_Visc(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the lift coefficient (viscous contribution).
     */
    virtual double GetAllBound_CSideForce_Visc(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the drag coefficient (viscous contribution).
     */
    virtual double GetAllBound_CDrag_Visc(void);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \param[in] val_vertex - Vertex of the marker <i>val_marker</i> where the coefficient is evaluated.
     * \return Value of the pressure coefficient.
     */
    virtual double GetCPressure(unsigned short val_marker, unsigned short val_vertex);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \param[in] val_vertex - Vertex of the marker <i>val_marker</i> where the coefficient is evaluated.
     * \return Value of the pressure coefficient.
     */
    virtual double GetCPressureTarget(unsigned short val_marker, unsigned short val_vertex);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \param[in] val_vertex - Vertex of the marker <i>val_marker</i> where the coefficient is evaluated.
     * \return Value of the pressure coefficient.
     */
    virtual void SetCPressureTarget(unsigned short val_marker, unsigned short val_vertex, double val_pressure);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \param[in] val_vertex - Vertex of the marker <i>val_marker</i> where the coefficient is evaluated.
     * \return Value of the pressure coefficient.
     */
    virtual double *GetCharacPrimVar(unsigned short val_marker, unsigned short val_vertex);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \param[in] val_vertex - Vertex of the marker <i>val_marker</i> where the coefficient is evaluated.
     * \return Value of the skin friction coefficient.
     */
    virtual double GetCSkinFriction(unsigned short val_marker, unsigned short val_vertex);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \param[in] val_vertex - Vertex of the marker <i>val_marker</i> where the coefficient is evaluated.
     * \return Value of the heat transfer coefficient.
     */
    virtual double GetHeatFlux(unsigned short val_marker, unsigned short val_vertex);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \param[in] val_vertex - Vertex of the marker <i>val_marker</i> where the coefficient is evaluated.
     * \return Value of the heat transfer coefficient.
     */
    virtual double GetHeatFluxTarget(unsigned short val_marker, unsigned short val_vertex);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \param[in] val_vertex - Vertex of the marker <i>val_marker</i> where the coefficient is evaluated.
     * \return Value of the pressure coefficient.
     */
    virtual void SetHeatFluxTarget(unsigned short val_marker, unsigned short val_vertex, double val_heat);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \param[in] val_vertex - Vertex of the marker <i>val_marker</i> where the coefficient is evaluated.
     * \return Value of the y plus.
     */
    virtual double GetYPlus(unsigned short val_marker, unsigned short val_vertex);
    
    /*!
     * \brief A virtual member.
     * \return Value of the StrainMag_Max
     */
    virtual double GetStrainMag_Max(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the Omega_Max
     */
    virtual double GetOmega_Max(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the StrainMag_Max
     */
    virtual void SetStrainMag_Max(double val_strainmag_max);
    
    /*!
     * \brief A virtual member.
     * \return Value of the Omega_Max
     */
    virtual void SetOmega_Max(double val_omega_max);
    
    /*!
     * \brief A virtual member.
     * \return Value of the adjoint density at the infinity.
     */
    virtual double GetPsiRho_Inf(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the adjoint density at the infinity.
     */
    virtual double* GetPsiRhos_Inf(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the adjoint energy at the infinity.
     */
    virtual double GetPsiE_Inf(void);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_dim - Index of the adjoint velocity vector.
     * \return Value of the adjoint velocity vector at the infinity.
     */
    virtual double GetPhi_Inf(unsigned short val_dim);
    
    /*!
     * \brief A virtual member.
     * \return Value of the geometrical sensitivity coefficient
     *         (inviscid + viscous contribution).
     */
    virtual double GetTotal_Sens_Geo(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the Mach sensitivity coefficient
     *         (inviscid + viscous contribution).
     */
    virtual double GetTotal_Sens_Mach(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the angle of attack sensitivity coefficient
     *         (inviscid + viscous contribution).
     */
    virtual double GetTotal_Sens_AoA(void);
    
    /*!
     * \brief Set the total farfield pressure sensitivity coefficient.
     * \return Value of the farfield pressure sensitivity coefficient
     *         (inviscid + viscous contribution).
     */
    virtual double GetTotal_Sens_Press(void);
    
    /*!
     * \brief Set the total farfield temperature sensitivity coefficient.
     * \return Value of the farfield temperature sensitivity coefficient
     *         (inviscid + viscous contribution).
     */
    virtual double GetTotal_Sens_Temp(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the density at the infinity.
     */
    virtual double GetDensity_Inf(void);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_var - Index of the variable for the density.
     * \return Value of the density at the infinity.
     */
    virtual double GetDensity_Inf(unsigned short val_var);
    
    /*!
     * \brief A virtual member.
     * \return Value of the velocity at the infinity.
     */
    virtual double GetModVelocity_Inf(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the density x energy at the infinity.
     */
    virtual double GetDensity_Energy_Inf(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the pressure at the infinity.
     */
    virtual double GetPressure_Inf(void);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_dim - Index of the adjoint velocity vector.
     * \return Value of the density x velocity at the infinity.
     */
    virtual double GetDensity_Velocity_Inf(unsigned short val_dim);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_dim - Index of the velocity vector.
     * \param[in] val_var - Index of the variable for the velocity.
     * \return Value of the density multiply by the velocity at the infinity.
     */
    virtual double GetDensity_Velocity_Inf(unsigned short val_dim, unsigned short val_var);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_dim - Index of the velocity vector.
     * \return Value of the velocity at the infinity.
     */
    virtual double GetVelocity_Inf(unsigned short val_dim);
    
    /*!
     * \brief A virtual member.
     * \return Value of the velocity at the infinity.
     */
    virtual double *GetVelocity_Inf(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the viscosity at the infinity.
     */
    virtual double GetViscosity_Inf(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the turbulent kinetic energy.
     */
    virtual double GetTke_Inf(void);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \param[in] val_vertex - Vertex of the marker <i>val_marker</i> where the coefficient is evaluated.
     * \return Value of the sensitivity coefficient.
     */
    virtual double GetCSensitivity(unsigned short val_marker, unsigned short val_vertex);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void SetFreeSurface_Distance(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief A virtual member.
     * \return A pointer to an array containing a set of constants
     */
    virtual double* GetConstants();
    
    /*!
     * \brief A virtual member.
     * \return average total pressure evaluated at an exit boundary marker
     */
    virtual double GetOneD_TotalPress(void);
    
    /*!
     * \brief A virtual member.
     * \param[in] val_exit_pt: value of the total average pressure at the exit.
     */
    virtual void SetOneD_TotalPress(double AveragePressure);
    
    /*!
     * \brief A virtual member.
     *\return average Mach number evaluated at an exit boundary marker
     */
    virtual double GetOneD_Mach(void);
    
    /*!
     * \brief A virtual member.
     * set average Mach number evaluated at an exit boundary marker
     */
    virtual void SetOneD_Mach(double AverageMach);
    
    /*!
     * \brief A virtual member.
     *\return average temperature evaluated at an exit boundary marker
     */
    virtual double GetOneD_Temp(void);
    
    /*!
     * \brief A virtual member.
     * set average temperature evaluated at an exit boundary marker
     */
    virtual void SetOneD_Temp(double AverageTemperature);
    
    /*!
     * \brief A virtual member.
     * \return average temperature evaluated at an exit boundary marker
     */
    virtual double GetOneD_MassFlowRate(void);
    
    /*!
     * \brief A virtual member.
     * set average temperature evaluated at an exit boundary marker
     */
    virtual void SetOneD_MassFlowRate(double MassFlowRate);
    
    /*!
     * \brief A virtual member.
     * \ Get the flux averaged pressure at a marker.(same as area averaged pressure)
     */
    virtual double GetOneD_FluxAvgPress(void);
    
    /*!
     * \brief A virtual member.
     * \ Set the flux averaged pressure at a marker. (same as area averaged pressure)
     */
    virtual void SetOneD_FluxAvgPress(double PressureRef);
    /*!
     * \brief A virtual member.
     * \ Get the flux averaged density at a marker. (\f$ = (gamma/(gamma-1)) / ( Pref*(href-1/2 uref^2) \f$)
     */
    virtual double GetOneD_FluxAvgDensity(void);
    
    /*!
     * \brief A virtual member.
     * \ Set the flux averaged density at a marker.( \f$= (gamma/(gamma-1)) / ( Pref*(href-1/2 uref^2) \f$)
     */
    virtual void SetOneD_FluxAvgDensity(double DensityRef);
    
    /*!
     * \brief A virtual member.
     * \ Get the flux averaged velocity at a marker. = \f$ \sqrt ( \frac{\int((rho*u)*u^2dA)}{\int(rho*u*dA) }) \f$
     */
    virtual double GetOneD_FluxAvgVelocity(void);
    
    /*!
     * \brief A virtual member.
     * \ Set the flux averaged velocity at a marker. = \f$ \sqrt (  \frac{\int((rho*u)*u^2dA)}{\int(rho*u*dA) }) \f$
     */
    virtual void SetOneD_FluxAvgVelocity(double VelocityRef);
    
    /*!
     * \brief A virtual member.
     * \ Get the flux averaged enthalpy at a marker. =\f$ \frac{ \int(rho*u*h dA) }{ \int(rho *u *dA )} \f$
     */
    virtual double GetOneD_FluxAvgEntalpy(void);
    /*!
     * \brief A virtual member.
     * \ Set the flux averaged enthalpy at a marker. =\f$ \frac{ \int(rho*u*h dA) }{ \int(rho *u *dA ) }\f$
     */
    virtual void SetOneD_FluxAvgEntalpy(double EnthalpyRef);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void GetSurface_Pressure(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief A virtual member.
     * \param[in] fea_geometry - Geometrical definition of the problem.
     * \param[in] flow_solution - Container vector with all the solutions.
     * \param[in] fea_config - Definition of the particular problem.
     */
    virtual void SetFEA_Load(CSolver ***flow_solution, CGeometry **fea_geometry,
                             CGeometry **flow_geometry, CConfig *fea_config,
                             CConfig *flow_config);
    
    /*!
     * \brief A virtual member.
     * \param[in] solver1_geometry - Geometrical definition of the problem.
     * \param[in] solver1_solution - Container vector with all the solutions.
     * \param[in] solver1_config - Definition of the particular problem.
     * \param[in] solver2_geometry - Geometrical definition of the problem.
     * \param[in] solver2_solution - Container vector with all the solutions.
     * \param[in] solver2_config - Definition of the particular problem.
     */
    virtual void Copy_Zone_Solution(CSolver ***solver1_solution,
                                    CGeometry **solver1_geometry,
                                    CConfig *solver1_config,
                                    CSolver ***solver2_solution,
                                    CGeometry **solver2_geometry,
                                    CConfig *solver2_config);
    
    /*!
     * \brief A virtual member.
     * \param[in] fea_geometry - Geometrical definition of the problem.
     * \param[in] flow_solution - Container vector with all the solutions.
     * \param[in] fea_config - Definition of the particular problem.
     */
    virtual void SetInitialCondition(CGeometry **geometry,
                                     CSolver ***solver_container,
                                     CConfig *config, unsigned long ExtIter);
    
    /*!
     * \brief A virtual member.
     * \param[in] flow_geometry - Geometrical definition of the problem.
     * \param[in] flow_grid_movement - Geometrical definition of the problem.
     * \param[in] flow_config - Geometrical definition of the problem.
     * \param[in] fea_geometry - Definition of the particular problem.
     */
    virtual void SetFlow_Displacement(CGeometry **flow_geometry,
                                      CVolumetricMovement *flow_grid_movement,
                                      CConfig *flow_config, CConfig *fea_config,
                                      CGeometry **fea_geometry,
                                      CSolver ***fea_solution);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver - Container vector with all of the solvers.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_iter - Current external iteration number.
     */
    virtual void LoadRestart(CGeometry **geometry, CSolver ***solver,
                             CConfig *config, int val_iter);
    
    /*!
     * \brief Gauss method for solving a linear system.
     * \param[in] A - Matrix Ax = b.
     * \param[in] rhs - Right hand side.
     * \param[in] nVar - Number of variables.
     */
    void Gauss_Elimination(double** A, double* rhs, unsigned short nVar);
    
    /*!
     * \brief Get the number of Species present in the flow.
     */
    virtual unsigned short GetnSpecies(void);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solution - Container vector with all the solutions.
     */
    virtual void GetEngine_Properties(CGeometry *geometry, CConfig *config, unsigned short iMesh, bool Output);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solution - Container vector with all the solutions.
     */
    virtual void GetActuatorDisk_Properties(CGeometry *geometry, CConfig *config, unsigned short iMesh, bool Output);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - current mesh level for the multigrid.
     * \param[in] Output - boolean to determine whether to print output.
     */
    virtual void SetFarfield_AoA(CGeometry *geometry, CSolver **solver_container,
                                 CConfig *config, unsigned short iMesh, bool Output);
    
    /*!
     * \brief Prepares and solves the aeroelastic equations.
     * \param[in] surface_movement - Surface movement classes of the problem.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     * \param[in] ExtIter - Physical iteration number.
     */
    void Aeroelastic(CSurfaceMovement *surface_movement, CGeometry *geometry, CConfig *config, unsigned long ExtIter);
    
    
    /*!
     * \brief Sets up the generalized eigenvectors and eigenvalues needed to solve the aeroelastic equations.
     * \param[in] PHI - Matrix of the generalized eigenvectors.
     * \param[in] lambda - The eigenvalues of the generalized eigensystem.
     * \param[in] config - Definition of the particular problem.
     */
    void SetUpTypicalSectionWingModel(double (&PHI)[2][2], double (&lambda)[2], CConfig *config);
    
    /*!
     * \brief Solve the typical section wing model.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] Cl - Coefficient of lift at particular iteration.
     * \param[in] Cm - Moment coefficient about z-axis at particular iteration.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_Marker - Surface that is being monitored.
     * \param[in] displacements - solution of typical section wing model.
     */
    void SolveTypicalSectionWingModel(CGeometry *geometry, double Cl, double Cm, CConfig *config, unsigned short val_Marker, double (&displacements)[4]);
    
};

/*!
 * \class CBaselineSolver
 * \brief Main class for defining a baseline solution from a restart file (for output).
 * \author F. Palacios, T. Economon.
 * \version 3.2.9 "eagle"
 */
class CBaselineSolver : public CSolver {
public:
    
    /*!
     * \brief Constructor of the class.
     */
    CBaselineSolver(void);
    
    /*!
     * \overload
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CBaselineSolver(CGeometry *geometry, CConfig *config, unsigned short iMesh);
    
    /*!
     * \brief Impose the send-receive boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void Set_MPI_Solution(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Load a solution from a restart file.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver - Container vector with all of the solvers.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_iter - Current external iteration number.
     */
    void LoadRestart(CGeometry **geometry, CSolver ***solver, CConfig *config, int val_iter);
    
    /*!
     * \brief Destructor of the class.
     */
    virtual ~CBaselineSolver(void);
    
};

/*!
 * \class CEulerSolver
 * \brief Main class for defining the Euler's flow solver.
 * \ingroup Euler_Equations
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CEulerSolver : public CSolver {
protected:
    
    double
    Mach_Inf,	/*!< \brief Mach number at the infinity. */
    Density_Inf,	/*!< \brief Density at the infinity. */
    Energy_Inf,			/*!< \brief Energy at the infinity. */
    Temperature_Inf,			/*!< \brief Energy at the infinity. */
    Pressure_Inf,		/*!< \brief Pressure at the infinity. */
    *Velocity_Inf;		/*!< \brief Flow Velocity vector at the infinity. */
    
    double
    *CDrag_Inv,	/*!< \brief Drag coefficient (inviscid contribution) for each boundary. */
    *CLift_Inv,			/*!< \brief Lift coefficient (inviscid contribution) for each boundary. */
    *CSideForce_Inv,		/*!< \brief Sideforce coefficient (inviscid contribution) for each boundary. */
    *CMx_Inv,			/*!< \brief x Moment coefficient (inviscid contribution) for each boundary. */
    *CMy_Inv,			/*!< \brief y Moment coefficient (inviscid contribution) for each boundary. */
    *CMz_Inv,			/*!< \brief z Moment coefficient (inviscid contribution) for each boundary. */
    *CFx_Inv,			/*!< \brief x Force coefficient (inviscid contribution) for each boundary. */
    *CFy_Inv,			/*!< \brief y Force coefficient (inviscid contribution) for each boundary. */
    *CFz_Inv,			/*!< \brief z Force coefficient (inviscid contribution) for each boundary. */
    *Surface_CLift_Inv, /*!< \brief Lift coefficient (inviscid contribution) for each monitoring surface. */
    *Surface_CDrag_Inv, /*!< \brief Drag coefficient (inviscid contribution) for each monitoring surface. */
    *Surface_CSideForce_Inv, /*!< \brief Side-force coefficient (inviscid contribution) for each monitoring surface. */
    *Surface_CEff_Inv, /*!< \brief Side-force coefficient (inviscid contribution) for each monitoring surface. */
    *Surface_CFx_Inv,   /*!< \brief x Force coefficient (inviscid contribution) for each monitoring surface. */
    *Surface_CFy_Inv,   /*!< \brief y Force coefficient (inviscid contribution) for each monitoring surface. */
    *Surface_CFz_Inv,   /*!< \brief z Force coefficient (inviscid contribution) for each monitoring surface. */
    *Surface_CMx_Inv,   /*!< \brief x Moment coefficient (inviscid contribution) for each monitoring surface. */
    *Surface_CMy_Inv,   /*!< \brief y Moment coefficient (inviscid contribution) for each monitoring surface. */
    *Surface_CMz_Inv,   /*!< \brief z Moment coefficient (inviscid contribution) for each monitoring surface. */
    *CEff_Inv,				/*!< \brief Efficiency (Cl/Cd) (inviscid contribution) for each boundary. */
    *CMerit_Inv,				/*!< \brief Rotor Figure of Merit (inviscid contribution) for each boundary. */
    *CT_Inv,			/*!< \brief Thrust coefficient (force in -x direction, inviscid contribution) for each boundary. */
    *CQ_Inv,			/*!< \brief Torque coefficient (moment in -x direction, inviscid contribution) for each boundary. */
    *CEquivArea_Inv,				/*!< \brief Equivalent area (inviscid contribution) for each boundary. */
    *CNearFieldOF_Inv,				/*!< \brief Near field pressure (inviscid contribution) for each boundary. */
    **CPressure,		/*!< \brief Pressure coefficient for each boundary and vertex. */
    **CPressureTarget,		/*!< \brief Target Pressure coefficient for each boundary and vertex. */
    **HeatFlux,		/*!< \brief Heat transfer coefficient for each boundary and vertex. */
    **HeatFluxTarget,		/*!< \brief Heat transfer coefficient for each boundary and vertex. */
    **YPlus,		/*!< \brief Yplus for each boundary and vertex. */
    ***CharacPrimVar,		/*!< \brief Value of the characteristic variables at each boundary. */
    *ForceInviscid,		/*!< \brief Inviscid force for each boundary. */
    *MomentInviscid,	/*!< \brief Inviscid moment for each boundary. */
    *Inflow_MassFlow,	/*!< \brief Mass flow rate for each boundary. */
    *Bleed_MassFlow,	/*!< \brief Mass flow rate for each boundary. */
    *Exhaust_MassFlow,	/*!< \brief Mass flow rate for each boundary. */
    *Inflow_Pressure,	/*!< \brief Fan face pressure for each boundary. */
    *Inflow_Mach,	/*!< \brief Fan face mach number for each boundary. */
    *Inflow_Area,	/*!< \brief Boundary total area. */
    *Bleed_Pressure,	/*!< \brief Fan face pressure for each boundary. */
    *Bleed_Temperature,	/*!< \brief Fan face mach number for each boundary. */
    *Bleed_Area,	/*!< \brief Boundary total area. */
    *Exhaust_Area,	/*!< \brief Boundary total area. */
    *Exhaust_Pressure,	/*!< \brief Fan face pressure for each boundary. */
    *Exhaust_Temperature,	/*!< \brief Fan face mach number for each boundary. */
    Inflow_MassFlow_Total,	/*!< \brief Mass flow rate for each boundary. */
    Bleed_MassFlow_Total,	/*!< \brief Mass flow rate for each boundary. */
    Exhaust_MassFlow_Total,	/*!< \brief Mass flow rate for each boundary. */
    Inflow_Pressure_Total,	/*!< \brief Fan face pressure for each boundary. */
    Inflow_Mach_Total,	/*!< \brief Fan face mach number for each boundary. */
    Bleed_Pressure_Total,	/*!< \brief Fan face pressure for each boundary. */
    Bleed_Temperature_Total,	/*!< \brief Fan face mach number for each boundary. */
    InverseDesign;	/*!< \brief Inverse design functional for each boundary. */
    
    double
    AllBound_CDrag_Inv,	/*!< \brief Total drag coefficient (inviscid contribution) for all the boundaries. */
    AllBound_CLift_Inv,			/*!< \brief Total lift coefficient (inviscid contribution) for all the boundaries. */
    AllBound_CSideForce_Inv,			/*!< \brief Total sideforce coefficient (inviscid contribution) for all the boundaries. */
    AllBound_CMx_Inv,			/*!< \brief Total x moment coefficient (inviscid contribution) for all the boundaries. */
    AllBound_CMy_Inv,			/*!< \brief Total y moment coefficient (inviscid contribution) for all the boundaries. */
    AllBound_CMz_Inv,			/*!< \brief Total z moment coefficient (inviscid contribution) for all the boundaries. */
    AllBound_CFx_Inv,			/*!< \brief Total x force coefficient (inviscid contribution) for all the boundaries. */
    AllBound_CFy_Inv,			/*!< \brief Total y force coefficient (inviscid contribution) for all the boundaries. */
    AllBound_CFz_Inv,			/*!< \brief Total z force coefficient (inviscid contribution) for all the boundaries. */
    AllBound_CEff_Inv,			/*!< \brief Efficient coefficient (inviscid contribution) for all the boundaries. */
    AllBound_CMerit_Inv,			/*!< \brief Rotor Figure of Merit (inviscid contribution) for all the boundaries. */
    AllBound_CT_Inv,			/*!< \brief Total thrust coefficient (inviscid contribution) for all the boundaries. */
    AllBound_CQ_Inv,			/*!< \brief Total torque coefficient (inviscid contribution) for all the boundaries. */
    AllBound_CEquivArea_Inv,			/*!< \brief equivalent area coefficient (inviscid contribution) for all the boundaries. */
    AllBound_CNearFieldOF_Inv;			/*!< \brief Near-Field press coefficient (inviscid contribution) for all the boundaries. */
    
    double
    OneD_TotalPress, /*!< \brief average total pressure evaluated at an exit */
    OneD_Mach, /*!< \brief area average Mach evaluated at an exit */
    OneD_Temp, /*!< \brief area average Temperature evaluated at an exit */
    OneD_PressureRef, /*!< \brief area average Pressure evaluated at an exit */
    OneD_MassFlowRate, /*!< \brief Mass flow rate at an exit */
    OneD_DensityRef, /*!< \brief flux average density evaluated at an exit */
    OneD_EnthalpyRef, /*!< \brief flux average enthalpy evaluated at an exit */
    OneD_VelocityRef, /*!< \brief flux average velocity evaluated at an exit */
    Total_CDrag, /*!< \brief Total drag coefficient for all the boundaries. */
    Total_CLift,		/*!< \brief Total lift coefficient for all the boundaries. */
    Total_CSideForce,		/*!< \brief Total sideforce coefficient for all the boundaries. */
    Total_CMx,			/*!< \brief Total x moment coefficient for all the boundaries. */
    Total_CMy,			/*!< \brief Total y moment coefficient for all the boundaries. */
    Total_CMz,			/*!< \brief Total z moment coefficient for all the boundaries. */
    Total_CFx,			/*!< \brief Total x force coefficient for all the boundaries. */
    Total_CFy,			/*!< \brief Total y force coefficient for all the boundaries. */
    Total_CFz,			/*!< \brief Total z force coefficient for all the boundaries. */
    Total_CEff,			/*!< \brief Total efficiency coefficient for all the boundaries. */
    Total_CMerit,			/*!< \brief Total rotor Figure of Merit for all the boundaries. */
    Total_CT,		/*!< \brief Total thrust coefficient for all the boundaries. */
    Total_CQ,		/*!< \brief Total torque coefficient for all the boundaries. */
    Total_Heat,    /*!< \brief Total heat load for all the boundaries. */
    Total_MaxHeat, /*!< \brief Maximum heat flux on all boundaries. */
    Total_CEquivArea,			/*!< \brief Total Equivalent Area coefficient for all the boundaries. */
    Total_CNearFieldOF,			/*!< \brief Total Near-Field Pressure coefficient for all the boundaries. */
    Total_CFreeSurface,			/*!< \brief Total Free Surface coefficient for all the boundaries. */
    Total_CpDiff,			/*!< \brief Total Equivalent Area coefficient for all the boundaries. */
    Total_HeatFluxDiff,			/*!< \brief Total Equivalent Area coefficient for all the boundaries. */
    Total_MassFlowRate;     /*!< \brief Total Mass Flow Rate on monitored boundaries. */
    double *Surface_CLift,   /*!< \brief Lift coefficient for each monitoring surface. */
    *Surface_CDrag,          /*!< \brief Drag coefficient for each monitoring surface. */
    *Surface_CSideForce,     /*!< \brief Side-force coefficient for each monitoring surface. */
    *Surface_CEff,     /*!< \brief Side-force coefficient for each monitoring surface. */
    *Surface_CFx,            /*!< \brief x Force coefficient for each monitoring surface. */
    *Surface_CFy,            /*!< \brief y Force coefficient for each monitoring surface. */
    *Surface_CFz,            /*!< \brief z Force coefficient for each monitoring surface. */
    *Surface_CMx,            /*!< \brief x Moment coefficient for each monitoring surface. */
    *Surface_CMy,            /*!< \brief y Moment coefficient for each monitoring surface. */
    *Surface_CMz;            /*!< \brief z Moment coefficient for each monitoring surface. */
    double *iPoint_UndLapl,	/*!< \brief Auxiliary variable for the undivided Laplacians. */
    *jPoint_UndLapl;			/*!< \brief Auxiliary variable for the undivided Laplacians. */
    double *SecondaryVar_i,	/*!< \brief Auxiliary vector for storing the solution at point i. */
    *SecondaryVar_j;			/*!< \brief Auxiliary vector for storing the solution at point j. */
    double *PrimVar_i,	/*!< \brief Auxiliary vector for storing the solution at point i. */
    *PrimVar_j;			/*!< \brief Auxiliary vector for storing the solution at point j. */
    double **LowMach_Precontioner; /*!< \brief Auxiliary vector for storing the inverse of Roe-turkel preconditioner. */
    unsigned long nMarker;				/*!< \brief Total number of markers using the grid information. */
    bool space_centered,  /*!< \brief True if space centered scheeme used. */
    euler_implicit,			/*!< \brief True if euler implicit scheme used. */
    least_squares;        /*!< \brief True if computing gradients by least squares. */
    double Gamma;									/*!< \brief Fluid's Gamma constant (ratio of specific heats). */
    double Gamma_Minus_One;				/*!< \brief Fluids's Gamma - 1.0  . */
    
    double *Primitive,		/*!< \brief Auxiliary nPrimVar vector. */
    *Primitive_i,				/*!< \brief Auxiliary nPrimVar vector for storing the primitive at point i. */
    *Primitive_j;				/*!< \brief Auxiliary nPrimVar vector for storing the primitive at point j. */
    
    double *Secondary,		/*!< \brief Auxiliary nPrimVar vector. */
    *Secondary_i,				/*!< \brief Auxiliary nPrimVar vector for storing the primitive at point i. */
    *Secondary_j;				/*!< \brief Auxiliary nPrimVar vector for storing the primitive at point j. */
    
    double Cauchy_Value,	/*!< \brief Summed value of the convergence indicator. */
    Cauchy_Func;			/*!< \brief Current value of the convergence indicator at one iteration. */
    unsigned short Cauchy_Counter;	/*!< \brief Number of elements of the Cauchy serial. */
    double *Cauchy_Serie;			/*!< \brief Complete Cauchy serial. */
    double Old_Func,	/*!< \brief Old value of the objective function (the function which is monitored). */
    New_Func;			/*!< \brief Current value of the objective function (the function which is monitored). */
    double AoA_old;  /*!< \brief Old value of the angle of attack (monitored). */
    
    CFluidModel  *FluidModel;  /*!< \brief fluid model used in the solver */
    
public:
    
    
    /*!
     * \brief Constructor of the class.
     */
    CEulerSolver(void);
    
    /*!
     * \overload
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CEulerSolver(CGeometry *geometry, CConfig *config, unsigned short iMesh);
    
    /*!
     * \brief Destructor of the class.
     */
    virtual ~CEulerSolver(void);
    
    /*!
     * \brief Impose the send-receive boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void Set_MPI_Solution(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Impose the send-receive boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void Set_MPI_Solution_Gradient(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Impose the send-receive boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void Set_MPI_Solution_Old(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Impose the send-receive boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void Set_MPI_Solution_Limiter(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Impose the send-receive boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void Set_MPI_Primitive_Limiter(CGeometry *geometry, CConfig *config);
    
    //  /*!
    //	 * \brief Impose the send-receive boundary condition.
    //	 * \param[in] geometry - Geometrical definition of the problem.
    //	 * \param[in] config - Definition of the particular problem.
    //	 */
    //  void Set_MPI_Secondary_Limiter(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Set the fluid solver nondimensionalization.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void SetNondimensionalization(CGeometry *geometry, CConfig *config, unsigned short iMesh);
    
    /*!
     * \brief Compute the pressure at the infinity.
     * \return Value of the pressure at the infinity.
     */
    CFluidModel* GetFluidModel(void);
    
    
    /*!
     * \brief Compute the density at the infinity.
     * \return Value of the density at the infinity.
     */
    double GetDensity_Inf(void);
    
    /*!
     * \brief Compute 2-norm of the velocity at the infinity.
     * \return Value of the 2-norm of the velocity at the infinity.
     */
    double GetModVelocity_Inf(void);
    
    /*!
     * \brief Compute the density multiply by energy at the infinity.
     * \return Value of the density multiply by  energy at the infinity.
     */
    double GetDensity_Energy_Inf(void);
    
    /*!
     * \brief Compute the pressure at the infinity.
     * \return Value of the pressure at the infinity.
     */
    double GetPressure_Inf(void);
    
    /*!
     * \brief Compute the density multiply by velocity at the infinity.
     * \param[in] val_dim - Index of the velocity vector.
     * \return Value of the density multiply by the velocity at the infinity.
     */
    double GetDensity_Velocity_Inf(unsigned short val_dim);
    
    /*!
     * \brief Get the velocity at the infinity.
     * \param[in] val_dim - Index of the velocity vector.
     * \return Value of the velocity at the infinity.
     */
    double GetVelocity_Inf(unsigned short val_dim);
    
    /*!
     * \brief Get the velocity at the infinity.
     * \return Value of the velocity at the infinity.
     */
    double *GetVelocity_Inf(void);
    
    /*!
     * \brief Compute the time step for solving the Euler equations.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     * \param[in] Iteration - Value of the current iteration.
     */
    void SetTime_Step(CGeometry *geometry, CSolver **solver_container, CConfig *config,
                      unsigned short iMesh, unsigned long Iteration);
    
    /*!
     * \brief Compute the spatial integration using a centered scheme.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     * \param[in] iRKStep - Current step of the Runge-Kutta iteration.
     */
    void Centered_Residual(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics,
                           CConfig *config, unsigned short iMesh, unsigned short iRKStep);
    
    /*!
     * \brief Compute the spatial integration using a upwind scheme.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     */
    void Upwind_Residual(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics,
                         CConfig *config, unsigned short iMesh);
    
    /*!
     * \brief Compute the extrapolated quantities, for MUSCL upwind 2nd reconstruction,
     * in a more thermodynamic consistent way
     * \param[in] config - Definition of the particular problem.
     */
    void ComputeConsExtrapolation(CConfig *config);
    /*!
     * \brief Source term integration.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     */
    void Source_Residual(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics, CNumerics *second_numerics,
                         CConfig *config, unsigned short iMesh);
    
    /*!
     * \brief Source term integration.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     */
    void Source_Template(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics,
                         CConfig *config, unsigned short iMesh);
    
    /*!
     * \brief Compute the velocity^2, SoundSpeed, Pressure, Enthalpy, Viscosity.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iRKStep - Current step of the Runge-Kutta iteration.
     * \param[in] RunTime_EqSystem - System of equations which is going to be solved.
     */
    void Preprocessing(CGeometry *geometry, CSolver **solver_container, CConfig *config, unsigned short iMesh, unsigned short iRKStep, unsigned short RunTime_EqSystem, bool Output);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     */
    void Postprocessing(CGeometry *geometry, CSolver **solver_container, CConfig *config, unsigned short iMesh);
    
    /*!
     * \brief Compute a pressure sensor switch.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     */
    void SetDissipation_Switch(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Parallelization of SetDissipation_Switch.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     */
    void Set_MPI_Dissipation_Switch(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Compute the gradient of the primitive variables using Green-Gauss method,
     *        and stores the result in the <i>Gradient_Primitive</i> variable.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void SetPrimitive_Gradient_GG(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Compute the gradient of the primitive variables using a Least-Squares method,
     *        and stores the result in the <i>Gradient_Primitive</i> variable.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void SetPrimitive_Gradient_LS(CGeometry *geometry, CConfig *config);
    
    //  /*!
    //	 * \brief Compute the gradient of the primitive variables using Green-Gauss method,
    //	 *        and stores the result in the <i>Gradient_Primitive</i> variable.
    //	 * \param[in] geometry - Geometrical definition of the problem.
    //	 * \param[in] config - Definition of the particular problem.
    //	 */
    //	void SetSecondary_Gradient_GG(CGeometry *geometry, CConfig *config);
    
    //	/*!
    //	 * \brief Compute the gradient of the primitive variables using a Least-Squares method,
    //	 *        and stores the result in the <i>Gradient_Primitive</i> variable.
    //	 * \param[in] geometry - Geometrical definition of the problem.
    //	 * \param[in] config - Definition of the particular problem.
    //	 */
    //	void SetSecondary_Gradient_LS(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Compute the gradient of the primitive variables using a Least-Squares method,
     *        and stores the result in the <i>Gradient_Primitive</i> variable.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void Set_MPI_Primitive_Gradient(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Compute the limiter of the primitive variables.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void SetPrimitive_Limiter(CGeometry *geometry, CConfig *config);
    
    //  /*!
    //	 * \brief Compute the gradient of the primitive variables using a Least-Squares method,
    //	 *        and stores the result in the <i>Gradient_Primitive</i> variable.
    //	 * \param[in] geometry - Geometrical definition of the problem.
    //	 * \param[in] config - Definition of the particular problem.
    //	 */
    //	void Set_MPI_Secondary_Gradient(CGeometry *geometry, CConfig *config);
    
    //	/*!
    //	 * \brief Compute the limiter of the primitive variables.
    //	 * \param[in] geometry - Geometrical definition of the problem.
    //	 * \param[in] config - Definition of the particular problem.
    //	 */
    //	void SetSecondary_Limiter(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Compute the preconditioner for convergence acceleration by Roe-Turkel method.
     * \param[in] iPoint - Index of the grid point
     * \param[in] config - Definition of the particular problem.
     */
    void SetPreconditioner(CConfig *config, unsigned short iPoint);
    
    /*!
     * \brief Compute the undivided laplacian for the solution, except the energy equation.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void SetUndivided_Laplacian(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Parallelization of Undivided Laplacian.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void Set_MPI_Undivided_Laplacian(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Compute the max eigenvalue.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void SetMax_Eigenvalue(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Parallelization of the Max eigenvalue.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void Set_MPI_MaxEigenvalue(CGeometry *geometry, CConfig *config);
    
    /*!
     * \author: G.Gori, S.Vitale, M.Pini, A.Guardone, P.Colonna
     *
     * \brief Impose via the residual the Euler wall boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Euler_Wall(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics, CConfig *config,
                       unsigned short val_marker);
    
    /*!
     * \brief Impose the far-field boundary condition using characteristics.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Far_Field(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics,
                      CConfig *config, unsigned short val_marker);
    
    /*!
     * \brief Impose the symmetry boundary condition using the residual.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Sym_Plane(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics, CConfig *config, unsigned short val_marker);
    
    /*!
     * \brief Impose the interface boundary condition using the residual.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Interface_Boundary(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics,
                               CConfig *config);
    
    /*!
     * \brief Impose the near-field boundary condition using the residual.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_NearField_Boundary(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics,
                               CConfig *config);
    
    /*!
     * \brief Impose the actuator disk boundary condition using the residual.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_ActDisk_Boundary(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics,
                             CConfig *config);
    
    /*!
     * \brief Impose the dirichlet boundary condition using the residual.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Dirichlet(CGeometry *geometry, CSolver **solver_container, CConfig *config,
                      unsigned short val_marker);
    
    /*!
     * \author: G.Gori, S.Vitale, M.Pini, A.Guardone, P.Colonna
     *
     * \brief Impose the boundary condition using characteristic recostruction.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Riemann(CGeometry *geometry, CSolver **solver_container,
                    CNumerics *conv_numerics, CNumerics *visc_numerics, CConfig *config, unsigned short val_marker);
    
    /*!
     * \brief Impose a subsonic inlet boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Inlet(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics,
                  CConfig *config, unsigned short val_marker);
    
    /*!
     * \brief Impose a supersonic inlet boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Supersonic_Inlet(CGeometry *geometry, CSolver **solver_container,
                             CNumerics *conv_numerics, CNumerics *visc_numerics, CConfig *config, unsigned short val_marker);
    
    /*!
     * \brief Impose a supersonic outlet boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Supersonic_Outlet(CGeometry *geometry, CSolver **solver_container,
                              CNumerics *conv_numerics, CNumerics *visc_numerics, CConfig *config, unsigned short val_marker);
    
    /*!
     * \brief Impose the dirichlet boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Custom(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics,
                   CConfig *config, unsigned short val_marker);
    
    /*!
     * \brief Impose the outlet boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     
     */
    void BC_Outlet(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics,
                   CConfig *config, unsigned short val_marker);
    
    /*!
     * \brief Impose the nacelle inflow boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Engine_Inflow(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics,
                          CConfig *config, unsigned short val_marker);
    
    /*!
     * \brief Impose the nacelle bleed boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Engine_Bleed(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics,
                         CConfig *config, unsigned short val_marker);
    
    /*!
     * \brief Impose the ancelle exhaust boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Engine_Exhaust(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics,
                           CConfig *config, unsigned short val_marker);
    
    /*!
     * \brief Update the solution using a Runge-Kutta scheme.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iRKStep - Current step of the Runge-Kutta iteration.
     */
    void ExplicitRK_Iteration(CGeometry *geometry, CSolver **solver_container, CConfig *config,
                              unsigned short iRKStep);
    
    /*!
     * \brief Compute the Fan face Mach number.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solution - Container vector with all the solutions.
     */
    void GetEngine_Properties(CGeometry *geometry, CConfig *config, unsigned short iMesh, bool Output);
    
    /*!
     * \brief Compute the Fan face Mach number.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solution - Container vector with all the solutions.
     */
    void GetActuatorDisk_Properties(CGeometry *geometry, CConfig *config, unsigned short iMesh, bool Output);
    
    /*!
     * \brief Update the AoA and freestream velocity at the farfield.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - current mesh level for the multigrid.
     * \param[in] Output - boolean to determine whether to print output.
     */
    void SetFarfield_AoA(CGeometry *geometry, CSolver **solver_container,
                         CConfig *config, unsigned short iMesh, bool Output);
    
    /*!
     * \brief Update the solution using the explicit Euler scheme.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     */
    void ExplicitEuler_Iteration(CGeometry *geometry, CSolver **solver_container, CConfig *config);
    
    /*!
     * \brief Update the solution using an implicit Euler scheme.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     */
    void ImplicitEuler_Iteration(CGeometry *geometry, CSolver **solver_container, CConfig *config);
    
    /*!
     * \brief Compute the pressure forces and all the adimensional coefficients.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void Inviscid_Forces(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Provide the non dimensional lift coefficient (inviscid contribution).
     * \param val_marker Surface where the coefficient is going to be computed.
     * \return Value of the lift coefficient (inviscid contribution) on the surface <i>val_marker</i>.
     */
    double GetCLift_Inv(unsigned short val_marker);
    
    /*!
     * \brief Provide the non dimensional z moment coefficient (inviscid contribution).
     * \param val_marker Surface where the coefficient is going to be computed.
     * \return Value of the z moment coefficient (inviscid contribution) on the surface <i>val_marker</i>.
     */
    double GetCMz_Inv(unsigned short val_marker);
    
    /*!
     * \brief Provide the non dimensional lift coefficient.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \return Value of the lift coefficient on the surface <i>val_marker</i>.
     */
    double GetSurface_CLift(unsigned short val_marker);
    
    /*!
     * \brief Provide the non dimensional drag coefficient.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \return Value of the drag coefficient on the surface <i>val_marker</i>.
     */
    double GetSurface_CDrag(unsigned short val_marker);
    
    /*!
     * \brief Provide the non dimensional side-force coefficient.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \return Value of the side-force coefficient on the surface <i>val_marker</i>.
     */
    double GetSurface_CSideForce(unsigned short val_marker);
    
    /*!
     * \brief Provide the non dimensional side-force coefficient.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \return Value of the side-force coefficient on the surface <i>val_marker</i>.
     */
    double GetSurface_CEff(unsigned short val_marker);
    
    /*!
     * \brief Provide the non dimensional x force coefficient.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \return Value of the x force coefficient on the surface <i>val_marker</i>.
     */
    double GetSurface_CFx(unsigned short val_marker);
    
    /*!
     * \brief Provide the non dimensional y force coefficient.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \return Value of the y force coefficient on the surface <i>val_marker</i>.
     */
    double GetSurface_CFy(unsigned short val_marker);
    
    /*!
     * \brief Provide the non dimensional z force coefficient.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \return Value of the z force coefficient on the surface <i>val_marker</i>.
     */
    double GetSurface_CFz(unsigned short val_marker);
    
    /*!
     * \brief Provide the non dimensional x moment coefficient.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \return Value of the x moment coefficient on the surface <i>val_marker</i>.
     */
    double GetSurface_CMx(unsigned short val_marker);
    
    /*!
     * \brief Provide the non dimensional y moment coefficient.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \return Value of the y moment coefficient on the surface <i>val_marker</i>.
     */
    double GetSurface_CMy(unsigned short val_marker);
    
    /*!
     * \brief Provide the non dimensional z moment coefficient.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \return Value of the z moment coefficient on the surface <i>val_marker</i>.
     */
    double GetSurface_CMz(unsigned short val_marker);
    
    /*!
     * \brief Provide the non dimensional lift coefficient.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \return Value of the lift coefficient on the surface <i>val_marker</i>.
     */
    double GetSurface_CLift_Inv(unsigned short val_marker);
    
    /*!
     * \brief Provide the non dimensional drag coefficient.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \return Value of the drag coefficient on the surface <i>val_marker</i>.
     */
    double GetSurface_CDrag_Inv(unsigned short val_marker);
    
    /*!
     * \brief Provide the non dimensional side-force coefficient.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \return Value of the side-force coefficient on the surface <i>val_marker</i>.
     */
    double GetSurface_CSideForce_Inv(unsigned short val_marker);
    
    /*!
     * \brief Provide the non dimensional side-force coefficient.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \return Value of the side-force coefficient on the surface <i>val_marker</i>.
     */
    double GetSurface_CEff_Inv(unsigned short val_marker);
    
    /*!
     * \brief Provide the non dimensional x force coefficient.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \return Value of the x force coefficient on the surface <i>val_marker</i>.
     */
    double GetSurface_CFx_Inv(unsigned short val_marker);
    
    /*!
     * \brief Provide the non dimensional y force coefficient.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \return Value of the y force coefficient on the surface <i>val_marker</i>.
     */
    double GetSurface_CFy_Inv(unsigned short val_marker);
    
    /*!
     * \brief Provide the non dimensional z force coefficient.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \return Value of the z force coefficient on the surface <i>val_marker</i>.
     */
    double GetSurface_CFz_Inv(unsigned short val_marker);
    
    /*!
     * \brief Provide the non dimensional x moment coefficient.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \return Value of the x moment coefficient on the surface <i>val_marker</i>.
     */
    double GetSurface_CMx_Inv(unsigned short val_marker);
    
    /*!
     * \brief Provide the non dimensional y moment coefficient.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \return Value of the y moment coefficient on the surface <i>val_marker</i>.
     */
    double GetSurface_CMy_Inv(unsigned short val_marker);
    
    /*!
     * \brief Provide the non dimensional z moment coefficient.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \return Value of the z moment coefficient on the surface <i>val_marker</i>.
     */
    double GetSurface_CMz_Inv(unsigned short val_marker);
    
    /*!
     * \brief Provide the non dimensional drag coefficient (inviscid contribution).
     * \param val_marker Surface where the coeficient is going to be computed.
     * \return Value of the drag coefficient (inviscid contribution) on the surface <i>val_marker</i>.
     */
    double GetCDrag_Inv(unsigned short val_marker);
    
    /*!
     * \brief Provide the mass flow rate.
     * \param val_marker Surface where the coeficient is going to be computed.
     * \return Value of the mass flow rate on the surface <i>val_marker</i>.
     */
    double GetInflow_MassFlow(unsigned short val_marker);
    
    /*!
     * \brief Provide the mass flow rate.
     * \param val_marker Surface where the coeficient is going to be computed.
     * \return Value of the mass flow rate on the surface <i>val_marker</i>.
     */
    double GetExhaust_MassFlow(unsigned short val_marker);
    
    /*!
     * \brief Provide the mass flow rate.
     * \param val_marker Surface where the coeficient is going to be computed.
     * \return Value of the fan face pressure on the surface <i>val_marker</i>.
     */
    double GetInflow_Pressure(unsigned short val_marker);
    
    /*!
     * \brief Provide the mass flow rate.
     * \param val_marker Surface where the coeficient is going to be computed.
     * \return Value of the fan face mach on the surface <i>val_marker</i>.
     */
    double GetInflow_Mach(unsigned short val_marker);
    
    /*!
     * \brief Provide the non dimensional sideforce coefficient (inviscid contribution).
     * \param val_marker Surface where the coeficient is going to be computed.
     * \return Value of the sideforce coefficient (inviscid contribution) on the surface <i>val_marker</i>.
     */
    double GetCSideForce_Inv(unsigned short val_marker);
    
    /*!
     * \brief Provide the non dimensional efficiency coefficient (inviscid contribution).
     * \param val_marker Surface where the coeficient is going to be computed.
     * \return Value of the efficiency coefficient (inviscid contribution) on the surface <i>val_marker</i>.
     */
    double GetCEff_Inv(unsigned short val_marker);
    
    /*!
     * \brief Provide the total (inviscid + viscous) non dimensional sideforce coefficient.
     * \return Value of the sideforce coefficient (inviscid + viscous contribution).
     */
    double GetTotal_CSideForce(void);
    
    /*!
     * \brief Provide the total (inviscid + viscous) non dimensional efficiency coefficient.
     * \return Value of the efficiency coefficient (inviscid + viscous contribution).
     */
    double GetTotal_CEff(void);
    
    /*!
     * \brief Provide the total (inviscid + viscous) non dimensional Equivalent Area coefficient.
     * \return Value of the Equivalent Area coefficient (inviscid + viscous contribution).
     */
    double GetTotal_CEquivArea(void);
    
    /*!
     * \brief Provide the total (inviscid + viscous) non dimensional Equivalent Area coefficient.
     * \return Value of the Equivalent Area coefficient (inviscid + viscous contribution).
     */
    double GetTotal_CpDiff(void);
    
    /*!
     * \brief Provide the total (inviscid + viscous) non dimensional Equivalent Area coefficient.
     * \return Value of the Equivalent Area coefficient (inviscid + viscous contribution).
     */
    double GetTotal_HeatFluxDiff(void);
    
    /*!
     * \brief Provide the total (inviscid + viscous) non dimensional Near-Field pressure coefficient.
     * \return Value of the NearField pressure coefficient (inviscid + viscous contribution).
     */
    double GetTotal_CNearFieldOF(void);
    
    /*!
     * \brief Set the value of the Equivalent Area coefficient.
     * \param[in] val_cequivarea - Value of the Equivalent Area coefficient.
     */
    void SetTotal_CEquivArea(double val_cequivarea);
    
    /*!
     * \brief Set the value of the Equivalent Area coefficient.
     * \param[in] val_cequivarea - Value of the Equivalent Area coefficient.
     */
    void SetTotal_CpDiff(double val_pressure);
    
    /*!
     * \brief Set the value of the Equivalent Area coefficient.
     * \param[in] val_cequivarea - Value of the Equivalent Area coefficient.
     */
    void SetTotal_HeatFluxDiff(double val_heat);
    
    /*!
     * \brief Set the value of the Near-Field pressure oefficient.
     * \param[in] val_cnearfieldpress - Value of the Near-Field pressure coefficient.
     */
    void SetTotal_CNearFieldOF(double val_cnearfieldpress);
    
    /*!
     * \brief Store the total (inviscid + viscous) non dimensional lift coefficient.
     * \param[in] val_Total_CLift - Value of the total lift coefficient.
     */
    void SetTotal_CLift(double val_Total_CLift);
    
    /*!
     * \brief Provide the total (inviscid + viscous) non dimensional lift coefficient.
     * \return Value of the lift coefficient (inviscid + viscous contribution).
     */
    double GetTotal_CLift(void);
    
    /*!
     * \brief Provide the total (inviscid + viscous) non dimensional drag coefficient.
     * \return Value of the drag coefficient (inviscid + viscous contribution).
     */
    double GetTotal_CDrag(void);
    
    /*!
     * \brief Provide the total (inviscid + viscous) non dimensional x moment coefficient.
     * \return Value of the moment x coefficient (inviscid + viscous contribution).
     */
    double GetTotal_CMx(void);
    
    /*!
     * \brief Provide the total (inviscid + viscous) non dimensional y moment coefficient.
     * \return Value of the moment y coefficient (inviscid + viscous contribution).
     */
    double GetTotal_CMy(void);
    
    /*!
     * \brief Provide the total (inviscid + viscous) non dimensional z moment coefficient.
     * \return Value of the moment z coefficient (inviscid + viscous contribution).
     */
    double GetTotal_CMz(void);
    
    /*!
     * \brief Provide the total (inviscid + viscous) non dimensional x force coefficient.
     * \return Value of the force x coefficient (inviscid + viscous contribution).
     */
    double GetTotal_CFx(void);
    
    /*!
     * \brief Provide the total (inviscid + viscous) non dimensional y force coefficient.
     * \return Value of the force y coefficient (inviscid + viscous contribution).
     */
    double GetTotal_CFy(void);
    
    /*!
     * \brief Provide the total (inviscid + viscous) non dimensional z force coefficient.
     * \return Value of the force z coefficient (inviscid + viscous contribution).
     */
    double GetTotal_CFz(void);
    
    /*!
     * \brief Provide the total (inviscid + viscous) non dimensional thrust coefficient.
     * \return Value of the rotor efficiency coefficient (inviscid + viscous contribution).
     */
    double GetTotal_CT(void);
    
    /*!
     * \brief Store the total (inviscid + viscous) non dimensional thrust coefficient.
     * \param[in] val_Total_CT - Value of the total thrust coefficient.
     */
    void SetTotal_CT(double val_Total_CT);
    
    /*!
     * \brief Provide the total (inviscid + viscous) non dimensional torque coefficient.
     * \return Value of the rotor efficiency coefficient (inviscid + viscous contribution).
     */
    double GetTotal_CQ(void);
    
    /*!
     * \brief Provide the total heat load.
     * \return Value of the heat load (viscous contribution).
     */
    double GetTotal_HeatFlux(void);
    
    /*!
     * \brief Provide the total heat load.
     * \return Value of the heat load (viscous contribution).
     */
    double GetTotal_MaxHeatFlux(void);
    
    /*!
     * \brief Store the total (inviscid + viscous) non dimensional torque coefficient.
     * \param[in] val_Total_CQ - Value of the total torque coefficient.
     */
    void SetTotal_CQ(double val_Total_CQ);
    
    /*!
     * \brief Store the total heat load.
     * \param[in] val_Total_Heat - Value of the heat load.
     */
    void SetTotal_HeatFlux(double val_Total_Heat);
    
    /*!
     * \brief Store the total heat load.
     * \param[in] val_Total_Heat - Value of the heat load.
     */
    void SetTotal_MaxHeatFlux(double val_Total_MaxHeat);
    
    /*!
     * \brief Provide the total (inviscid + viscous) non dimensional rotor Figure of Merit.
     * \return Value of the rotor efficiency coefficient (inviscid + viscous contribution).
     */
    double GetTotal_CMerit(void);
    
    /*!
     * \brief Store the total (inviscid + viscous) non dimensional drag coefficient.
     * \param[in] val_Total_CDrag - Value of the total drag coefficient.
     */
    void SetTotal_CDrag(double val_Total_CDrag);
    
    /*!
     * \brief Get the inviscid contribution to the lift coefficient.
     * \return Value of the lift coefficient (inviscid contribution).
     */
    double GetAllBound_CLift_Inv(void);
    
    /*!
     * \brief Get the inviscid contribution to the drag coefficient.
     * \return Value of the drag coefficient (inviscid contribution).
     */
    double GetAllBound_CDrag_Inv(void);
    
    /*!
     * \brief Get the inviscid contribution to the sideforce coefficient.
     * \return Value of the sideforce coefficient (inviscid contribution).
     */
    double GetAllBound_CSideForce_Inv(void);
    
    /*!
     * \brief Get the inviscid contribution to the efficiency coefficient.
     * \return Value of the efficiency coefficient (inviscid contribution).
     */
    double GetAllBound_CEff_Inv(void);
    
    /*!
     * \brief Get the inviscid contribution to the efficiency coefficient.
     * \return Value of the efficiency coefficient (inviscid contribution).
     */
    double GetAllBound_CMx_Inv(void);
    
    /*!
     * \brief Get the inviscid contribution to the efficiency coefficient.
     * \return Value of the efficiency coefficient (inviscid contribution).
     */
    double GetAllBound_CMy_Inv(void);
    
    /*!
     * \brief Get the inviscid contribution to the efficiency coefficient.
     * \return Value of the efficiency coefficient (inviscid contribution).
     */
    double GetAllBound_CMz_Inv(void);
    
    /*!
     * \brief Get the inviscid contribution to the efficiency coefficient.
     * \return Value of the efficiency coefficient (inviscid contribution).
     */
    double GetAllBound_CFx_Inv(void);
    
    /*!
     * \brief Get the inviscid contribution to the efficiency coefficient.
     * \return Value of the efficiency coefficient (inviscid contribution).
     */
    double GetAllBound_CFy_Inv(void);
    
    /*!
     * \brief Get the inviscid contribution to the efficiency coefficient.
     * \return Value of the efficiency coefficient (inviscid contribution).
     */
    double GetAllBound_CFz_Inv(void);
    
    /*!
     * \brief Provide the Pressure coefficient.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \param[in] val_vertex - Vertex of the marker <i>val_marker</i> where the coefficient is evaluated.
     * \return Value of the pressure coefficient.
     */
    double GetCPressure(unsigned short val_marker, unsigned short val_vertex);
    
    /*!
     * \brief Provide the Target Pressure coefficient.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \param[in] val_vertex - Vertex of the marker <i>val_marker</i> where the coefficient is evaluated.
     * \return Value of the pressure coefficient.
     */
    double GetCPressureTarget(unsigned short val_marker, unsigned short val_vertex);
    
    /*!
     * \brief Set the value of the target Pressure coefficient.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \param[in] val_vertex - Vertex of the marker <i>val_marker</i> where the coefficient is evaluated.
     * \return Value of the pressure coefficient.
     */
    void SetCPressureTarget(unsigned short val_marker, unsigned short val_vertex, double val_pressure);
    
    /*!
     * \brief Value of the characteristic variables at the boundaries.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \param[in] val_vertex - Vertex of the marker <i>val_marker</i> where the coefficient is evaluated.
     * \return Value of the pressure coefficient.
     */
    double *GetCharacPrimVar(unsigned short val_marker, unsigned short val_vertex);
    
    /*!
     * \brief Provide the total (inviscid + viscous) non dimensional Free Surface coefficient.
     * \return Value of the Free Surface coefficient (inviscid + viscous contribution).
     */
    double GetTotal_CFreeSurface(void);
    
    /*!
     * \brief Set the value of the Free Surface coefficient.
     * \param[in] val_cfreesurface - Value of the Free Surface coefficient.
     */
    void SetTotal_CFreeSurface(double val_cfreesurface);
    
    /*!
     * \brief Provide the averaged total pressure at a marker.
     */
    double GetOneD_TotalPress(void);
    
    /*!
     * \brief Set the value of averaged total pressure
     * \param[in] val_exit_pt - value of the averaged pressure
     */
    void SetOneD_TotalPress(double AveragePressure);
    
    /*!
     * \brief Provide the averaged Mach number at a marker.
     */
    double GetOneD_Mach(void);
    
    /*!
     * \brief Set the averaged Mach number at a marker.
     */
    void SetOneD_Mach(double AverageMach);
    
    /*!
     * \brief Provide the averaged Mach number at a marker.
     */
    double GetOneD_Temp(void);
    
    /*!
     * \brief Set the averaged Temperature at a marker.
     */
    void SetOneD_Temp(double AverageTemperature);
    
    /*!
     * \brief Provide the averaged Mach number at a marker.
     */
    double GetOneD_MassFlowRate(void);
    
    /*!
     * \brief Set the averaged Temperature at a marker.
     */
    void SetOneD_MassFlowRate(double MassFlowRate);
    
    /*!
     * \brief Get the flux averaged pressure at a marker.(same as area averaged pressure)
     */
    double GetOneD_FluxAvgPress(void);
    
    /*!
     * \brief Set the flux averaged pressure at a marker. (same as area averaged pressure)
     */
    void SetOneD_FluxAvgPress(double PressureRef);
    
    /*!
     * \brief Get the flux averaged density at a marker. ( = (gamma/(gamma-1)) / ( Pref*(href-1/2 uref^2) )
     */
    double GetOneD_FluxAvgDensity(void);
    
    /*!
     * \brief Set the flux averaged density at a marker.( = (gamma/(gamma-1)) / ( Pref*(href-1/2 uref^2) )
     */
    void SetOneD_FluxAvgDensity(double DensityRef);
    
    /*!
     * \brief Get the flux averaged velocity at a marker. = \f$ \sqrt ( \int((rho*u)*u^2dA)/\int(rho*u*dA) )\f$
     */
    double GetOneD_FluxAvgVelocity(void);
    
    /*!
     * \brief Set the flux averaged velocity at a marker. =\f$ sqrt ( \int((rho*u)*u^2dA)/\int(rho*u*dA) ) \f$
     */
    void SetOneD_FluxAvgVelocity(double VelocityRef);
    
    /*!
     * \brief Get the flux averaged enthalpy at a marker. = \f$ \int(rho*u*h dA) / \int(rho *u *dA ) \f$
     */
    double GetOneD_FluxAvgEntalpy(void);
    
    /*!
     * \brief Set the flux averaged enthalpy at a marker. =\f$ \int(rho*u*h dA) / \int(rho *u *dA ) \f$
     */
    void SetOneD_FluxAvgEntalpy(double EnthalpyRef);
    
    /*!
     * \brief Set the total residual adding the term that comes from the Dual Time Strategy.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iRKStep - Current step of the Runge-Kutta iteration.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     * \param[in] RunTime_EqSystem - System of equations which is going to be solved.
     */
    void SetResidual_DualTime(CGeometry *geometry, CSolver **solver_container, CConfig *config,
                              unsigned short iRKStep, unsigned short iMesh, unsigned short RunTime_EqSystem);
    
    /*!
     * \brief A virtual member.
     * \param[in] flow_geometry - Geometrical definition of the problem.
     * \param[in] flow_grid_movement - Geometrical definition of the problem.
     * \param[in] flow_config - Geometrical definition of the problem.
     * \param[in] fea_geometry - Definition of the particular problem.
     */
    void SetFlow_Displacement(CGeometry **flow_geometry, CVolumetricMovement *flow_grid_movement, CConfig *flow_config, CConfig *fea_config,
                              CGeometry **fea_geometry, CSolver ***fea_solution);
    
    /*!
     * \brief Load a solution from a restart file.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver - Container vector with all of the solvers.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_iter - Current external iteration number.
     */
    void LoadRestart(CGeometry **geometry, CSolver ***solver, CConfig *config, int val_iter);
    
    /*!
     * \brief Set the initial condition for the Euler Equations.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] ExtIter - External iteration.
     */
    void SetInitialCondition(CGeometry **geometry, CSolver ***solver_container, CConfig *config, unsigned long ExtIter);
    
    /*!
     * \brief Recompute distance to the level set 0.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void SetFreeSurface_Distance(CGeometry *geometry, CConfig *config);
    
};

/*!
 * \class CNSSolver
 * \brief Main class for defining the Navier-Stokes flow solver.
 * \ingroup Navier_Stokes_Equations
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CNSSolver : public CEulerSolver {
private:
    double Viscosity_Inf;	/*!< \brief Viscosity at the infinity. */
    double Tke_Inf;	/*!< \brief Turbulent kinetic energy at the infinity. */
    double Prandtl_Lam,   /*!< \brief Laminar Prandtl number. */
    Prandtl_Turb;         /*!< \brief Turbulent Prandtl number. */
    double *CDrag_Visc,	/*!< \brief Drag coefficient (viscous contribution) for each boundary. */
    *CLift_Visc,		/*!< \brief Lift coefficient (viscous contribution) for each boundary. */
    *CSideForce_Visc,		/*!< \brief Side force coefficient (viscous contribution) for each boundary. */
    *CMx_Visc,			/*!< \brief Moment x coefficient (viscous contribution) for each boundary. */
    *CMy_Visc,			/*!< \brief Moment y coefficient (viscous contribution) for each boundary. */
    *CMz_Visc,			/*!< \brief Moment z coefficient (viscous contribution) for each boundary. */
    *CFx_Visc,			/*!< \brief Force x coefficient (viscous contribution) for each boundary. */
    *CFy_Visc,			/*!< \brief Force y coefficient (viscous contribution) for each boundary. */
    *CFz_Visc,			/*!< \brief Force z coefficient (viscous contribution) for each boundary. */
    *Surface_CLift_Visc,/*!< \brief Lift coefficient (viscous contribution) for each monitoring surface. */
    *Surface_CDrag_Visc,/*!< \brief Drag coefficient (viscous contribution) for each monitoring surface. */
    *Surface_CSideForce_Visc,/*!< \brief Side-force coefficient (viscous contribution) for each monitoring surface. */
    *Surface_CEff_Visc,/*!< \brief Side-force coefficient (viscous contribution) for each monitoring surface. */
    *Surface_CFx_Visc,  /*!< \brief Force x coefficient (viscous contribution) for each monitoring surface. */
    *Surface_CFy_Visc,  /*!< \brief Force y coefficient (viscous contribution) for each monitoring surface. */
    *Surface_CFz_Visc,  /*!< \brief Force z coefficient (viscous contribution) for each monitoring surface. */
    *Surface_CMx_Visc,  /*!< \brief Moment x coefficient (viscous contribution) for each monitoring surface. */
    *Surface_CMy_Visc,  /*!< \brief Moment y coefficient (viscous contribution) for each monitoring surface. */
    *Surface_CMz_Visc,  /*!< \brief Moment z coefficient (viscous contribution) for each monitoring surface. */
    *CEff_Visc,			/*!< \brief Efficiency (Cl/Cd) (Viscous contribution) for each boundary. */
    *CMerit_Visc,			/*!< \brief Rotor Figure of Merit (Viscous contribution) for each boundary. */
    *CT_Visc,		/*!< \brief Thrust coefficient (viscous contribution) for each boundary. */
    *CQ_Visc,		/*!< \brief Torque coefficient (viscous contribution) for each boundary. */
    *Heat_Visc,		/*!< \brief Heat load (viscous contribution) for each boundary. */
    *MaxHeatFlux_Visc, /*!< \brief Maximum heat flux (viscous contribution) for each boundary. */
    **CSkinFriction;	/*!< \brief Skin friction coefficient for each boundary and vertex. */
    double *ForceViscous,	/*!< \brief Viscous force for each boundary. */
    *MomentViscous;			/*!< \brief Inviscid moment for each boundary. */
    double AllBound_CDrag_Visc, /*!< \brief Drag coefficient (viscous contribution) for all the boundaries. */
    AllBound_CLift_Visc,		/*!< \brief Lift coefficient (viscous contribution) for all the boundaries. */
    AllBound_CSideForce_Visc,		/*!< \brief Sideforce coefficient (viscous contribution) for all the boundaries. */
    AllBound_CMx_Visc,			/*!< \brief Moment x coefficient (inviscid contribution) for all the boundaries. */
    AllBound_CMy_Visc,			/*!< \brief Moment y coefficient (inviscid contribution) for all the boundaries. */
    AllBound_CMz_Visc,			/*!< \brief Moment z coefficient (inviscid contribution) for all the boundaries. */
    AllBound_CEff_Visc,			/*!< \brief Efficient coefficient (Viscous contribution) for all the boundaries. */
    AllBound_CFx_Visc,			/*!< \brief Force x coefficient (inviscid contribution) for all the boundaries. */
    AllBound_CFy_Visc,			/*!< \brief Force y coefficient (inviscid contribution) for all the boundaries. */
    AllBound_CFz_Visc,			/*!< \brief Force z coefficient (inviscid contribution) for all the boundaries. */
    AllBound_CMerit_Visc,			/*!< \brief Rotor Figure of Merit coefficient (Viscous contribution) for all the boundaries. */
    AllBound_CT_Visc,		/*!< \brief Thrust coefficient (viscous contribution) for all the boundaries. */
    AllBound_CQ_Visc,		/*!< \brief Torque coefficient (viscous contribution) for all the boundaries. */
    AllBound_HeatFlux_Visc,		/*!< \brief Heat load (viscous contribution) for all the boundaries. */
    AllBound_MaxHeatFlux_Visc; /*!< \brief Maximum heat flux (viscous contribution) for all boundaries. */
    double StrainMag_Max, Omega_Max; /*!< \brief Maximum Strain Rate magnitude and Omega. */
    
public:
    
    /*!
     * \brief Constructor of the class.
     */
    CNSSolver(void);
    
    /*!
     * \overload
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CNSSolver(CGeometry *geometry, CConfig *config, unsigned short iMesh);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CNSSolver(void);
    
    /*!
     * \brief Compute the viscosity at the infinity.
     * \return Value of the viscosity at the infinity.
     */
    double GetViscosity_Inf(void);
    
    /*!
     * \brief Get the turbulent kinetic energy at the infinity.
     * \return Value of the turbulent kinetic energy at the infinity.
     */
    double GetTke_Inf(void);
    
    /*!
     * \brief Compute the time step for solving the Navier-Stokes equations with turbulence model.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     * \param[in] Iteration - Index of the current iteration.
     */
    void SetTime_Step(CGeometry *geometry, CSolver **solver_container, CConfig *config,
                      unsigned short iMesh, unsigned long Iteration);
    
    /*!
     * \brief Restart residual and compute gradients.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iRKStep - Current step of the Runge-Kutta iteration.
     * \param[in] RunTime_EqSystem - System of equations which is going to be solved.
     */
    void Preprocessing(CGeometry *geometry, CSolver **solver_container, CConfig *config, unsigned short iMesh, unsigned short iRKStep, unsigned short RunTime_EqSystem, bool Output);
    
    /*!
     * \brief Impose a constant heat-flux condition at the wall.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_HeatFlux_Wall(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics, CConfig *config, unsigned short val_marker);
    
    /*!
     * \brief Impose the Navier-Stokes boundary condition (strong).
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Isothermal_Wall(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics, CConfig *config,
                            unsigned short val_marker);
    
    /*!
     * \brief Compute the viscous forces and all the addimensional coefficients.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void Viscous_Forces(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Get the non dimensional lift coefficient (viscous contribution).
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \return Value of the lift coefficient (viscous contribution) on the surface <i>val_marker</i>.
     */
    double GetCLift_Visc(unsigned short val_marker);
    
    /*!
     * \brief Get the non dimensional z moment coefficient (viscous contribution).
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \return Value of the z moment coefficient (viscous contribution) on the surface <i>val_marker</i>.
     */
    double GetCMz_Visc(unsigned short val_marker);
    
    /*!
     * \brief Get the non dimensional sideforce coefficient (viscous contribution).
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \return Value of the sideforce coefficient (viscous contribution) on the surface <i>val_marker</i>.
     */
    double GetCSideForce_Visc(unsigned short val_marker);
    
    /*!
     * \brief Get the non dimensional drag coefficient (viscous contribution).
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \return Value of the drag coefficient (viscous contribution) on the surface <i>val_marker</i>.
     */
    double GetCDrag_Visc(unsigned short val_marker);
    
    /*!
     * \brief Get the total non dimensional lift coefficient (viscous contribution).
     * \return Value of the lift coefficient (viscous contribution).
     */
    double GetAllBound_CLift_Visc(void);
    
    /*!
     * \brief Get the total non dimensional sideforce coefficient (viscous contribution).
     * \return Value of the lift coefficient (viscous contribution).
     */
    double GetAllBound_CSideForce_Visc(void);
    
    /*!
     * \brief Get the total non dimensional drag coefficient (viscous contribution).
     * \return Value of the drag coefficient (viscous contribution).
     */
    double GetAllBound_CDrag_Visc(void);
    
    /*!
     * \brief Compute the viscous residuals.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     * \param[in] iRKStep - Current step of the Runge-Kutta iteration.
     */
    void Viscous_Residual(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics,
                          CConfig *config, unsigned short iMesh, unsigned short iRKStep);
    
    /*!
     * \brief Get the skin friction coefficient.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \param[in] val_vertex - Vertex of the marker <i>val_marker</i> where the coefficient is evaluated.
     * \return Value of the skin friction coefficient.
     */
    double GetCSkinFriction(unsigned short val_marker, unsigned short val_vertex);
    
    /*!
     * \brief Get the skin friction coefficient.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \param[in] val_vertex - Vertex of the marker <i>val_marker</i> where the coefficient is evaluated.
     * \return Value of the heat transfer coefficient.
     */
    double GetHeatFlux(unsigned short val_marker, unsigned short val_vertex);
    
    /*!
     * \brief Get the skin friction coefficient.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \param[in] val_vertex - Vertex of the marker <i>val_marker</i> where the coefficient is evaluated.
     * \return Value of the heat transfer coefficient.
     */
    double GetHeatFluxTarget(unsigned short val_marker, unsigned short val_vertex);
    
    /*!
     * \brief Set the value of the target Pressure coefficient.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \param[in] val_vertex - Vertex of the marker <i>val_marker</i> where the coefficient is evaluated.
     * \return Value of the pressure coefficient.
     */
    void SetHeatFluxTarget(unsigned short val_marker, unsigned short val_vertex, double val_heat);
    
    /*!
     * \brief Get the y plus.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \param[in] val_vertex - Vertex of the marker <i>val_marker</i> where the coefficient is evaluated.
     * \return Value of the y plus.
     */
    double GetYPlus(unsigned short val_marker, unsigned short val_vertex);
    
    /*!
     * \brief Get the max Omega.
     * \return Value of the max Omega.
     */
    double GetOmega_Max(void);
    
    /*!
     * \brief Get the max Strain rate magnitude.
     * \return Value of the max Strain rate magnitude.
     */
    double GetStrainMag_Max(void);
    
    /*!
     * \brief A virtual member.
     * \return Value of the StrainMag_Max
     */
    void SetStrainMag_Max(double val_strainmag_max);
    
    /*!
     * \brief A virtual member.
     * \return Value of the Omega_Max
     */
    void SetOmega_Max(double val_omega_max);
    
};

/*!
 * \class CTurbSolver
 * \brief Main class for defining the turbulence model solver.
 * \ingroup Turbulence_Model
 * \author A. Bueno.
 * \version 3.2.9 "eagle"
 */
class CTurbSolver : public CSolver {
protected:
    double *FlowPrimVar_i,  /*!< \brief Store the flow solution at point i. */
    *FlowPrimVar_j,         /*!< \brief Store the flow solution at point j. */
    *lowerlimit,            /*!< \brief contains lower limits for turbulence variables. */
    *upperlimit;            /*!< \brief contains upper limits for turbulence variables. */
    double Gamma;           /*!< \brief Fluid's Gamma constant (ratio of specific heats). */
    double Gamma_Minus_One; /*!< \brief Fluids's Gamma - 1.0  . */
    
public:
    
    /*!
     * \brief Constructor of the class.
     */
    CTurbSolver(void);
    
    /*!
     * \brief Destructor of the class.
     */
    virtual ~CTurbSolver(void);
    
    /*!
     * \brief Constructor of the class.
     */
    CTurbSolver(CConfig *config);
    
    /*!
     * \brief Impose the send-receive boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void Set_MPI_Solution(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Impose the send-receive boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void Set_MPI_Solution_Old(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Impose the send-receive boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void Set_MPI_Solution_Gradient(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Impose the send-receive boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void Set_MPI_Solution_Limiter(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Compute the spatial integration using a upwind scheme.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     */
    
    void Upwind_Residual(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics, CConfig *config,
                         unsigned short iMesh);
    
    /*!
     * \brief Compute the viscous residuals for the turbulent equation.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     * \param[in] iRKStep - Current step of the Runge-Kutta iteration.
     */
    void Viscous_Residual(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics,
                          CConfig *config, unsigned short iMesh, unsigned short iRKStep);
    
    /*!
     * \brief Impose the Symmetry Plane boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Sym_Plane(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics, CConfig *config, unsigned short val_marker);
    
    /*!
     * \brief Impose via the residual the Euler wall boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Euler_Wall(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics, CConfig *config,
                       unsigned short val_marker);
    
    /*!
     * \brief Update the solution using an implicit solver.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     */
    void ImplicitEuler_Iteration(CGeometry *geometry, CSolver **solver_container, CConfig *config);
    
    /*!
     * \brief Set the total residual adding the term that comes from the Dual Time-Stepping Strategy.
     * \param[in] geometry - Geometric definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iRKStep - Current step of the Runge-Kutta iteration.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     * \param[in] RunTime_EqSystem - System of equations which is going to be solved.
     */
    void SetResidual_DualTime(CGeometry *geometry, CSolver **solver_container, CConfig *config,
                              unsigned short iRKStep, unsigned short iMesh, unsigned short RunTime_EqSystem);
    
};

/*!
 * \class CTurbSASolver
 * \brief Main class for defining the turbulence model solver.
 * \ingroup Turbulence_Model
 * \author A. Bueno.
 * \version 3.2.9 "eagle"
 */

class CTurbSASolver: public CTurbSolver {
private:
    double nu_tilde_Inf, nu_tilde_Engine;
    
public:
    /*!
     * \brief Constructor of the class.
     */
    CTurbSASolver(void);
    
    /*!
     * \overload
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CTurbSASolver(CGeometry *geometry, CConfig *config, unsigned short iMesh, CFluidModel* FluidModel);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CTurbSASolver(void);
    
    /*!
     * \brief Restart residual and compute gradients.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iRKStep - Current step of the Runge-Kutta iteration.
     * \param[in] RunTime_EqSystem - System of equations which is going to be solved.
     */
    void Preprocessing(CGeometry *geometry, CSolver **solver_container, CConfig *config, unsigned short iMesh, unsigned short iRKStep, unsigned short RunTime_EqSystem, bool Output);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     */
    void Postprocessing(CGeometry *geometry, CSolver **solver_container, CConfig *config,
                        unsigned short iMesh);
    
    /*!
     * \brief Source term computation.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     */
    void Source_Residual(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics, CNumerics *second_numerics,
                         CConfig *config, unsigned short iMesh);
    
    /*!
     * \brief Source term computation.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     */
    void Source_Template(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics,
                         CConfig *config, unsigned short iMesh);
    
    /*!
     * \brief Impose the Navier-Stokes wall boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_HeatFlux_Wall(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics, CConfig *config,
                          unsigned short val_marker);
    
    /*!
     * \brief Impose the Navier-Stokes wall boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Isothermal_Wall(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics, CConfig *config,
                            unsigned short val_marker);
    
    /*!
     * \brief Impose the Far Field boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Far_Field(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics, CConfig *config,
                      unsigned short val_marker);
    
    /*!
     * \brief Impose the inlet boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Inlet(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics, CConfig *config,
                  unsigned short val_marker);
    
    /*!
     * \brief Impose the outlet boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    
    void BC_Outlet(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics, CConfig *config,
                   unsigned short val_marker);
    
    /*!
     * \brief Impose the engine inflow boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Engine_Inflow(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics,
                          CConfig *config, unsigned short val_marker);
    
    /*!
     * \brief Impose the engine bleed boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Engine_Bleed(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics,
                         CConfig *config, unsigned short val_marker);
    
    /*!
     * \brief Impose the engine exhaust boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Engine_Exhaust(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics,
                           CConfig *config, unsigned short val_marker);
    
    /*!
     * \brief Impose the interface boundary condition using the residual.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Interface_Boundary(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics,
                               CConfig *config);
    
    /*!
     * \brief Impose the near-field boundary condition using the residual.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_NearField_Boundary(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics,
                               CConfig *config);
    
    /*!
     * \brief Load a solution from a restart file.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver - Container vector with all of the solvers.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_iter - Current external iteration number.
     */
    void LoadRestart(CGeometry **geometry, CSolver ***solver, CConfig *config, int val_iter);
    
    
};

/*!
 * \class CTurbMLSolver
 * \brief Main class for defining the turbulence model solver.
 * \ingroup Turbulence_Model
 * \author B. Tracey.
 * \version 3.2.9 "eagle"
 */

class CTurbMLSolver: public CTurbSolver {
private:
    double nu_tilde_Inf;
    
public:
    /*!
     * \brief Constructor of the class.
     */
    CTurbMLSolver(void);
    
    /*!
     * \overload
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CTurbMLSolver(CGeometry *geometry, CConfig *config, unsigned short iMesh);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CTurbMLSolver(void);
    
    /*!
     * \brief Restart residual and compute gradients.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iRKStep - Current step of the Runge-Kutta iteration.
     * \param[in] RunTime_EqSystem - System of equations which is going to be solved.
     */
    void Preprocessing(CGeometry *geometry, CSolver **solver_container, CConfig *config, unsigned short iMesh, unsigned short iRKStep, unsigned short RunTime_EqSystem, bool Output);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     */
    void Postprocessing(CGeometry *geometry, CSolver **solver_container, CConfig *config,
                        unsigned short iMesh);
    
    /*!
     * \brief Source term computation.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     */
    void Source_Residual(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics, CNumerics *second_numerics,
                         CConfig *config, unsigned short iMesh);
    
    /*!
     * \brief Source term computation.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     */
    void Source_Template(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics,
                         CConfig *config, unsigned short iMesh);
    
    /*!
     * \brief Impose the Navier-Stokes wall boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_HeatFlux_Wall(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics, CConfig *config,
                          unsigned short val_marker);
    
    /*!
     * \brief Impose the Navier-Stokes wall boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Isothermal_Wall(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics, CConfig *config,
                            unsigned short val_marker);
    
    /*!
     * \brief Impose the Far Field boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Far_Field(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics, CConfig *config,
                      unsigned short val_marker);
    
    /*!
     * \brief Impose the inlet boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Inlet(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics, CConfig *config,
                  unsigned short val_marker);
    
    /*!
     * \brief Impose the outlet boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    
    void BC_Outlet(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics, CConfig *config,
                   unsigned short val_marker);
    
    /*!
     * \brief Load a solution from a restart file.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver - Container vector with all of the solvers.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_iter - Current external iteration number.
     */
    void LoadRestart(CGeometry **geometry, CSolver ***solver, CConfig *config, int val_iter);
    
    double SAProduction, SADestruction, SACrossProduction, SASource, MLProduction, MLDestruction, MLCrossProduction, MLSource, SourceDiff;
    
};

/*!
 * \class CTransLMSolver
 * \brief Main class for defining the turbulence model solver.
 * \ingroup Turbulence_Model
 * \author A. Aranake.
 * \version 3.2.9 "eagle"
 */

class CTransLMSolver: public CTurbSolver {
private:
    double Intermittency_Inf, REth_Inf;
public:
    /*!
     * \brief Constructor of the class.
     */
    CTransLMSolver(void);
    
    /*!
     * \overload
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CTransLMSolver(CGeometry *geometry, CConfig *config, unsigned short iMesh);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CTransLMSolver(void);
    
    /*!
     * \brief Correlation function to relate turbulence intensity to transition onset reynolds number
     * \param[in]  tu - turbulence intensity
     */
    //double REthCorrelation(double tu);
    
    /*!
     * \brief Restart residual and compute gradients.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iRKStep - Current step of the Runge-Kutta iteration.
     * \param[in] RunTime_EqSystem - System of equations which is going to be solved.
     */
    void Preprocessing(CGeometry *geometry, CSolver **solver_container, CConfig *config, unsigned short iMesh, unsigned short iRKStep, unsigned short RunTime_EqSystem, bool Output);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     */
    void Postprocessing(CGeometry *geometry, CSolver **solver_container, CConfig *config,
                        unsigned short iMesh);
    
    /*!
     * \brief Compute the spatial integration using a upwind scheme.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     */
    void Upwind_Residual(CGeometry *geometry, CSolver **solver_container,
                         CNumerics *numerics, CConfig *config, unsigned short iMesh);
    
    /*!
     * \brief Compute the viscous residuals for the turbulent equation.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     * \param[in] iRKStep - Current step of the Runge-Kutta iteration.
     */
    void Viscous_Residual(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics,
                          CConfig *config, unsigned short iMesh, unsigned short iRKStep);
    
    /*!
     * \brief Source term computation.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     */
    void Source_Residual(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics, CNumerics *second_numerics,
                         CConfig *config, unsigned short iMesh);
    
    /*!
     * \brief Source term computation.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     */
    void Source_Template(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics,
                         CConfig *config, unsigned short iMesh);
    
    /*!
     * \brief Impose the Navier-Stokes wall boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_HeatFlux_Wall(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics, CConfig *config,
                          unsigned short val_marker);
    
    /*!
     * \brief Impose the Far Field boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Far_Field(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics, CConfig *config,
                      unsigned short val_marker);
    
    /*!
     * \brief Impose the inlet boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Inlet(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics, CConfig *config,
                  unsigned short val_marker);
    
    /*!
     * \brief Impose the outlet boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    
    void BC_Outlet(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics, CConfig *config,
                   unsigned short val_marker);
    
    /*!
     * \brief Impose the symmetry condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    
    void BC_Sym_Plane(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics, CConfig *config,
                      unsigned short val_marker);
    /*!
     * \brief Update the solution using an implicit solver.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     */
    void ImplicitEuler_Iteration(CGeometry *geometry, CSolver **solver_container, CConfig *config);
    
    // Another set of matrix structures for the Lm equations
    CSysMatrix JacobianItmc; /*!< \brief Complete sparse Jacobian structure for implicit computations. */
    double *LinSysSolItmc;		/*!< \brief vector to store iterative solution of implicit linear system. */
    double *LinSysResItmc;		/*!< \brief vector to store iterative residual of implicit linear system. */
    double *rhsItmc;		/*!< \brief right hand side of implicit linear system. */
    CSysMatrix JacobianReth; /*!< \brief Complete sparse Jacobian structure for implicit computations. */
    double *LinSysSolReth;		/*!< \brief vector to store iterative solution of implicit linear system. */
    double *LinSysResReth;		/*!< \brief vector to store iterative residual of implicit linear system. */
    double *rhsReth;		/*!< \brief right hand side of implicit linear system. */
};

/*!
 * \class CTurbSSTSolver
 * \brief Main class for defining the turbulence model solver.
 * \ingroup Turbulence_Model
 * \author A. Campos, F. Palacios, T. Economon
 * \version 3.2.9 "eagle"
 */

class CTurbSSTSolver: public CTurbSolver {
private:
    double *constants,  /*!< \brief Constants for the model. */
    kine_Inf,           /*!< \brief Free-stream turbulent kinetic energy. */
    omega_Inf;          /*!< \brief Free-stream specific dissipation. */
    
public:
    /*!
     * \brief Constructor of the class.
     */
    CTurbSSTSolver(void);
    
    /*!
     * \overload
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CTurbSSTSolver(CGeometry *geometry, CConfig *config, unsigned short iMesh);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CTurbSSTSolver(void);
    
    /*!
     * \brief Restart residual and compute gradients.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iRKStep - Current step of the Runge-Kutta iteration.
     * \param[in] RunTime_EqSystem - System of equations which is going to be solved.
     */
    void Preprocessing(CGeometry *geometry, CSolver **solver_container, CConfig *config, unsigned short iMesh, unsigned short iRKStep, unsigned short RunTime_EqSystem, bool Output);
    
    /*!
     * \brief Computes the eddy viscosity.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     */
    void Postprocessing(CGeometry *geometry, CSolver **solver_container, CConfig *config,
                        unsigned short iMesh);
    
    /*!
     * \brief Source term computation.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     */
    void Source_Residual(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics, CNumerics *second_numerics,
                         CConfig *config, unsigned short iMesh);
    
    /*!
     * \brief Source term computation.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     */
    void Source_Template(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics,
                         CConfig *config, unsigned short iMesh);
    
    /*!
     * \brief Impose the Navier-Stokes wall boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_HeatFlux_Wall(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics, CConfig *config,
                          unsigned short val_marker);
    
    /*!
     * \brief Impose the Navier-Stokes wall boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Isothermal_Wall(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics, CConfig *config,
                            unsigned short val_marker);
    
    /*!
     * \brief Impose the Far Field boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Far_Field(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics, CConfig *config,
                      unsigned short val_marker);
    
    /*!
     * \brief Impose the inlet boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Inlet(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics, CConfig *config,
                  unsigned short val_marker);
    
    /*!
     * \brief Impose the outlet boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    
    void BC_Outlet(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics, CConfig *config,
                   unsigned short val_marker);
    
    /*!
     * \brief Get the constants for the SST model.
     * \return A pointer to an array containing a set of constants
     */
    double* GetConstants();
    
};

/*!
 * \class CAdjEulerSolver
 * \brief Main class for defining the Euler's adjoint flow solver.
 * \ingroup Euler_Equations
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CAdjEulerSolver : public CSolver {
protected:
    double PsiRho_Inf,	/*!< \brief PsiRho variable at the infinity. */
    PsiE_Inf,			/*!< \brief PsiE variable at the infinity. */
    *Phi_Inf;			/*!< \brief Phi vector at the infinity. */
    double *Sens_Mach, /*!< \brief Mach sensitivity coefficient for each boundary. */
    *Sens_AoA,			/*!< \brief Angle of attack sensitivity coefficient for each boundary. */
    *Sens_Geo,			/*!< \brief Shape sensitivity coefficient for each boundary. */
    *Sens_Press,			/*!< \brief Pressure sensitivity coefficient for each boundary. */
    *Sens_Temp,			/*!< \brief Temperature sensitivity coefficient for each boundary. */
    **CSensitivity;		/*!< \brief Shape sensitivity coefficient for each boundary and vertex. */
    double Total_Sens_Mach;	/*!< \brief Total mach sensitivity coefficient for all the boundaries. */
    double Total_Sens_AoA;		/*!< \brief Total angle of attack sensitivity coefficient for all the boundaries. */
    double Total_Sens_Geo;		/*!< \brief Total shape sensitivity coefficient for all the boundaries. */
    double Total_Sens_Press;    /*!< \brief Total farfield sensitivity to pressure. */
    double Total_Sens_Temp;    /*!< \brief Total farfield sensitivity to temperature. */
    double *iPoint_UndLapl,	/*!< \brief Auxiliary variable for the undivided Laplacians. */
    *jPoint_UndLapl;			/*!< \brief Auxiliary variable for the undivided Laplacians. */
    bool space_centered;  /*!< \brief True if space centered scheeme used. */
    double **Jacobian_Axisymmetric; /*!< \brief Storage for axisymmetric Jacobian. */
    unsigned long nMarker;				/*!< \brief Total number of markers using the grid information. */
    double Gamma;									/*!< \brief Fluid's Gamma constant (ratio of specific heats). */
    double Gamma_Minus_One;				/*!< \brief Fluids's Gamma - 1.0  . */
    double *FlowPrimVar_i,	/*!< \brief Store the flow solution at point i. */
    *FlowPrimVar_j;        /*!< \brief Store the flow solution at point j. */
    
    double pnorm;
    
public:
    
    /*!
     * \brief Constructor of the class.
     */
    CAdjEulerSolver(void);
    
    /*!
     * \overload
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     */
    CAdjEulerSolver(CGeometry *geometry, CConfig *config, unsigned short iMesh);
    
    /*!
     * \brief Destructor of the class.
     */
    virtual ~CAdjEulerSolver(void);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     * \param[in] Iteration - Index of the current iteration.
     */
    void SetTime_Step(CGeometry *geometry, CSolver **solver_container, CConfig *config,
                      unsigned short iMesh, unsigned long Iteration);
    
    /*!
     * \brief Impose the send-receive boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void Set_MPI_Solution(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Impose the send-receive boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void Set_MPI_Solution_Gradient(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Impose the send-receive boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void Set_MPI_Solution_Limiter(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Impose the send-receive boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void Set_MPI_Solution_Old(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Compute the Fan face Mach number.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solution - Container vector with all the solutions.
     */
    void GetEngine_Properties(CGeometry *geometry, CConfig *config, unsigned short iMesh, bool Output);
    
    /*!
     * \brief Created the force projection vector for adjoint boundary conditions.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     */
    void SetForceProj_Vector(CGeometry *geometry, CSolver **solver_container, CConfig *config);
    
    /*!
     * \brief Compute the jump for the interior boundary problem.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     */
    void SetIntBoundary_Jump(CGeometry *geometry, CSolver **solver_container, CConfig *config);
    
    /*!
     * \brief Compute adjoint density at the infinity.
     * \return Value of the adjoint density at the infinity.
     */
    double GetPsiRho_Inf(void);
    
    /*!
     * \brief Compute the adjoint energy at the infinity.
     * \return Value of the adjoint energy at the infinity.
     */
    double GetPsiE_Inf(void);
    
    /*!
     * \brief Compute Phi (adjoint velocity) at the infinity.
     * \param[in] val_dim - Index of the adjoint velocity vector.
     * \return Value of the adjoint velocity vector at the infinity.
     */
    double GetPhi_Inf(unsigned short val_dim);
    
    /*!
     * \brief Compute the spatial integration using a centered scheme for the adjoint equations.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     * \param[in] iRKStep - Current step of the Runge-Kutta iteration.
     */
    void Centered_Residual(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics, CConfig *config,
                           unsigned short iMesh, unsigned short iRKStep);
    
    /*!
     * \brief Compute the spatial integration using a upwind scheme.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     */
    void Upwind_Residual(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics, CConfig *config,
                         unsigned short iMesh);
    
    /*!
     * \brief Source term integration.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     */
    void Source_Residual(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics, CNumerics *second_numerics,
                         CConfig *config, unsigned short iMesh);
    
    /*!
     * \brief Source term integration.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     */
    void Source_Template(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics,
                         CConfig *config, unsigned short iMesh);
    
    /*!
     * \brief Compute the undivided laplacian for the adjoint solution.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void SetUndivided_Laplacian(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Parallelization of Undivided Laplacian.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void Set_MPI_Undivided_Laplacian(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Compute the sensor for higher order dissipation control in rotating problems.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     */
    void SetDissipation_Switch(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     */
    void Set_MPI_Dissipation_Switch(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Impose via the residual the adjoint Euler wall boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Euler_Wall(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics, CConfig *config,
                       unsigned short val_marker);
    
    /*!
     * \brief Impose via the residual the interface adjoint boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Interface_Boundary(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics, CConfig *config);
    
    /*!
     * \brief Impose via the residual the near-field adjoint boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_NearField_Boundary(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics, CConfig *config);
    
    /*!
     * \brief Impose via the residual the adjoint symmetry boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Sym_Plane(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics, CConfig *config,
                      unsigned short val_marker);
    
    /*!
     * \brief Impose the boundary condition to the far field using characteristics.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Far_Field(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics, CConfig *config,
                      unsigned short val_marker);
    
    /*!
     * \brief Impose the inlet boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Inlet(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics, CConfig *config,
                  unsigned short val_marker);
    
    
    /*!
     * \brief Impose the supersonic inlet boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] solver - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Supersonic_Inlet(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics, CConfig *config,
                             unsigned short val_marker);
    
    /*!
     * \brief Impose the supersonic outlet boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] solver - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Supersonic_Outlet(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics, CConfig *config,
                              unsigned short val_marker);
    
    /*!
     * \brief Impose the outlet boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Outlet(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics, CConfig *config,
                   unsigned short val_marker);
    
    /*!
     * \brief Impose the engine inflow adjoint boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Engine_Inflow(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics,
                          CConfig *config, unsigned short val_marker);
    
    /*!
     * \brief Impose the engine bleed adjoint boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Engine_Bleed(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics,
                         CConfig *config, unsigned short val_marker);
    
    /*!
     * \brief Impose the engine exhaust boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Engine_Exhaust(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics,
                           CConfig *config, unsigned short val_marker);
    
    /*!
     * \brief Update the solution using a Runge-Kutta strategy.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iRKStep - Current step of the Runge-Kutta iteration.
     */
    void ExplicitRK_Iteration(CGeometry *geometry, CSolver **solver_container, CConfig *config,
                              unsigned short iRKStep);
    
    /*!
     * \brief Update the solution using a explicit Euler scheme.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     */
    void ExplicitEuler_Iteration(CGeometry *geometry, CSolver **solver_container, CConfig *config);
    
    /*!
     * \brief Update the solution using an implicit solver.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     */
    void ImplicitEuler_Iteration(CGeometry *geometry, CSolver **solver_container, CConfig *config);
    
    /*!
     * \brief Initialize the residual vectors.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iRKStep - Current step of the Runge-Kutta iteration.
     * \param[in] RunTime_EqSystem - System of equations which is going to be solved.
     */
    void Preprocessing(CGeometry *geometry, CSolver **solver_container, CConfig *config, unsigned short iMesh, unsigned short iRKStep, unsigned short RunTime_EqSystem, bool Output);
    
    /*!
     * \brief Compute the inviscid sensitivity of the functional.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     */
    void Inviscid_Sensitivity(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics, CConfig *config);
    
    /*!
     * \brief Smooth the inviscid sensitivity of the functional.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     */
    void Smooth_Sensitivity(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics, CConfig *config);
    
    /*!
     * \brief Get the shape sensitivity coefficient.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \param[in] val_vertex - Vertex of the marker <i>val_marker</i> where the coefficient is evaluated.
     * \return Value of the sensitivity coefficient.
     */
    double GetCSensitivity(unsigned short val_marker, unsigned short val_vertex);
    
    /*!
     * \brief Set the shape sensitivity coefficient.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \param[in] val_vertex - Vertex of the marker <i>val_marker</i> where the coefficient is evaluated.
     * \param[in] val_sensitivity - Value of the sensitivity coefficient.
     */
    void SetCSensitivity(unsigned short val_marker, unsigned short val_vertex, double val_sensitivity);
    
    /*!
     * \brief Provide the total shape sensitivity coefficient.
     * \return Value of the geometrical sensitivity coefficient
     *         (inviscid + viscous contribution).
     */
    double GetTotal_Sens_Geo(void);
    
    /*!
     * \brief Set the total Mach number sensitivity coefficient.
     * \return Value of the Mach sensitivity coefficient
     *         (inviscid + viscous contribution).
     */
    double GetTotal_Sens_Mach(void);
    
    /*!
     * \brief Set the total angle of attack sensitivity coefficient.
     * \return Value of the angle of attack sensitivity coefficient
     *         (inviscid + viscous contribution).
     */
    double GetTotal_Sens_AoA(void);
    
    /*!
     * \brief Set the total farfield pressure sensitivity coefficient.
     * \return Value of the farfield pressure sensitivity coefficient
     *         (inviscid + viscous contribution).
     */
    double GetTotal_Sens_Press(void);
    
    /*!
     * \brief Set the total farfield temperature sensitivity coefficient.
     * \return Value of the farfield temperature sensitivity coefficient
     *         (inviscid + viscous contribution).
     */
    double GetTotal_Sens_Temp(void);
    
    /*!
     * \brief Set the total residual adding the term that comes from the Dual Time Strategy.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iRKStep - Current step of the Runge-Kutta iteration.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     * \param[in] RunTime_EqSystem - System of equations which is going to be solved.
     */
    void SetResidual_DualTime(CGeometry *geometry, CSolver **solver_container, CConfig *config,
                              unsigned short iRKStep, unsigned short iMesh, unsigned short RunTime_EqSystem);
    
    /*!
     * \brief Set the initial condition for the Euler Equations.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] ExtIter - External iteration.
     */
    void SetInitialCondition(CGeometry **geometry, CSolver ***solver_container, CConfig *config, unsigned long ExtIter);
    
    
};

/*!
 * \class CAdjNSSolver
 * \brief Main class for defining the Navier-Stokes' adjoint flow solver.
 * \ingroup Navier_Stokes_Equations
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CAdjNSSolver : public CAdjEulerSolver {
public:
    
    /*!
     * \brief Constructor of the class.
     */
    CAdjNSSolver(void);
    
    /*!
     * \overload
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     */
    CAdjNSSolver(CGeometry *geometry, CConfig *config, unsigned short iMesh);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CAdjNSSolver(void);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     * \param[in] Iteration - Index of the current iteration.
     */
    void SetTime_Step(CGeometry *geometry, CSolver **solver_container, CConfig *config,
                      unsigned short iMesh, unsigned long Iteration);
    
    
    /*!
     * \brief Impose via the residual or brute force the Navier-Stokes adjoint boundary condition (heat flux).
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_HeatFlux_Wall(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics, CConfig *config,
                          unsigned short val_marker);
    
    /*!
     * \brief Impose via the residual or brute force the Navier-Stokes adjoint boundary condition (heat flux).
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Isothermal_Wall(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics, CConfig *config, unsigned short val_marker);
    
    /*!
     * \brief Restart residual and compute gradients.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iRKStep - Current step of the Runge-Kutta iteration.
     * \param[in] RunTime_EqSystem - System of equations which is going to be solved.
     */
    void Preprocessing(CGeometry *geometry, CSolver **solver_container, CConfig *config, unsigned short iMesh, unsigned short iRKStep, unsigned short RunTime_EqSystem, bool Output);
    
    /*!
     * \brief Compute the viscous sensitivity of the functional.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     */
    void Viscous_Sensitivity(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics, CConfig *config);
    
    /*!
     * \brief Compute the viscous residuals for the adjoint equation.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     * \param[in] iRKStep - Current step of the Runge-Kutta iteration.
     */
    void Viscous_Residual(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics,
                          CConfig *config, unsigned short iMesh, unsigned short iRKStep);
    
    /*!
     * \brief Source term computation.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     */
    void Source_Residual(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics, CNumerics *second_numerics,
                         CConfig *config, unsigned short iMesh);
    
};

/*!
 * \class CAdjTurbSolver
 * \brief Main class for defining the adjoint turbulence model solver.
 * \ingroup Turbulence_Model
 * \author F. Palacios, A. Bueno.
 * \version 3.2.9 "eagle"
 */
class CAdjTurbSolver : public CSolver {
private:
    double PsiNu_Inf,	/*!< \brief PsiNu variable at the infinity. */
    *FlowSolution_i,	/*!< \brief Store the flow solution at point i. */
    *FlowSolution_j;	/*!< \brief Store the flow solution at point j. */
    
    double Gamma;									/*!< \brief Fluid's Gamma constant (ratio of specific heats). */
    double Gamma_Minus_One;				/*!< \brief Fluids's Gamma - 1.0  . */
    
public:
    
    /*!
     * \brief Default constructor of the class.
     */
    CAdjTurbSolver(void);
    
    /*!
     * \overload
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CAdjTurbSolver(CGeometry *geometry, CConfig *config, unsigned short iMesh);
    
    /*!
     * \brief Impose the send-receive boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void Set_MPI_Solution(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Impose the send-receive boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void Set_MPI_Solution_Old(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Impose the send-receive boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void Set_MPI_Solution_Gradient(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Default destructor of the class.
     */
    virtual ~CAdjTurbSolver(void);
    
    /*!
     * \brief Impose the Navier-Stokes turbulent adjoint boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_HeatFlux_Wall(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics, CConfig *config,
                          unsigned short val_marker);
    
    /*!
     * \brief Impose an isothermal wall boundary condition (no-slip).
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Isothermal_Wall(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics, CConfig *config,
                            unsigned short val_marker);
    
    /*!
     * \brief Impose the boundary condition to the far field using characteristics.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Far_Field(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics, CConfig *config,
                      unsigned short val_marker);
    
    /*!
     * \brief Initializate the residual vectors.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iRKStep - Current step of the Runge-Kutta iteration.
     * \param[in] RunTime_EqSystem - System of equations which is going to be solved.
     */
    void Preprocessing(CGeometry *geometry, CSolver **solver_container, CConfig *config, unsigned short iMesh, unsigned short iRKStep, unsigned short RunTime_EqSystem, bool Output);
    
    /*!
     * \brief Compute the spatial integration using a upwind scheme.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     */
    void Upwind_Residual(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics, CConfig *config,
                         unsigned short iMesh);
    
    /*!
     * \brief Compute the viscous residuals for the turbulent adjoint equation.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     * \param[in] iRKStep - Current step of the Runge-Kutta iteration.
     */
    void Viscous_Residual(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics, CConfig *config,
                          unsigned short iMesh, unsigned short iRKStep);
    
    /*!
     * \brief Source term computation.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     */
    void Source_Residual(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics, CNumerics *second_numerics,
                         CConfig *config, unsigned short iMesh);
    
    /*!
     * \brief Update the solution using an implicit solver.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     */
    void ImplicitEuler_Iteration(CGeometry *geometry, CSolver **solver_container, CConfig *config);
    
};

/*!
 * \class CLinEulerSolver
 * \brief Main class for defining the linearized Euler solver.
 * \ingroup Euler_Equations
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CLinEulerSolver : public CSolver {
private:
    double DeltaRho_Inf,	/*!< \brief Linearized density variable at the infinity. */
    DeltaE_Inf,				/*!< \brief Linearized energy at the infinity. */
    *DeltaVel_Inf;			/*!< \brief Linearized velocity vector at the infinity. */
    double *iPoint_UndLapl,	/*!< \brief Undivided Laplacians for centered scheme. */
    *jPoint_UndLapl;			/*!< \brief Undivided Laplacians for centered scheme. */
    double *CDeltaDrag_Inv, /*!< \brief Linearized drag coefficient (inviscid contribution) for each boundary. */
    *CDeltaLift_Inv,		/*!< \brief Linearized lift coefficient (inviscid contribution) for each boundary. */
    *DeltaForceInviscid;	/*!< \brief Linearized inviscid force for each boundary. */
    double AllBound_CDeltaDrag_Inv, /*!< \brief Total linearized drag coefficient (inviscid contribution) for all the boundaries. */
    AllBound_CDeltaLift_Inv;		/*!< \brief Total linearized lift coefficient (inviscid contribution) for all the boundaries. */
    double Total_CDeltaDrag,	/*!< \brief Total linearized drag coefficient for all the boundaries. */
    Total_CDeltaLift;			/*!< \brief Total linearized lift coefficient for all the boundaries. */
    double Gamma;									/*!< \brief Fluid's Gamma constant (ratio of specific heats). */
    double Gamma_Minus_One;				/*!< \brief Fluids's Gamma - 1.0  . */
    
public:
    
    /*!
     * \brief Constructor of the class.
     */
    CLinEulerSolver(void);
    
    /*!
     * \overload
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CLinEulerSolver(CGeometry *geometry, CConfig *config, unsigned short iMesh);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CLinEulerSolver(void);
    
    /*!
     * \brief Compute the spatial integration using a centered scheme for the linearized equations.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     * \param[in] iRKStep - Current step of the Runge-Kutta iteration.
     */
    void Centered_Residual(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics, CConfig *config,
                           unsigned short iMesh, unsigned short iRKStep);
    
    /*!
     * \brief Compute the undivided laplacian for the linearized solution.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void SetUndivided_Laplacian(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Impose via the residual the linearized Euler wall boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Euler_Wall(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics, CConfig *config,
                       unsigned short val_marker);
    
    /*!
     * \brief Impose the far-field boundary condition using characteristics.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Far_Field(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics, CConfig *config,
                      unsigned short val_marker);
    
    /*!
     * \brief Update the solution using a Runge-Kutta scheme.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iRKStep - Current step of the Runge-Kutta iteration.
     */
    void ExplicitRK_Iteration(CGeometry *geometry, CSolver **solver_container, CConfig *config,
                              unsigned short iRKStep);
    
    /*!
     * \brief Restart residual.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iRKStep - Current step of the Runge-Kutta iteration.
     * \param[in] RunTime_EqSystem - System of equations which is going to be solved.
     */
    void Preprocessing(CGeometry *geometry, CSolver **solver_container, CConfig *config, unsigned short iMesh, unsigned short iRKStep, unsigned short RunTime_EqSystem, bool Output);
    
    /*!
     * \brief Compute the linearization of the pressure forces and all the adimensional coefficients.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     */
    void Inviscid_DeltaForces(CGeometry *geometry, CSolver **solver_container, CConfig *config);
    
    /*!
     * \brief Get the total non dimensional drag coefficient.
     * \return Value of the linearized drag coefficient (inviscid contribution).
     */
    double GetTotal_CDeltaDrag(void);
    
    /*!
     * \brief Get the total non dimensional lift coefficient.
     * \return Value of the linearized lift coefficient (inviscid contribution).
     */
    double GetTotal_CDeltaLift(void);
};

/*! \class CPoissonSolver
 *  \brief Main class for defining the poisson potential solver.
 *  \author F. Palacios
 *  \version 3.2.9 "eagle"
 *  \date May 3, 2010.
 */
class CPoissonSolver : public CSolver {
private:
    double Total_CCharge;			/*!< \brief Total charge coefficient for all the domain. */
    double *Source_Vector;		/*!< \brief Auxiliary vector for storing element source vector. */
    
    double Gamma;									/*!< \brief Fluid's Gamma constant (ratio of specific heats). */
    double Gamma_Minus_One;				/*!< \brief Fluids's Gamma - 1.0  . */
    
    double **StiffMatrix_Elem,			/*!< \brief Auxiliary matrices for storing point to point Stiffness Matrices. */
    **StiffMatrix_Node;							/*!< \brief Auxiliary matrices for storing point to point Stiffness Matrices. */
    
    
public:
    
    /*!
     * \brief Constructor of the class.
     */
    CPoissonSolver(void);
    
    /*!
     * \overload
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CPoissonSolver(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief A virtual member.
     * \param[in] solver1_geometry - Geometrical definition of the problem.
     * \param[in] solver1_solution - Container vector with all the solutions.
     * \param[in] solver1_config - Definition of the particular problem.
     * \param[in] solver2_geometry - Geometrical definition of the problem.
     * \param[in] solver2_solution - Container vector with all the solutions.
     * \param[in] solver2_config - Definition of the particular problem.
     */
    void Copy_Zone_Solution(CSolver ***solver1_solution, CGeometry **solver1_geometry, CConfig *solver1_config, CSolver ***solver2_solution, CGeometry **solver2_geometry, CConfig *solver2_config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CPoissonSolver(void);
    
    /*!
     * \brief Integrate the Poisson equation using a Galerkin method.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     */
    void Viscous_Residual(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics, CConfig *config,
                          unsigned short iMesh, unsigned short iRKStep);
    
    /*!
     * \brief Integrate the Poisson equation using a Galerkin method.
     * \param[in] StiffMatrix_Elem - Element stiffness matrix
     */
    void AddStiffMatrix(double **StiffMatrix_Elem, unsigned long Point_0, unsigned long Point_1, unsigned long Point_2, unsigned long Point_3);
    
    /*!
     * \brief Compute the residual.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     */
    void Compute_Residual(CGeometry *geometry, CSolver **solver_container, CConfig *config,
                          unsigned short iMesh);
    
    /*!
     * \brief Impose via the residual the Dirichlet boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Dirichlet(CGeometry *geometry, CSolver **solver_container, CConfig *config, unsigned short val_marker);
    
    /*!
     * \brief Impose via the residual the Neumann boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Neumann(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics, CConfig *config, unsigned short val_marker);
    
    /*!
     * \brief Set residuals to zero.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iRKStep - Current step of the Runge-Kutta iteration.
     * \param[in] RunTime_EqSystem - System of equations which is going to be solved.
     */
    void Preprocessing(CGeometry *geometry, CSolver **solver_container, CConfig *config, unsigned short iMesh, unsigned short iRKStep, unsigned short RunTime_EqSystem, bool Output);
    
    /*!
     * \brief Source term computation.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     */
    void Source_Residual(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics, CNumerics *second_numerics,
                         CConfig *config, unsigned short iMesh);
    
    /*!
     * \brief Source term computation.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     */
    void Source_Template(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics,
                         CConfig *config, unsigned short iMesh);
    
    /*!
     * \brief Update the solution using an implicit solver.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     */
    void ImplicitEuler_Iteration(CGeometry *geometry, CSolver **solver_container, CConfig *config);
    
};

/*! \class CWaveSolver
 *  \brief Main class for defining the wave solver.
 *  \author F. Palacios
 *  \version 3.2.9 "eagle"
 *  \date May 3, 2010.
 */
class CWaveSolver : public CSolver {
private:
    double *CWave;	/*!< \brief Wave strength for each boundary. */
    double AllBound_CWave;	/*!< \brief Total wave strength for all the boundaries. */
    double Total_CWave; /*!< \brief Total wave strength for all the boundaries. */
    
    CSysMatrix StiffMatrixSpace; /*!< \brief Sparse structure for storing the stiffness matrix in Galerkin computations. */
    CSysMatrix StiffMatrixTime;	/*!< \brief Sparse structure for storing the stiffness matrix in Galerkin computations. */
    
    double **StiffMatrix_Elem,			/*!< \brief Auxiliary matrices for storing point to point Stiffness Matrices. */
    **StiffMatrix_Node;							/*!< \brief Auxiliary matrices for storing point to point Stiffness Matrices. */
    
public:
    
    /*!
     * \brief Constructor of the class.
     */
    CWaveSolver(void);
    
    /*!
     * \overload
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CWaveSolver(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CWaveSolver(void);
    
    /*!
     * \brief Integrate the Poisson equation using a Galerkin method.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     */
    void Viscous_Residual(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics, CConfig *config,
                          unsigned short iMesh, unsigned short iRKStep);
    
    /*!
     * \brief Impose via the residual the Euler wall boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Euler_Wall(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics, CConfig *config,
                       unsigned short val_marker);
    
    /*!
     * \brief Impose a Dirichlet boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Far_Field(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics, CConfig *config,
                      unsigned short val_marker);
    
    /*!
     * \brief Set residuals to zero.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iRKStep - Current step of the Runge-Kutta iteration.
     * \param[in] RunTime_EqSystem - System of equations which is going to be solved.
     */
    void Preprocessing(CGeometry *geometry, CSolver **solver_container, CConfig *config, unsigned short iMesh, unsigned short iRKStep, unsigned short RunTime_EqSystem, bool Output);
    
    /*!
     * \brief Source term computation.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     */
    void Source_Residual(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics, CNumerics *second_numerics,
                         CConfig *config, unsigned short iMesh);
    
    /*!
     * \brief Source term computation.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     */
    void Source_Template(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics,
                         CConfig *config, unsigned short iMesh);
    
    /*!
     * \brief Update the solution using an implicit solver.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     */
    void ImplicitEuler_Iteration(CGeometry *geometry, CSolver **solver_container, CConfig *config);
    
    /*!
     * \brief Set the total residual adding the term that comes from the Dual Time Strategy.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iRKStep - Current step of the Runge-Kutta iteration.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     * \param[in] RunTime_EqSystem - System of equations which is going to be solved.
     */
    void SetResidual_DualTime(CGeometry *geometry, CSolver **solver_container, CConfig *config,
                              unsigned short iRKStep, unsigned short iMesh, unsigned short RunTime_EqSystem);
    
    /*!
     * \brief Load a solution from a restart file.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver - Container vector with all of the solvers.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_iter - Current external iteration number.
     */
    void LoadRestart(CGeometry **geometry, CSolver ***solver, CConfig *config, int val_iter);
    
    /*!
     * \brief Compute the total wave strength coefficient.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void Wave_Strength(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Build stiffness matrix in space.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void SetSpace_Matrix(CGeometry *geometry,
                         CConfig   *config);
    
    /*!
     * \brief Provide the total wave strength.
     * \return Value of the wave strength.
     */
    double GetTotal_CWave(void);
    
};

/*! \class CHeatSolver
 *  \brief Main class for defining the heat solver.
 *  \author F. Palacios
 *  \version 3.2.9 "eagle"
 *  \date May 3, 2010.
 */
class CHeatSolver : public CSolver {
private:
    double *CHeat;	/*!< \brief Heat strength for each boundary. */
    double AllBound_CHeat;	/*!< \brief Total Heat strength for all the boundaries. */
    double Total_CHeat; /*!< \brief Total Heat strength for all the boundaries. */
    
    CSysMatrix StiffMatrixSpace; /*!< \brief Sparse structure for storing the stiffness matrix in Galerkin computations. */
    CSysMatrix StiffMatrixTime;	/*!< \brief Sparse structure for storing the stiffness matrix in Galerkin computations. */
    
    double **StiffMatrix_Elem,			/*!< \brief Auxiliary matrices for storing point to point Stiffness Matrices. */
    **StiffMatrix_Node;							/*!< \brief Auxiliary matrices for storing point to point Stiffness Matrices. */
    
public:
    
    /*!
     * \brief Constructor of the class.
     */
    CHeatSolver(void);
    
    /*!
     * \overload
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CHeatSolver(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CHeatSolver(void);
    
    /*!
     * \brief Integrate the Poisson equation using a Galerkin method.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     */
    void Viscous_Residual(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics, CConfig *config,
                          unsigned short iMesh, unsigned short iRKStep);
    
    /*!
     * \brief Impose via the residual or brute force the Navier-Stokes adjoint boundary condition (heat flux).
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_HeatFlux_Wall(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics, CConfig *config,
                          unsigned short val_marker);
    
    /*!
     * \brief Impose via the residual or brute force the Navier-Stokes adjoint boundary condition (heat flux).
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Isothermal_Wall(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics, CConfig *config, unsigned short val_marker);
    
    /*!
     * \brief Set residuals to zero.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iRKStep - Current step of the Runge-Kutta iteration.
     * \param[in] RunTime_EqSystem - System of equations which is going to be solved.
     */
    void Preprocessing(CGeometry *geometry, CSolver **solver_container, CConfig *config, unsigned short iMesh, unsigned short iRKStep, unsigned short RunTime_EqSystem, bool Output);
    
    /*!
     * \brief Source term computation.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     */
    void Source_Residual(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics, CNumerics *second_numerics,
                         CConfig *config, unsigned short iMesh);
    
    /*!
     * \brief Update the solution using an implicit solver.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     */
    void ImplicitEuler_Iteration(CGeometry *geometry, CSolver **solver_container, CConfig *config);
    
    /*!
     * \brief Set the total residual adding the term that comes from the Dual Time Strategy.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iRKStep - Current step of the Runge-Kutta iteration.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     * \param[in] RunTime_EqSystem - System of equations which is going to be solved.
     */
    void SetResidual_DualTime(CGeometry *geometry, CSolver **solver_container, CConfig *config,
                              unsigned short iRKStep, unsigned short iMesh, unsigned short RunTime_EqSystem);
    
    /*!
     * \brief Provide the total heat strength.
     * \return Value of the heat strength.
     */
    double GetTotal_CHeat(void);
    
};

/*! \class CFEASolver
 *  \brief Main class for defining the FEA solver.
 *  \author F. Palacios
 *  \version 3.2.9 "eagle"
 *  \date May 3, 2010.
 */
class CFEASolver : public CSolver {
private:
    
    double  Total_CFEA;			/*!< \brief Total FEA coefficient for all the boundaries. */
    CSysMatrix StiffMatrixSpace; /*!< \brief Sparse structure for storing the stiffness matrix in Galerkin computations. */
    CSysMatrix StiffMatrixTime;	/*!< \brief Sparse structure for storing the stiffness matrix in Galerkin computations. */
    
    double **StiffMatrix_Elem,			/*!< \brief Auxiliary matrices for storing point to point Stiffness Matrices. */
    **StiffMatrix_Node;							/*!< \brief Auxiliary matrices for storing point to point Stiffness Matrices. */
    
public:
    
    /*!
     * \brief Constructor of the class.
     */
    CFEASolver(void);
    
    /*!
     * \overload
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CFEASolver(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CFEASolver(void);
    
    /*!
     * \brief Integrate the Poisson equation using a Galerkin method.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     */
    void Viscous_Residual(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics, CConfig *config,
                          unsigned short iMesh, unsigned short iRKStep);
    
    /*!
     * \brief Impose a displacement (constraint) boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Normal_Displacement(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics, CConfig *config,
                                unsigned short val_marker);
    
    /*!
     * \brief Impose a load boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Flow_Load(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics, CConfig *config,
                      unsigned short val_marker);
    
    /*!
     * \brief Impose a load boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Normal_Load(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics, CConfig *config,
                        unsigned short val_marker);
    
    /*!
     * \brief Impose a load boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Pressure(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics, CConfig *config,
                     unsigned short val_marker);
    
    /*!
     * \brief Set residuals to zero.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iRKStep - Current step of the Runge-Kutta iteration.
     * \param[in] RunTime_EqSystem - System of equations which is going to be solved.
     */
    void Preprocessing(CGeometry *geometry, CSolver **solver_container, CConfig *config, unsigned short iMesh, unsigned short iRKStep, unsigned short RunTime_EqSystem, bool Output);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     */
    void Postprocessing(CGeometry *geometry, CSolver **solver_container, CConfig *config, unsigned short iMesh);
    
    /*!
     * \brief Source term computation.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     */
    void Source_Residual(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics, CNumerics *second_numerics,
                         CConfig *config, unsigned short iMesh);
    
    /*!
     * \brief Update the solution using an implicit solver.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     */
    void ImplicitEuler_Iteration(CGeometry *geometry, CSolver **solver_container, CConfig *config);
    
    /*!
     * \brief Set the total residual adding the term that comes from the Dual Time Strategy.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iRKStep - Current step of the Runge-Kutta iteration.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     * \param[in] RunTime_EqSystem - System of equations which is going to be solved.
     */
    void SetResidual_DualTime(CGeometry *geometry, CSolver **solver_container, CConfig *config,
                              unsigned short iRKStep, unsigned short iMesh, unsigned short RunTime_EqSystem);
    
    /*!
     * \brief Get the surface pressure from a file.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void GetSurface_Pressure(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Set the the pressure load in the FEA solver.
     * \param[in] fea_geometry - Geometrical definition of the problem.
     * \param[in] flow_solution - Container vector with all the solutions.
     * \param[in] fea_config - Definition of the particular problem.
     */
    void SetFEA_Load(CSolver ***flow_solution, CGeometry **fea_geometry, CGeometry **flow_geometry, CConfig *fea_config, CConfig *flow_config);
    
    /*!
     * \brief Set the initial condition for the FEA Equations.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] ExtIter - External iteration.
     */
    void SetInitialCondition(CGeometry **geometry, CSolver ***solver_container, CConfig *config, unsigned long ExtIter);
    
    /*!
     * \brief Provide the total (inviscid + viscous) non dimensional FEA coefficient.
     * \return Value of the FEA coefficient (inviscid + viscous contribution).
     */
    double GetTotal_CFEA(void);
    
    /*!
     * \brief Set the value of the FEA coefficient.
     * \param[in] val_cfea - Value of the FEA coefficient.
     */
    void SetTotal_CFEA(double val_cfea);
    
};

/*!
 * \class CAdjLevelSetSolver
 * \brief Main class for defining the level set solver.
 * \ingroup LevelSet_Model
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CAdjLevelSetSolver : public CSolver {
protected:
    double *FlowSolution_i,	/*!< \brief Store the flow solution at point i. */
    *FlowSolution_j,		/*!< \brief Store the flow solution at point j. */
    Total_CFreeSurface;			/*!< \brief Total Free Surface coefficient for all the boundaries. */
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CAdjLevelSetSolver(CGeometry *geometry, CConfig *config, unsigned short iMesh);
    
    /*!
     * \brief Destructor of the class.
     */
    virtual ~CAdjLevelSetSolver(void);
    
    /*!
     * \brief Impose the send-receive boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void Set_MPI_Solution(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Impose the send-receive boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void Set_MPI_Solution_Gradient(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Impose the send-receive boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void Set_MPI_Solution_Limiter(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Impose the Symmetry Plane boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Sym_Plane(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics, CConfig *config,
                      unsigned short val_marker);
    
    /*!
     * \brief Update the solution using an implicit solver.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     */
    void ImplicitEuler_Iteration(CGeometry *geometry, CSolver **solver_container, CConfig *config);
    
    /*!
     * \brief Restart residual and compute gradients.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iRKStep - Current step of the Runge-Kutta iteration.
     * \param[in] RunTime_EqSystem - System of equations which is going to be solved.
     */
    void Preprocessing(CGeometry *geometry, CSolver **solver_container, CConfig *config, unsigned short iMesh, unsigned short iRKStep, unsigned short RunTime_EqSystem, bool Output);
    
    /*!
     * \brief Compute the spatial integration using a upwind scheme.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     */
    void Upwind_Residual(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics, CConfig *config,
                         unsigned short iMesh);
    
    /*!
     * \brief Source term computation.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     */
    void Source_Residual(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics, CNumerics *second_numerics,
                         CConfig *config, unsigned short iMesh);
    
    /*!
     * \brief Source term computation.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     */
    void Source_Template(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics,
                         CConfig *config, unsigned short iMesh);
    
    /*!
     * \brief Impose via the residual the Euler wall boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Euler_Wall(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics, CConfig *config,
                       unsigned short val_marker);
    
    /*!
     * \brief Impose the Navier-Stokes wall boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_HeatFlux_Wall(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics, CConfig *config,
                          unsigned short val_marker);
    
    /*!
     * \brief Impose the Far Field boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Far_Field(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics, CConfig *config,
                      unsigned short val_marker);
    
    /*!
     * \brief Impose the Far Field boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Inlet(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics, CConfig *config,
                  unsigned short val_marker);
    
    /*!
     * \brief Impose the Far Field boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Outlet(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics, CConfig *config,
                   unsigned short val_marker);
    
    /*!
     * \brief Set the total residual adding the term that comes from the Dual Time Strategy.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iRKStep - Current step of the Runge-Kutta iteration.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     * \param[in] RunTime_EqSystem - System of equations which is going to be solved.
     */
    void SetResidual_DualTime(CGeometry *geometry, CSolver **solver_container, CConfig *config,
                              unsigned short iRKStep, unsigned short iMesh, unsigned short RunTime_EqSystem);
    
};

/*!
 * \class CTemplateSolver
 * \brief Main class for defining the template model solver.
 * \ingroup Template_Flow_Equation
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CTemplateSolver : public CSolver {
private:
    
public:
    
    /*!
     * \brief Constructor of the class.
     */
    CTemplateSolver(void);
    
    /*!
     * \overload
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CTemplateSolver(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CTemplateSolver(void);
    
    /*!
     * \brief Compute the velocity^2, SoundSpeed, Pressure.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iRKStep - Current step of the Runge-Kutta iteration.
     * \param[in] RunTime_EqSystem - System of equations which is going to be solved.
     */
    void Preprocessing(CGeometry *geometry, CSolver **solver_container, CConfig *config, unsigned short iMesh, unsigned short iRKStep, unsigned short RunTime_EqSystem, bool Output);
    
    /*!
     * \brief Compute the time step for solving the Euler equations.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     * \param[in] Iteration - Index of the current iteration.
     */
    void SetTime_Step(CGeometry *geometry, CSolver **solver_container, CConfig *config,
                      unsigned short iMesh, unsigned long Iteration);
    
    /*!
     * \brief Compute the spatial integration using a centered scheme.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     * \param[in] iRKStep - Current step of the Runge-Kutta iteration.
     */
    void Centered_Residual(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics,
                           CConfig *config, unsigned short iMesh, unsigned short iRKStep);
    
    /*!
     * \brief Compute the spatial integration using a upwind scheme.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     */
    void Upwind_Residual(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics,
                         CConfig *config, unsigned short iMesh);
    
    /*!
     * \brief Source term integration.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     */
    void Source_Residual(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics, CNumerics *second_numerics,
                         CConfig *config, unsigned short iMesh);
    
    /*!
     * \brief Source term integration.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     */
    void Source_Template(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics,
                         CConfig *config, unsigned short iMesh);
    
    /*!
     * \brief Impose via the residual the Euler wall boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Euler_Wall(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics, CConfig *config,
                       unsigned short val_marker);
    
    /*!
     * \brief Impose the Navier-Stokes boundary condition (strong).
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_HeatFlux_Wall(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics, CConfig *config,
                          unsigned short val_marker);
    
    /*!
     * \brief Impose the far-field boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Far_Field(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics, CConfig *config,
                      unsigned short val_marker);
    
    /*!
     * \brief Impose the inlet boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Inlet(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics, CConfig *config,
                  unsigned short val_marker);
    
    /*!
     * \brief Impose the outlet boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Outlet(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics, CConfig *config,
                   unsigned short val_marker);
    
    /*!
     * \brief Impose the symmetry plane boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Sym_Plane(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics, CConfig *config,
                      unsigned short val_marker);
    
    /*!
     * \brief Impose the dirichlet boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Custom(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics,
                   CConfig *config, unsigned short val_marker);
    
    /*!
     * \brief Update the solution using a Runge-Kutta scheme.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iRKStep - Current step of the Runge-Kutta iteration.
     */
    void ExplicitRK_Iteration(CGeometry *geometry, CSolver **solver_container, CConfig *config,
                              unsigned short iRKStep);
    
    /*!
     * \brief Update the solution using the explicit Euler scheme.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     */
    void ExplicitEuler_Iteration(CGeometry *geometry, CSolver **solver_container, CConfig *config);
    
    /*!
     * \brief Update the solution using an implicit Euler scheme.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     */
    void ImplicitEuler_Iteration(CGeometry *geometry, CSolver **solver_container, CConfig *config);
    
};

/*!
 * \class CTNE2EulerSolver
 * \brief Main class for defining the TNE2 Euler's flow solver.
 * \ingroup Euler_Equations
 * \author S. R. Copeland, F. Palacios
 * \version 2.0.6
 */
class CTNE2EulerSolver : public CSolver {
protected:
    
    unsigned short
    nSpecies;	                /*!< \brief Number of species in the gas mixture. */
    
    double
    Gamma,                    /*!< \brief Mixture Cp/Cv. */
    Gamma_Minus_One;	        /*!< \brief Mixture Cp/Cv - 1. */
    
    double
    Mach_Inf,       	        /*!< \brief Free stream Mach number. */
    *Density,                 /*!< \brief Free stream species density. */
    Energy_ve_Inf,            /*!< \brief Vib.-el. free stream energy. */
    Pressure_Inf,		          /*!< \brief Free stream pressure. */
    *Velocity_Inf,		        /*!< \brief Free stream flow velocity. */
    *MassFrac_Inf,            /*!< \brief Free stream species mass fraction. */
    Temperature_Inf,          /*!< \brief Trans.-rot. free stream temperature. */
    Temperature_ve_Inf;       /*!< \brief Vib.-el. free stream temperature. */
    
    double
    *lowerlimit,            /*!< \brief contains lower limits for conserved variables. */
    *upperlimit;            /*!< \brief contains upper limits for conserved variables. */
    
    double
    *CDrag_Inv,	              /*!< \brief Boundary invisc. Cd contribution. */
    *CLift_Inv,			          /*!< \brief Boundary invisc. Cl contribution. */
    *CSideForce_Inv,		      /*!< \brief Boundary invisc. sideforce contribution. */
    *CMx_Inv,			            /*!< \brief X-moment contribution on boundaries. */
    *CMy_Inv,			            /*!< \brief Y-moment contribution on boundaries. */
    *CMz_Inv,			            /*!< \brief Z-moment contribution on boundaries. */
    *CFx_Inv,			            /*!< \brief X-force contribution on boundaries. */
    *CFy_Inv,                 /*!< \brief Y-force contribution on boundaries. */
    *CFz_Inv,                 /*!< \brief Z-force contribution on boundaries. */
    *CEff_Inv,			        	/*!< \brief Invisc. Cl/Cd on boundaries. */
    *ForceInviscid,		        /*!< \brief Inviscid forces at domain boundaries. */
    *MomentInviscid,	        /*!< \brief Inviscid moments at domain boundaries. */
    **CPressure,		          /*!< \brief Cp at each node on domain boundaries . */
    **HeatFlux,		      /*!< \brief Cq at each node on domain boundaries . */
    **CharacPrimVar,		      /*!< \brief Value of the characteristic variables at the boundary . */
    AllBound_CDrag_Inv,	      /*!< \brief Sum of CDrag_Inv from all boundaries. */
    AllBound_CLift_Inv,			  /*!< \brief Sum of CLift_Inv from all boundaries. */
    AllBound_CSideForce_Inv,	/*!< \brief Sum of CSideForce_Inv from all boundaries. */
    AllBound_CMx_Inv,			    /*!< \brief Sum of CMx_Inv from all boundaries. */
    AllBound_CMy_Inv,			    /*!< \brief Sum of CMy_Inv from all boundaries. */
    AllBound_CMz_Inv,			    /*!< \brief Sum of CMz_Inv from all boundaries. */
    AllBound_CFx_Inv,			    /*!< \brief Sum of CFx_Inv from all boundaries. */
    AllBound_CFy_Inv,			    /*!< \brief Sum of CFy_Inv from all boundaries. */
    AllBound_CFz_Inv,			    /*!< \brief Sum of CFz_Inv from all boundaries. */
    AllBound_CEff_Inv;        /*!< \brief Sum of CEff_Inv from all boundaries. */
    
    double
    Total_CDrag,              /*!< \brief Total Cd. */
    Total_CLift,		          /*!< \brief Total Cl. */
    Total_CSideForce,		      /*!< \brief Total CSideForce. */
    Total_CMx,			          /*!< \brief Total CMx. */
    Total_CMy,                /*!< \brief Total CMy. */
    Total_CMz,                /*!< \brief Total CMz. */
    Total_CFx,                /*!< \brief Total CFx. */
    Total_CFy,                /*!< \brief Total CFy. */
    Total_CFz,                /*!< \brief Total CFz. */
    Total_CEff,               /*!< \brief Total CEff. */
    Total_Heat,                  /*!< \brief Total heat load. */
    Total_MaxHeat;               /*!< \brief Maximum heat flux on all boundaries. */
    
    double
    *PrimVar_i,	      /*!< \brief Vector for storing primitives at node i. */
    *PrimVar_j;			  /*!< \brief Vector for storing primitives at node j. */
    
    double
    **LowMach_Precontioner; /*!< \brief Matrix for storing the inverse of preconditioner. */
    
    unsigned long
    nMarker;				  /*!< \brief Total number of domain boundaries. */
    
    bool least_squares;     /*!< \brief Indicator for least-squares computed grads. */
    
public:
    
    /*!
     * \brief Constructor of the class.
     */
    CTNE2EulerSolver(void);
    
    /*!
     * \overload
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CTNE2EulerSolver(CGeometry *geometry, CConfig *config, unsigned short iMesh);
    
    /*!
     * \brief Destructor of the class.
     */
    virtual ~CTNE2EulerSolver(void);
    
    /*!
     * \brief Impose the send-receive boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void Set_MPI_Solution(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Impose the send-receive boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void Set_MPI_Solution_Old(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Impose the send-receive boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void Set_MPI_Primitive(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Impose the send-receive boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void Set_MPI_Solution_Limiter(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Impose the send-receive boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void Set_MPI_Primitive_Limiter(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Impose the send-receive boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void Set_MPI_Undivided_Laplacian(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Impose the send-receive boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void Set_MPI_MaxEigenvalue(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Impose the send-receive boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void Set_MPI_Dissipation_Switch(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Impose the send-receive boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void Set_MPI_Solution_Gradient(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Impose the send-receive boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void Set_MPI_Primitive_Gradient(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Set the fluid solver nondimensionalization.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void SetNondimensionalization(CGeometry *geometry, CConfig *config, unsigned short iMesh);
    
    /*!
     * \brief Set the maximum value of the eigenvalue.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void SetMax_Eigenvalue(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Compute the density at the infinity.
     * \return Value of the density at the infinity.
     */
    double GetDensity_Inf(void);
    
    /*!
     * \brief Compute 2-norm of the velocity at the infinity.
     * \return Value of the 2-norm of the velocity at the infinity.
     */
    double GetModVelocity_Inf(void);
    
    /*!
     * \brief Compute the density multiply by energy at the infinity.
     * \return Value of the density multiply by  energy at the infinity.
     */
    double GetDensity_Energy_Inf(void);
    
    /*!
     * \brief Compute the pressure at the infinity.
     * \return Value of the pressure at the infinity.
     */
    double GetPressure_Inf(void);
    
    /*!
     * \brief Compute the density multiply by velocity at the infinity.
     * \param[in] val_dim - Index of the velocity vector.
     * \return Value of the density multiply by the velocity at the infinity.
     */
    double GetDensity_Velocity_Inf(unsigned short val_dim);
    
    /*!
     * \brief Get the velocity at the infinity.
     * \param[in] val_dim - Index of the velocity vector.
     * \return Value of the velocity at the infinity.
     */
    double GetVelocity_Inf(unsigned short val_dim);
    
    /*!
     * \brief Compute the time step for solving the Euler equations.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     * \param[in] Iteration - Value of the current iteration.
     */
    void SetTime_Step(CGeometry *geometry, CSolver **solver_container, CConfig *config,
                      unsigned short iMesh, unsigned long Iteration);
    
    /*!
     * \brief Compute the spatial integration using a centered scheme.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     */
    void Centered_Residual(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics,
                           CConfig *config, unsigned short iMesh, unsigned short iRKStep);
    
    /*!
     * \brief Compute the spatial integration using a upwind scheme.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     */
    void Upwind_Residual(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics,
                         CConfig *config, unsigned short iMesh);
    
    /*!
     * \brief Source term integration.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] second_numerics - Description of the second numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     */
    void Source_Residual(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics,
                         CNumerics *second_numerics, CConfig *config, unsigned short iMesh);
    
    /*!
     * \brief Compute the velocity^2, SoundSpeed, Pressure, Enthalpy, Viscosity.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iRKStep - Current step of the Runge-Kutta iteration.
     * \param[in] RunTime_EqSystem - System of equations which is going to be solved.
     */
    void Preprocessing(CGeometry *geometry, CSolver **solver_container, CConfig *config, unsigned short iMesh, unsigned short iRKStep, unsigned short RunTime_EqSystem, bool Output);
    
    /*!
     * \brief Compute the gradient of the primitive variables using Green-Gauss method,
     *        and stores the result in the <i>Gradient_Primitive</i> variable.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void SetPrimitive_Gradient_GG(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Compute the gradient of the primitive variables using a Least-Squares method,
     *        and stores the result in the <i>Gradient_Primitive</i> variable.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void SetPrimitive_Gradient_LS(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Compute the gradient of the primitive variables using a Least-Squares method,
     *        and stores the result in the <i>Gradient_Primitive</i> variable.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void SetPrimitive_Gradient_LS(CGeometry *geometry, CConfig *config, unsigned long val_Point);
    
    /*!
     * \brief Compute the limiter of the primitive variables.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void SetPrimitive_Limiter(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Compute slope limiter.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void SetSolution_Limiter(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Compute the preconditioner for convergence acceleration by Roe-Turkel method.
     * \param[in] iPoint - Index of the grid point
     * \param[in] config - Definition of the particular problem.
     */
    void SetPreconditioner(CConfig *config, unsigned short iPoint);
    
    /*!
     * \brief Impose via the residual the Euler wall boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Euler_Wall(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics,
                       CConfig *config, unsigned short val_marker);
    
    /*!
     * \brief Impose the far-field boundary condition using characteristics.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method for convective terms.
     * \param[in] visc_numerics - Description of the numerical method for viscous terms.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Far_Field(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics,
                      CNumerics *visc_numerics, CConfig *config, unsigned short val_marker);
    
    /*!
     * \brief Impose the symmetry boundary condition using the residual.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method for convective terms.
     * \param[in] visc_numerics - Description of the numerical method for viscous terms.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Sym_Plane(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics,
                      CNumerics *visc_numerics, CConfig *config, unsigned short val_marker);
    
    /*!
     * \brief Impose a subsonic inlet boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method for convective terms.
     * \param[in] visc_numerics - Description of the numerical method for viscous terms.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Inlet(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics,
                  CNumerics *visc_numerics, CConfig *config, unsigned short val_marker);
    
    /*!
     * \brief Impose a supersonic inlet boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method for convective terms.
     * \param[in] visc_numerics - Description of the numerical method for viscous terms.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Supersonic_Inlet(CGeometry *geometry, CSolver **solver_container,
                             CNumerics *conv_numerics, CNumerics *visc_numerics,
                             CConfig *config, unsigned short val_marker);
    
    /*!
     * \brief Impose the outlet boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method for convective terms.
     * \param[in] visc_numerics - Description of the numerical method for viscous terms.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     
     */
    void BC_Outlet(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics,
                   CNumerics *visc_numerics, CConfig *config, unsigned short val_marker);
    
    /*!
     * \brief Update the solution using an explicit Euler scheme.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     */
    void ExplicitEuler_Iteration(CGeometry *geometry, CSolver **solver_container, CConfig *config);
    
    /*!
     * \brief Update the solution using an implicit Euler scheme.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     */
    void ImplicitEuler_Iteration(CGeometry *geometry, CSolver **solver_container, CConfig *config);
    
    /*!
     * \brief Compute the pressure forces and all the adimensional coefficients.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void Inviscid_Forces(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Provide the non dimensional lift coefficient (inviscid contribution).
     * \param val_marker Surface where the coefficient is going to be computed.
     * \return Value of the lift coefficient (inviscid contribution) on the surface <i>val_marker</i>.
     */
    double GetCLift_Inv(unsigned short val_marker);
    
    /*!
     * \brief Provide the non dimensional drag coefficient (inviscid contribution).
     * \param val_marker Surface where the coeficient is going to be computed.
     * \return Value of the drag coefficient (inviscid contribution) on the surface <i>val_marker</i>.
     */
    double GetCDrag_Inv(unsigned short val_marker);
    
    /*!
     * \brief Provide the non dimensional sideforce coefficient (inviscid contribution).
     * \param val_marker Surface where the coeficient is going to be computed.
     * \return Value of the sideforce coefficient (inviscid contribution) on the surface <i>val_marker</i>.
     */
    double GetCSideForce_Inv(unsigned short val_marker);
    
    /*!
     * \brief Provide the non dimensional efficiency coefficient (inviscid contribution).
     * \param val_marker Surface where the coeficient is going to be computed.
     * \return Value of the efficiency coefficient (inviscid contribution) on the surface <i>val_marker</i>.
     */
    double GetCEff_Inv(unsigned short val_marker);
    
    /*!
     * \brief Provide the total (inviscid + viscous) non dimensional sideforce coefficient.
     * \return Value of the sideforce coefficient (inviscid + viscous contribution).
     */
    double GetTotal_CSideForce(void);
    
    /*!
     * \brief Provide the total (inviscid + viscous) non dimensional efficiency coefficient.
     * \return Value of the efficiency coefficient (inviscid + viscous contribution).
     */
    double GetTotal_CEff(void);
    
    /*!
     * \brief Store the total (inviscid + viscous) non dimensional lift coefficient.
     * \param[in] val_Total_CLift - Value of the total lift coefficient.
     */
    void SetTotal_CLift(double val_Total_CLift);
    
    /*!
     * \brief Provide the total (inviscid + viscous) non dimensional lift coefficient.
     * \return Value of the lift coefficient (inviscid + viscous contribution).
     */
    double GetTotal_CLift(void);
    
    /*!
     * \brief Provide the total (inviscid + viscous) non dimensional drag coefficient.
     * \return Value of the drag coefficient (inviscid + viscous contribution).
     */
    double GetTotal_CDrag(void);
    
    /*!
     * \brief Provide the total (inviscid + viscous) non dimensional x moment coefficient.
     * \return Value of the moment x coefficient (inviscid + viscous contribution).
     */
    double GetTotal_CMx(void);
    
    /*!
     * \brief Provide the total (inviscid + viscous) non dimensional y moment coefficient.
     * \return Value of the moment y coefficient (inviscid + viscous contribution).
     */
    double GetTotal_CMy(void);
    
    /*!
     * \brief Provide the total (inviscid + viscous) non dimensional z moment coefficient.
     * \return Value of the moment z coefficient (inviscid + viscous contribution).
     */
    double GetTotal_CMz(void);
    
    /*!
     * \brief Provide the total (inviscid + viscous) non dimensional x force coefficient.
     * \return Value of the force x coefficient (inviscid + viscous contribution).
     */
    double GetTotal_CFx(void);
    
    /*!
     * \brief Provide the total (inviscid + viscous) non dimensional y force coefficient.
     * \return Value of the force y coefficient (inviscid + viscous contribution).
     */
    double GetTotal_CFy(void);
    
    /*!
     * \brief Provide the total (inviscid + viscous) non dimensional z force coefficient.
     * \return Value of the force z coefficient (inviscid + viscous contribution).
     */
    double GetTotal_CFz(void);
    
    /*!
     * \brief Provide the total heat load.
     * \return Value of the heat load (viscous contribution).
     */
    double GetTotal_HeatFlux(void);
    
    /*!
     * \brief Provide the total heat load.
     * \return Value of the heat load (viscous contribution).
     */
    double GetTotal_MaxHeatFlux(void);
    
    /*!
     * \brief Store the total heat load.
     * \param[in] val_Total_Heat - Value of the heat load.
     */
    void SetTotal_HeatFlux(double val_Total_Heat);
    
    /*!
     * \brief Store the total heat load.
     * \param[in] val_Total_HeatMax - Value of the heat load.
     */
    void SetTotal_MaxHeatFlux(double val_Total_MaxHeat);
    
    /*!
     * \brief Store the total (inviscid + viscous) non dimensional drag coefficient.
     * \param[in] val_Total_CDrag - Value of the total drag coefficient.
     */
    void SetTotal_CDrag(double val_Total_CDrag);
    
    /*!
     * \brief Get the inviscid contribution to the lift coefficient.
     * \return Value of the lift coefficient (inviscid contribution).
     */
    double GetAllBound_CLift_Inv(void);
    
    /*!
     * \brief Get the inviscid contribution to the drag coefficient.
     * \return Value of the drag coefficient (inviscid contribution).
     */
    double GetAllBound_CDrag_Inv(void);
    
    /*!
     * \brief Get the inviscid contribution to the sideforce coefficient.
     * \return Value of the sideforce coefficient (inviscid contribution).
     */
    double GetAllBound_CSideForce_Inv(void);
    
    /*!
     * \brief Get the inviscid contribution to the efficiency coefficient.
     * \return Value of the efficiency coefficient (inviscid contribution).
     */
    double GetAllBound_CEff_Inv(void);
    
    /*!
     * \brief Get the inviscid contribution to the efficiency coefficient.
     * \return Value of the efficiency coefficient (inviscid contribution).
     */
    double GetAllBound_CMx_Inv(void);
    
    /*!
     * \brief Get the inviscid contribution to the efficiency coefficient.
     * \return Value of the efficiency coefficient (inviscid contribution).
     */
    double GetAllBound_CMy_Inv(void);
    
    /*!
     * \brief Get the inviscid contribution to the efficiency coefficient.
     * \return Value of the efficiency coefficient (inviscid contribution).
     */
    double GetAllBound_CMz_Inv(void);
    
    /*!
     * \brief Get the inviscid contribution to the efficiency coefficient.
     * \return Value of the efficiency coefficient (inviscid contribution).
     */
    double GetAllBound_CFx_Inv(void);
    
    /*!
     * \brief Get the inviscid contribution to the efficiency coefficient.
     * \return Value of the efficiency coefficient (inviscid contribution).
     */
    double GetAllBound_CFy_Inv(void);
    
    /*!
     * \brief Get the inviscid contribution to the efficiency coefficient.
     * \return Value of the efficiency coefficient (inviscid contribution).
     */
    double GetAllBound_CFz_Inv(void);
    
    /*!
     * \brief Provide the Pressure coefficient.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \param[in] val_vertex - Vertex of the marker <i>val_marker</i> where the coefficient is evaluated.
     * \return Value of the pressure coefficient.
     */
    double GetCPressure(unsigned short val_marker, unsigned short val_vertex);
    
    /*!
     * \brief Set the total residual adding the term that comes from the Dual Time Strategy.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iRKStep - Current step of the Runge-Kutta iteration.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     * \param[in] RunTime_EqSystem - System of equations which is going to be solved.
     */
    void SetResidual_DualTime(CGeometry *geometry, CSolver **solver_container, CConfig *config,
                              unsigned short iRKStep, unsigned short iMesh, unsigned short RunTime_EqSystem);
    
    /*!
     * \brief Load a direct flow solution for use with the adjoint solver.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_iZone - Current zone in the mesh.
     */
    void GetRestart(CGeometry *geometry, CConfig *config, unsigned short val_iZone);
    
    /*!
     * \brief Load the output data container with the variables to be written to the volume solution file.
     * \param[in] config - Definition of the particular problem.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] data_container - Container holding the output variable data.
     * \param[in] nOutput_Vars - Number of output variables being stored.
     */
    void SetVolume_Output(CConfig *config, CGeometry *geometry, double **data_container, unsigned short nOutput_Vars);
    
};

/*!
 * \class CTNE2NSSolver
 * \brief Main class for defining the TNE2 Navier-Stokes flow solver.
 * \ingroup Navier_Stokes_Equations
 * \author S. R. Copeland, F. Palacios
 * \version 2.0.6
 */
class CTNE2NSSolver : public CTNE2EulerSolver {
private:
    double Viscosity_Inf;	/*!< \brief Viscosity at the infinity. */
    double Prandtl_Lam,   /*!< \brief Laminar Prandtl number. */
    Prandtl_Turb;         /*!< \brief Turbulent Prandtl number. */
    double *CDrag_Visc,	/*!< \brief Drag coefficient (viscous contribution) for each boundary. */
    *CLift_Visc,		/*!< \brief Lift coefficient (viscous contribution) for each boundary. */
    *CMx_Visc,			/*!< \brief Moment x coefficient (viscous contribution) for each boundary. */
    *CMy_Visc,			/*!< \brief Moment y coefficient (viscous contribution) for each boundary. */
    *CMz_Visc,			/*!< \brief Moment z coefficient (viscous contribution) for each boundary. */
    *CFx_Visc,			/*!< \brief Force x coefficient (viscous contribution) for each boundary. */
    *CFy_Visc,			/*!< \brief Force y coefficient (viscous contribution) for each boundary. */
    *CFz_Visc,			/*!< \brief Force z coefficient (viscous contribution) for each boundary. */
    *CEff_Visc,			/*!< \brief Efficiency (Cl/Cd) (Viscous contribution) for each boundary. */
    *Heat_Visc,		/*!< \brief Heat load (viscous contribution) for each boundary. */
    *MaxHeatFlux_Visc, /*!< \brief Maximum heat flux (viscous contribution) for each boundary. */
    
    **CSkinFriction;	/*!< \brief Skin friction coefficient for each boundary and vertex. */
    double *ForceViscous,	/*!< \brief Viscous force for each boundary. */
    *MomentViscous;			/*!< \brief Inviscid moment for each boundary. */
    double AllBound_CDrag_Visc, /*!< \brief Drag coefficient (viscous contribution) for all the boundaries. */
    AllBound_CLift_Visc,		/*!< \brief Lift coefficient (viscous contribution) for all the boundaries. */
    AllBound_CMx_Visc,			/*!< \brief Moment x coefficient (inviscid contribution) for all the boundaries. */
    AllBound_CMy_Visc,			/*!< \brief Moment y coefficient (inviscid contribution) for all the boundaries. */
    AllBound_CMz_Visc,			/*!< \brief Moment z coefficient (inviscid contribution) for all the boundaries. */
    AllBound_CEff_Visc,			/*!< \brief Efficient coefficient (Viscous contribution) for all the boundaries. */
    AllBound_CFx_Visc,			/*!< \brief Force x coefficient (inviscid contribution) for all the boundaries. */
    AllBound_CFy_Visc,			/*!< \brief Force y coefficient (inviscid contribution) for all the boundaries. */
    AllBound_CFz_Visc,			/*!< \brief Force z coefficient (inviscid contribution) for all the boundaries. */
    AllBound_HeatFlux_Visc,		/*!< \brief Heat load (viscous contribution) for all the boundaries. */
    AllBound_MaxHeatFlux_Visc; /*!< \brief Maximum heat flux (viscous contribution) for all boundaries. */
    
public:
    
    /*!
     * \brief Constructor of the class.
     */
    CTNE2NSSolver(void);
    
    /*!
     * \overload
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    CTNE2NSSolver(CGeometry *geometry, CConfig *config, unsigned short iMesh);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CTNE2NSSolver(void);
    
    /*!
     * \brief Compute the viscosity at the infinity.
     * \return Value of the viscosity at the infinity.
     */
    double GetViscosity_Inf(void);
    
    /*!
     * \brief Compute the time step for solving the Navier-Stokes equations with turbulence model.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     * \param[in] Iteration - Index of the current iteration.
     */
    void SetTime_Step(CGeometry *geometry, CSolver **solver_container, CConfig *config,
                      unsigned short iMesh, unsigned long Iteration);
    
    /*!
     * \brief Restart residual and compute gradients.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iRKStep - Current step of the Runge-Kutta iteration.
     * \param[in] RunTime_EqSystem - System of equations which is going to be solved.
     */
    void Preprocessing(CGeometry *geometry, CSolver **solver_container, CConfig *config, unsigned short iMesh, unsigned short iRKStep, unsigned short RunTime_EqSystem, bool Output);
    
    /*!
     * \brief Impose the symmetry boundary condition using the residual.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method for convective terms.
     * \param[in] visc_numerics - Description of the numerical method for viscous terms.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Sym_Plane(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics,
                      CNumerics *visc_numerics, CConfig *config, unsigned short val_marker);
    
    /*!
     * \brief Impose a constant heat-flux condition at the wall.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method for convective terms.
     * \param[in] visc_numerics - Description of the numerical method for viscous terms.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_HeatFlux_Wall(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics,
                          CNumerics *visc_numerics, CConfig *config, unsigned short val_marker);
    
    /*!
     * \brief Impose a constant heat-flux condition at the wall.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method for convective terms.
     * \param[in] visc_numerics - Description of the numerical method for viscous terms.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_HeatFluxCatalytic_Wall(CGeometry *geometry,
                                   CSolver **solver_container,
                                   CNumerics *conv_numerics,
                                   CNumerics *visc_numerics,
                                   CConfig *config, unsigned short val_marker);
    
    /*!
     * \brief Impose a constant heat-flux condition at the wall.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method for convective terms.
     * \param[in] visc_numerics - Description of the numerical method for viscous terms.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_HeatFluxNonCatalytic_Wall(CGeometry *geometry,
                                      CSolver **solver_container,
                                      CNumerics *conv_numerics,
                                      CNumerics *visc_numerics,
                                      CConfig *config, unsigned short val_marker);
    
    /*!
     * \brief Impose the Navier-Stokes boundary condition (strong).
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method for convective terms.
     * \param[in] visc_numerics - Description of the numerical method for viscous terms.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Isothermal_Wall(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics,
                            CNumerics *visc_numerics, CConfig *config, unsigned short val_marker);
    
    /*!
     * \brief Impose the Navier-Stokes boundary condition (strong).
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method for convective terms.
     * \param[in] visc_numerics - Description of the numerical method for viscous terms.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_IsothermalCatalytic_Wall(CGeometry *geometry,
                                     CSolver **solver_container,
                                     CNumerics *conv_numerics,
                                     CNumerics *visc_numerics,
                                     CConfig *config, unsigned short val_marker);
    
    /*!
     * \brief Impose the Navier-Stokes boundary condition (strong).
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method for convective terms.
     * \param[in] visc_numerics - Description of the numerical method for viscous terms.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_IsothermalNonCatalytic_Wall(CGeometry *geometry,
                                        CSolver **solver_container,
                                        CNumerics *conv_numerics,
                                        CNumerics *visc_numerics,
                                        CConfig *config,
                                        unsigned short val_marker);
    
    /*!
     * \brief Compute the viscous forces and all the addimensional coefficients.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void Viscous_Forces(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Get the non dimensional lift coefficient (viscous contribution).
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \return Value of the lift coefficient (viscous contribution) on the surface <i>val_marker</i>.
     */
    double GetCLift_Visc(unsigned short val_marker);
    
    /*!
     * \brief Get the non dimensional drag coefficient (viscous contribution).
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \return Value of the drag coefficient (viscous contribution) on the surface <i>val_marker</i>.
     */
    double GetCDrag_Visc(unsigned short val_marker);
    
    /*!
     * \brief Get the total non dimensional lift coefficient (viscous contribution).
     * \return Value of the lift coefficient (viscous contribution).
     */
    double GetAllBound_CLift_Visc(void);
    
    /*!
     * \brief Get the total non dimensional drag coefficient (viscous contribution).
     * \return Value of the drag coefficient (viscous contribution).
     */
    double GetAllBound_CDrag_Visc(void);
    
    /*!
     * \brief Compute the viscous residuals.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     * \param[in] iRKStep - Current step of the Runge-Kutta iteration.
     */
    void Viscous_Residual(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics,
                          CConfig *config, unsigned short iMesh, unsigned short iRKStep);
    
    /*!
     * \brief Get the skin friction coefficient.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \param[in] val_vertex - Vertex of the marker <i>val_marker</i> where the coefficient is evaluated.
     * \return Value of the skin friction coefficient.
     */
    double GetCSkinFriction(unsigned short val_marker, unsigned short val_vertex);
    
    /*!
     * \brief Get the skin friction coefficient.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \param[in] val_vertex - Vertex of the marker <i>val_marker</i> where the coefficient is evaluated.
     * \return Value of the heat transfer coefficient.
     */
    double GetHeatFlux(unsigned short val_marker, unsigned short val_vertex);
    
};


/*!
 * \class CAdjEulerSolver
 * \brief Main class for defining the Euler's adjoint flow solver.
 * \ingroup Euler_Equations
 * \author F. Palacios
 * \version 2.0.6
 */
class CAdjTNE2EulerSolver : public CSolver {
protected:
    unsigned short
    nSpecies;
    
    double
    *PsiRho_Inf,	/*!< \brief Free-stream adjoint density. */
    *Phi_Inf,			/*!< \brief Phi vector at the infinity. */
    PsiE_Inf,			/*!< \brief PsiE variable at the infinity. */
    PsiEve_Inf;
    
    double *Sens_Mach, /*!< \brief Mach sensitivity coefficient for each boundary. */
    *Sens_AoA,			/*!< \brief Angle of attack sensitivity coefficient for each boundary. */
    *Sens_Geo,			/*!< \brief Shape sensitivity coefficient for each boundary. */
    *Sens_Press,			/*!< \brief Pressure sensitivity coefficient for each boundary. */
    *Sens_Temp,			/*!< \brief Temperature sensitivity coefficient for each boundary. */
    **CSensitivity;		/*!< \brief Shape sensitivity coefficient for each boundary and vertex. */
    double Total_Sens_Mach;	/*!< \brief Total mach sensitivity coefficient for all the boundaries. */
    double Total_Sens_AoA;		/*!< \brief Total angle of attack sensitivity coefficient for all the boundaries. */
    double Total_Sens_Geo;		/*!< \brief Total shape sensitivity coefficient for all the boundaries. */
    double Total_Sens_Press;    /*!< \brief Total farfield sensitivity to pressure. */
    double Total_Sens_Temp;    /*!< \brief Total farfield sensitivity to temperature. */
    double *iPoint_UndLapl,	/*!< \brief Auxiliary variable for the undivided Laplacians. */
    *jPoint_UndLapl;			/*!< \brief Auxiliary variable for the undivided Laplacians. */
    bool space_centered;  /*!< \brief True if space centered scheeme used. */
    unsigned long nMarker;				/*!< \brief Total number of markers using the grid information. */
    double Gamma, Gamma_Minus_One;
    double **Jacobian_Axisymmetric;
    
public:
    
    /*!
     * \brief Constructor of the class.
     */
    CAdjTNE2EulerSolver(void);
    
    /*!
     * \overload
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     */
    CAdjTNE2EulerSolver(CGeometry *geometry, CConfig *config, unsigned short iMesh);
    
    /*!
     * \brief Destructor of the class.
     */
    virtual ~CAdjTNE2EulerSolver(void);
    
    /*!
     * \brief Impose the send-receive boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void Set_MPI_Solution(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Impose the send-receive boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void Set_MPI_Solution_Gradient(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Impose the send-receive boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void Set_MPI_Solution_Limiter(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Impose the send-receive boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void Set_MPI_Solution_Old(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Created the force projection vector for adjoint boundary conditions.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     */
    void SetForceProj_Vector(CGeometry *geometry, CSolver **solver_container, CConfig *config);
    
    /*!
     * \brief Compute adjoint density at the infinity.
     * \return Value of the adjoint density at the infinity.
     */
    double* GetPsiRhos_Inf(void);
    
    /*!
     * \brief Compute the adjoint energy at the infinity.
     * \return Value of the adjoint energy at the infinity.
     */
    double GetPsiE_Inf(void);
    
    /*!
     * \brief Compute Phi (adjoint velocity) at the infinity.
     * \param[in] val_dim - Index of the adjoint velocity vector.
     * \return Value of the adjoint velocity vector at the infinity.
     */
    double GetPhi_Inf(unsigned short val_dim);
    
    /*!
     * \brief Compute the spatial integration using a centered scheme for the adjoint equations.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     * \param[in] iRKStep - Current step of the Runge-Kutta iteration.
     */
    void Centered_Residual(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics, CConfig *config,
                           unsigned short iMesh, unsigned short iRKStep);
    
    /*!
     * \brief Compute the spatial integration using a upwind scheme.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     */
    void Upwind_Residual(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics, CConfig *config,
                         unsigned short iMesh);
    
    /*!
     * \brief Source term integration.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     */
    void Source_Residual(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics, CNumerics *second_numerics,
                         CConfig *config, unsigned short iMesh);
    
    /*!
     * \brief Compute the undivided laplacian for the adjoint solution.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void SetUndivided_Laplacian(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Parallelization of Undivided Laplacian.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     */
    void Set_MPI_Undivided_Laplacian(CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Impose via the residual the adjoint Euler wall boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Euler_Wall(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics, CConfig *config,
                       unsigned short val_marker);
    
    /*!
     * \brief Impose via the residual the adjoint symmetry boundary condition.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Sym_Plane(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics, CConfig *config,
                      unsigned short val_marker);
    
    /*!
     * \brief Impose the boundary condition to the far field using characteristics.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Far_Field(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics, CConfig *config,
                      unsigned short val_marker);
    
    /*!
     * \brief Update the solution using an explicit solver.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     */
    void ExplicitEuler_Iteration(CGeometry *geometry, CSolver **solver_container, CConfig *config);
    
    /*!
     * \brief Update the solution using an implicit solver.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     */
    void ImplicitEuler_Iteration(CGeometry *geometry, CSolver **solver_container, CConfig *config);
    
    /*!
     * \brief Initialize the residual vectors.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iRKStep - Current step of the Runge-Kutta iteration.
     * \param[in] RunTime_EqSystem - System of equations which is going to be solved.
     */
    void Preprocessing(CGeometry *geometry, CSolver **solver_container, CConfig *config, unsigned short iMesh, unsigned short iRKStep, unsigned short RunTime_EqSystem, bool Output);
    
    /*!
     * \brief Compute the inviscid sensitivity of the functional.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     */
    void Inviscid_Sensitivity(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics, CConfig *config);
    
    /*!
     * \brief Get the shape sensitivity coefficient.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \param[in] val_vertex - Vertex of the marker <i>val_marker</i> where the coefficient is evaluated.
     * \return Value of the sensitivity coefficient.
     */
    double GetCSensitivity(unsigned short val_marker, unsigned short val_vertex);
    
    /*!
     * \brief Set the shape sensitivity coefficient.
     * \param[in] val_marker - Surface marker where the coefficient is computed.
     * \param[in] val_vertex - Vertex of the marker <i>val_marker</i> where the coefficient is evaluated.
     * \param[in] val_sensitivity - Value of the sensitivity coefficient.
     */
    void SetCSensitivity(unsigned short val_marker, unsigned short val_vertex, double val_sensitivity);
    
    /*!
     * \brief Provide the total shape sensitivity coefficient.
     * \return Value of the geometrical sensitivity coefficient
     *         (inviscid + viscous contribution).
     */
    double GetTotal_Sens_Geo(void);
    
    /*!
     * \brief Set the total Mach number sensitivity coefficient.
     * \return Value of the Mach sensitivity coefficient
     *         (inviscid + viscous contribution).
     */
    double GetTotal_Sens_Mach(void);
    
    /*!
     * \brief Set the total angle of attack sensitivity coefficient.
     * \return Value of the angle of attack sensitivity coefficient
     *         (inviscid + viscous contribution).
     */
    double GetTotal_Sens_AoA(void);
    
    /*!
     * \brief Set the total farfield pressure sensitivity coefficient.
     * \return Value of the farfield pressure sensitivity coefficient
     *         (inviscid + viscous contribution).
     */
    double GetTotal_Sens_Press(void);
    
    /*!
     * \brief Set the total farfield temperature sensitivity coefficient.
     * \return Value of the farfield temperature sensitivity coefficient
     *         (inviscid + viscous contribution).
     */
    double GetTotal_Sens_Temp(void);
    
    /*!
     * \brief Set the initial condition for the Euler Equations.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] ExtIter - External iteration.
     */
    void SetInitialCondition(CGeometry **geometry, CSolver ***solver_container, CConfig *config, unsigned long ExtIter);
    
};

/*!
 * \class CAdjNSSolver
 * \brief Main class for defining the Navier-Stokes' adjoint flow solver.
 * \ingroup Navier_Stokes_Equations
 * \author F. Palacios
 * \version 2.0.6
 */
class CAdjTNE2NSSolver : public CAdjTNE2EulerSolver {
public:
    
    /*!
     * \brief Constructor of the class.
     */
    CAdjTNE2NSSolver(void);
    
    /*!
     * \overload
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     */
    CAdjTNE2NSSolver(CGeometry *geometry, CConfig *config, unsigned short iMesh);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CAdjTNE2NSSolver(void);
    
    /*!
     * \brief Impose via the residual or brute force the Navier-Stokes adjoint boundary condition (heat flux).
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_HeatFlux_Wall(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics, CConfig *config,
                          unsigned short val_marker);
    
    /*!
     * \brief Impose via the residual or brute force the Navier-Stokes adjoint boundary condition (heat flux).
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] conv_numerics - Description of the numerical method.
     * \param[in] visc_numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_marker - Surface marker where the boundary condition is applied.
     */
    void BC_Isothermal_Wall(CGeometry *geometry, CSolver **solver_container, CNumerics *conv_numerics, CNumerics *visc_numerics, CConfig *config, unsigned short val_marker);
    
    /*!
     * \brief Restart residual and compute gradients.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iRKStep - Current step of the Runge-Kutta iteration.
     * \param[in] RunTime_EqSystem - System of equations which is going to be solved.
     */
    void Preprocessing(CGeometry *geometry, CSolver **solver_container, CConfig *config, unsigned short iMesh, unsigned short iRKStep, unsigned short RunTime_EqSystem, bool Output);
    
    /*!
     * \brief Compute the viscous sensitivity of the functional.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     */
    void Viscous_Sensitivity(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics, CConfig *config);
    
    /*!
     * \brief Compute the viscous residuals for the adjoint equation.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     * \param[in] iRKStep - Current step of the Runge-Kutta iteration.
     */
    void Viscous_Residual(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics,
                          CConfig *config, unsigned short iMesh, unsigned short iRKStep);
    
    /*!
     * \brief Source term computation.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     */
    void Source_Residual(CGeometry *geometry, CSolver **solver_container, CNumerics *numerics, CNumerics *second_numerics,
                         CConfig *config, unsigned short iMesh);
    
};

 




/* integration_structure.hpp------------------------------------------------------------
 *
 *
 *
 */

/*!
 * \class CIntegration
 * \brief Main class for doing the space integration, time integration, and monitoring
 *        of a system of Partial Differential Equations (PDE).
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CIntegration {
protected:
    double Cauchy_Value,	/*!< \brief Summed value of the convergence indicator. */
    Cauchy_Func;			/*!< \brief Current value of the convergence indicator at one iteration. */
    unsigned short Cauchy_Counter;	/*!< \brief Number of elements of the Cauchy serial. */
    double *Cauchy_Serie;			/*!< \brief Complete Cauchy serial. */
    double Old_Func,	/*!< \brief Old value of the objective function (the function which is monitored). */
    New_Func;			/*!< \brief Current value of the objective function (the function which is monitored). */
    bool Convergence,		/*!< \brief To indicate if the flow solver (direct, adjoint, or linearized) has converged or not. */
    Convergence_FullMG;		/*!< \brief To indicate if the Full Multigrid has converged and it is necessary to add a new level. */
    double InitResidual;	/*!< \brief Initial value of the residual to evaluate the convergence level. */
    
public:
    
    /*!
     * \brief Constructor of the class.
     */
    CIntegration(CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    virtual ~CIntegration(void);
    
    /*!
     * \brief Do the space integration of the numerical system.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] solver - Description of the numerical method.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     * \param[in] iRKStep - Current step of the Runge-Kutta iteration.
     * \param[in] RunTime_EqSystem - System of equations which is going to be solved.
     */
    void Space_Integration(CGeometry *geometry, CSolver **solver_container, CNumerics **numerics, CConfig *config,
                           unsigned short iMesh, unsigned short iRKStep, unsigned short RunTime_EqSystem);
    
    /*!
     * \brief Do the time integration (explicit or implicit) of the numerical system.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iRKStep - Current step of the Runge-Kutta iteration.
     * \param[in] RunTime_EqSystem - System of equations which is going to be solved.
     * \param[in] Iteration - Current iteration.
     */
    void Time_Integration(CGeometry *geometry, CSolver **solver_container, CConfig *config,
                          unsigned short iRKStep, unsigned short RunTime_EqSystem, unsigned long Iteration);
    
    /*!
     * \brief Initialize the adjoint solution using the primal problem.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] RunTime_EqSystem - System of equations which is going to be solved.
     * \param[in] Iteration - Current iteration.
     */
    void Adjoint_Setup(CGeometry ***geometry, CSolver ****solver_container, CConfig **config,
                       unsigned short RunTime_EqSystem, unsigned long Iteration, unsigned short iZone);
    
    /*!
     * \brief Do the convergence analisys to determine if the code must stop the execution.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     * \param[in] Iteration - Current iteration.
     * \param[in] monitor - Objective function that is use to study its convergence.
     */
    void Convergence_Monitoring(CGeometry *geometry, CConfig *config,
                                unsigned long Iteration, double monitor, unsigned short iMesh);
    
    /*!
     * \brief Get the value of the convergence.
     * \return Level of convergence of the solution.
     */
    double GetCauchy_Value(void);
    
    /*!
     * \brief Get the indicator of the convergence for the direct, adjoint and linearized problem.
     * \return <code>TRUE</code> means that the convergence criteria is satisfied;
     *         otherwise <code>FALSE</code>.
     */
    bool GetConvergence(void);
    
    /*!
     * \brief Set the indicator of the convergence.
     * \param[in] value - <code>TRUE</code> means that the convergence criteria is satisfied;
     *            otherwise <code>FALSE</code>.
     */
    void SetConvergence(bool value);
    
    /*!
     * \brief Get the indicator of the convergence for the full multigrid problem.
     * \return <code>TRUE</code> means that the convergence criteria is satisfied;
     *         otherwise <code>FALSE</code>.
     */
    bool GetConvergence_FullMG(void);
    
    /*!
     * \brief Save the solution, and volume at different time steps.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solution - Flow solution.
     * \param[in] config - Definition of the particular problem.
     */
    void SetDualTime_Solver(CGeometry *geometry, CSolver *solver, CConfig *config, unsigned short iMesh);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics_container - Description of the numerical method (the way in which the equations are solved).
     * \param[in] config - Definition of the particular problem.
     * \param[in] RunTime_EqSystem - System of equations which is going to be solved.
     * \param[in] Iteration - Current iteration.
     */
    virtual void MultiGrid_Iteration(CGeometry ***geometry, CSolver ****solver_container, CNumerics *****numerics_container,
                                     CConfig **config, unsigned short RunTime_EqSystem, unsigned long Iteration, unsigned short iZone);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics_container - Description of the numerical method (the way in which the equations are solved).
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     * \param[in] mu - Variable for controlling the kind of multigrid algorithm.
     * \param[in] RunTime_EqSystem - System of equations which is going to be solved.
     * \param[in] Iteration - Current iteration.
     */
    virtual void MultiGrid_Cycle(CGeometry ***geometry, CSolver ****solver_container, CNumerics *****numerics_container,
                                 CConfig **config, unsigned short iMesh, unsigned short mu, unsigned short RunTime_EqSystem,
                                 unsigned long Iteration, unsigned short iZone);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] RunTime_EqSystem - System of equations which is going to be solved.
     * \param[in] Iteration - Current iteration.
     * \param[in] monitor - value of the non-dimensional parameters for monitoring the convergence.
     */
    virtual void NonDimensional_Parameters(CGeometry **geometry, CSolver ***solver_container, CNumerics ****numerics_container,
                                           CConfig *config, unsigned short FinestMesh, unsigned short RunTime_EqSystem, unsigned long Iteration,
                                           double *monitor);
    
    /*!
     * \brief A virtual member.
     * \param[out] sol_fine - Pointer to the solution on the fine grid.
     * \param[in] geo_fine - Geometrical definition of the fine grid.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void SetProlongated_Correction(CSolver *sol_fine, CGeometry *geo_fine, CConfig *config, unsigned short iMesh);
    
    /*!
     * \brief A virtual member.
     * \param[in] RunTime_EqSystem - System of equations which is going to be solved.
     * \param[out] sol_fine - Pointer to the solution on the fine grid.
     * \param[in] sol_coarse - Pointer to the solution on the coarse grid.
     * \param[in] geo_fine - Geometrical definition of the fine grid.
     * \param[in] geo_coarse - Geometrical definition of the coarse grid.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void SetProlongated_Solution(unsigned short RunTime_EqSystem, CSolver *sol_fine, CSolver *sol_coarse,
                                         CGeometry *geo_fine, CGeometry *geo_coarse, CConfig *config);
    
    /*!
     * \brief A virtual member.
     * \param[in] sol_fine - Pointer to the solution on the fine grid.
     * \param[out] sol_coarse - Pointer to the solution on the coarse grid.
     * \param[in] geo_fine - Geometrical definition of the fine grid.
     * \param[in] geo_coarse - Geometrical definition of the coarse grid.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void SetRestricted_Residual(CSolver *sol_fine, CSolver *sol_coarse, CGeometry *geo_fine,
                                        CGeometry *geo_coarse, CConfig *config);
    
    /*!
     * \brief A virtual member.
     * \param[in] RunTime_EqSystem - System of equations which is going to be solved.
     * \param[in] sol_fine - Pointer to the solution on the fine grid.
     * \param[out] sol_coarse - Pointer to the solution on the coarse grid.
     * \param[in] geo_fine - Geometrical definition of the fine grid.
     * \param[in] geo_coarse - Geometrical definition of the coarse grid.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     * \param[in] InclSharedDomain - Include the shared domain in the interpolation.
     */
    virtual void SetRestricted_Solution(unsigned short RunTime_EqSystem, CSolver *sol_fine, CSolver *sol_coarse, CGeometry *geo_fine, CGeometry *geo_coarse, CConfig *config);
    
    /*!
     * \brief A virtual member.
     * \param[in] RunTime_EqSystem - System of equations which is going to be solved.
     * \param[in] sol_fine - Pointer to the solution on the fine grid.
     * \param[out] sol_coarse - Pointer to the solution on the coarse grid.
     * \param[in] geo_fine - Geometrical definition of the fine grid.
     * \param[in] geo_coarse - Geometrical definition of the coarse grid.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     * \param[in] InclSharedDomain - Include the shared domain in the interpolation.
     */
    virtual void SetRestricted_EddyVisc(unsigned short RunTime_EqSystem, CSolver *sol_fine, CSolver *sol_coarse, CGeometry *geo_fine, CGeometry *geo_coarse, CConfig *config);
    
    /*!
     * \brief A virtual member.
     * \param[in] RunTime_EqSystem - System of equations which is going to be solved.
     * \param[in] sol_fine - Pointer to the solution on the fine grid.
     * \param[out] sol_coarse - Pointer to the solution on the coarse grid.
     * \param[in] geo_fine - Geometrical definition of the fine grid.
     * \param[in] geo_coarse - Geometrical definition of the coarse grid.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void SetRestricted_Gradient(unsigned short RunTime_EqSystem, CSolver *sol_fine, CSolver *sol_coarse,
                                        CGeometry *geo_fine, CGeometry *geo_coarse, CConfig *config);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] flow - Flow solution.
     */
    virtual void SetResidual_Term(CGeometry *geometry, CSolver *flow);
    
    /*!
     * \brief A virtual member.
     * \param[in] sol_fine - Pointer to the solution on the fine grid.
     * \param[in] sol_coarse - Pointer to the solution on the coarse grid.
     * \param[in] geo_fine - Geometrical definition of the fine grid.
     * \param[in] geo_coarse - Geometrical definition of the coarse grid.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void SetForcing_Term(CSolver *sol_fine, CSolver *sol_coarse, CGeometry *geo_fine, CGeometry *geo_coarse,
                                 CConfig *config, unsigned short iMesh);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics_container - Description of the numerical method (the way in which the equations are solved).
     * \param[in] config - Definition of the particular problem.
     * \param[in] RunTime_EqSystem - System of equations which is going to be solved.
     * \param[in] Iteration - Current iteration.
     */
    virtual void SingleGrid_Iteration(CGeometry ***geometry, CSolver ****solver_container, CNumerics *****numerics_container,
                                      CConfig **config, unsigned short RunTime_EqSystem, unsigned long Iteration, unsigned short iZone);
    
    /*!
     * \brief A virtual member.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics_container - Description of the numerical method (the way in which the equations are solved).
     * \param[in] config - Definition of the particular problem.
     * \param[in] RunTime_EqSystem - System of equations which is going to be solved.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     */
    virtual void SetPotential_Solver(CGeometry ***geometry, CSolver ****solver_container, CNumerics *****numerics_container,
                                     CConfig **config, unsigned short RunTime_EqSystem, unsigned short iMesh, unsigned short iZone);
    
    /*!
     * \brief A virtual member.
     * \param[in] RunTime_EqSystem - System of equations which is going to be solved.
     * \param[in] solution - Container vector with all the solutions on the finest grid.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] val_nSmooth - Number of smoothing iterations.
     * \param[in] val_smooth_coeff - Relaxation factor.
     * \param[in] config - Definition of the particular problem.
     */
    virtual void Smooth_Solution(unsigned short RunTime_EqSystem, CSolver *solver, CGeometry *geometry,
                                 unsigned short val_nSmooth, double val_smooth_coeff, CConfig *config);
    
};

/*!
 * \class CMultiGridIntegration
 * \brief Class for doing the numerical integration using a multigrid method.
 * \author F. Palacios
 * \version 3.2.9 "eagle"
 */
class CMultiGridIntegration : public CIntegration {
protected:
    
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] config - Definition of the particular problem.
     */
    CMultiGridIntegration(CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CMultiGridIntegration(void);
    
    /*!
     * \brief This subroutine calls the MultiGrid_Cycle and also prepare the multigrid levels and the monitoring.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics_container - Description of the numerical method (the way in which the equations are solved).
     * \param[in] config - Definition of the particular problem.
     * \param[in] RunTime_EqSystem - System of equations which is going to be solved.
     * \param[in] Iteration - Current iteration.
     */
    void MultiGrid_Iteration(CGeometry ***geometry, CSolver ****solver_container, CNumerics *****numerics_container,
                             CConfig **config, unsigned short RunTime_EqSystem, unsigned long Iteration, unsigned short iZone);
    
    /*!
     * \brief Perform a Full-Approximation Storage (FAS) Multigrid.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics_container - Description of the numerical method (the way in which the equations are solved).
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     * \param[in] mu - Variable for controlling the kind of multigrid algorithm.
     * \param[in] RunTime_EqSystem - System of equations which is going to be solved.
     * \param[in] Iteration - Current iteration.
     */
    void MultiGrid_Cycle(CGeometry ***geometry, CSolver ****solver_container, CNumerics *****numerics_container,
                         CConfig **config, unsigned short iMesh, unsigned short mu, unsigned short RunTime_EqSystem,
                         unsigned long Iteration, unsigned short iZone);
    
    /*!
     * \brief Compute the non-dimensional parameters.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] RunTime_EqSystem - System of equations which is going to be solved.
     * \param[in] Iteration - Current iteration.
     * \param[in] monitor - value of the non-dimensional parameters for monitoring the convergence.
     */
    void NonDimensional_Parameters(CGeometry **geometry, CSolver ***solver_container, CNumerics ****numerics_container,
                                   CConfig *config, unsigned short FinestMesh, unsigned short RunTime_EqSystem, unsigned long Iteration,
                                   double *monitor);
    
    /*!
     * \brief Compute the fine solution from a coarse solution.
     * \param[in] RunTime_EqSystem - System of equations which is going to be solved.
     * \param[out] sol_fine - Pointer to the solution on the fine grid.
     * \param[in] sol_coarse - Pointer to the solution on the coarse grid.
     * \param[in] geo_fine - Geometrical definition of the fine grid.
     * \param[in] geo_coarse - Geometrical definition of the coarse grid.
     * \param[in] config - Definition of the particular problem.
     */
    void SetProlongated_Solution(unsigned short RunTime_EqSystem, CSolver *sol_fine, CSolver *sol_coarse,
                                 CGeometry *geo_fine, CGeometry *geo_coarse, CConfig *config);
    
    /*!
     * \brief Compute the fine grid correction from the coarse solution.
     * \param[out] sol_fine - Pointer to the solution on the fine grid.
     * \param[in] sol_coarse - Pointer to the solution on the coarse grid.
     * \param[in] geo_fine - Geometrical definition of the fine grid.
     * \param[in] geo_coarse - Geometrical definition of the coarse grid.
     * \param[in] config - Definition of the particular problem.
     */
    void GetProlongated_Correction(unsigned short RunTime_EqSystem, CSolver *sol_fine, CSolver *sol_coarse, CGeometry *geo_fine,
                                   CGeometry *geo_coarse, CConfig *config);
    
    /*!
     * \brief Do an implicit smoothing of the prolongated correction.
     * \param[in] RunTime_EqSystem - System of equations which is going to be solved.
     * \param[in] solution - Container vector with all the solutions on the finest grid.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] val_nSmooth - Number of smoothing iterations.
     * \param[in] val_smooth_coeff - Relaxation factor.
     * \param[in] config - Definition of the particular problem.
     */
    void SmoothProlongated_Correction(unsigned short RunTime_EqSystem, CSolver *solver, CGeometry *geometry,
                                      unsigned short val_nSmooth, double val_smooth_coeff, CConfig *config);
    
    /*!
     * \brief Do an implicit smoothing of the solution.
     * \param[in] RunTime_EqSystem - System of equations which is going to be solved.
     * \param[in] solution - Container vector with all the solutions on the finest grid.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] val_nSmooth - Number of smoothing iterations.
     * \param[in] val_smooth_coeff - Relaxation factor.
     * \param[in] config - Definition of the particular problem.
     */
    void Smooth_Solution(unsigned short RunTime_EqSystem, CSolver *solver, CGeometry *geometry,
                         unsigned short val_nSmooth, double val_smooth_coeff, CConfig *config);
    
    /*!
     * \brief Set the value of the corrected fine grid solution.
     * \param[out] sol_fine - Pointer to the solution on the fine grid.
     * \param[in] geo_fine - Geometrical definition of the fine grid.
     * \param[in] config - Definition of the particular problem.
     */
    void SetProlongated_Correction(CSolver *sol_fine, CGeometry *geo_fine, CConfig *config, unsigned short iMesh);
    
    /*!
     * \brief Compute truncation error in the coarse grid using the fine grid information.
     * \param[in] sol_fine - Pointer to the solution on the fine grid.
     * \param[out] sol_coarse - Pointer to the solution on the coarse grid.
     * \param[in] geo_fine - Geometrical definition of the fine grid.
     * \param[in] geo_coarse - Geometrical definition of the coarse grid.
     * \param[in] config - Definition of the particular problem.
     */
    void SetRestricted_Residual(CSolver *sol_fine, CSolver *sol_coarse, CGeometry *geo_fine,
                                CGeometry *geo_coarse, CConfig *config);
    
    /*!
     * \brief Restrict solution from fine grid to a coarse grid.
     * \param[in] RunTime_EqSystem - System of equations which is going to be solved.
     * \param[in] sol_fine - Pointer to the solution on the fine grid.
     * \param[out] sol_coarse - Pointer to the solution on the coarse grid.
     * \param[in] geo_fine - Geometrical definition of the fine grid.
     * \param[in] geo_coarse - Geometrical definition of the coarse grid.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     * \param[in] InclSharedDomain - Include the shared domain in the interpolation.
     */
    void SetRestricted_Solution(unsigned short RunTime_EqSystem, CSolver *sol_fine, CSolver *sol_coarse, CGeometry *geo_fine, CGeometry *geo_coarse, CConfig *config);
    
    /*!
     * \brief Compute the gradient in coarse grid using the fine grid information.
     * \param[in] RunTime_EqSystem - System of equations which is going to be solved.
     * \param[in] sol_fine - Pointer to the solution on the fine grid.
     * \param[out] sol_coarse - Pointer to the solution on the coarse grid.
     * \param[in] geo_fine - Geometrical definition of the fine grid.
     * \param[in] geo_coarse - Geometrical definition of the coarse grid.
     * \param[in] config - Definition of the particular problem.
     */
    void SetRestricted_Gradient(unsigned short RunTime_EqSystem, CSolver *sol_fine, CSolver *sol_coarse,
                                CGeometry *geo_fine, CGeometry *geo_coarse, CConfig *config);
    
    /*!
     * \brief Add the truncation error to the residual.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] flow - Flow solution.
     */
    void SetResidual_Term(CGeometry *geometry, CSolver *flow);
    
    /*!
     * \brief Compute the forcing term.
     * \param[in] sol_fine - Pointer to the solution on the fine grid.
     * \param[in] sol_coarse - Pointer to the solution on the coarse grid.
     * \param[in] geo_fine - Geometrical definition of the fine grid.
     * \param[in] geo_coarse - Geometrical definition of the coarse grid.
     * \param[in] config - Definition of the particular problem.
     */
    void SetForcing_Term(CSolver *sol_fine, CSolver *sol_coarse, CGeometry *geo_fine, CGeometry *geo_coarse,
                         CConfig *config, unsigned short iMesh);
};

/*!
 * \class CSingleGridIntegration
 * \brief Class for doing the numerical integration of the turbulence model.
 * \author A. Bueno.
 * \version 3.2.9 "eagle"
 */
class CSingleGridIntegration : public CIntegration {
public:
    
    /*!
     * \brief Constructor of the class.
     * \param[in] config - Definition of the particular problem.
     */
    CSingleGridIntegration(CConfig *config);
    
    /*!
     * \brief Destructor of the class.
     */
    ~CSingleGridIntegration(void);
    
    /*!
     * \brief Do the numerical integration (implicit) of the turbulence solver.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] numerics_container - Description of the numerical method (the way in which the equations are solved).
     * \param[in] config - Definition of the particular problem.
     * \param[in] RunTime_EqSystem - System of equations which is going to be solved.
     * \param[in] Iteration - Current iteration.
     */
    void SingleGrid_Iteration(CGeometry ***geometry, CSolver ****solver_container, CNumerics *****numerics_container,
                              CConfig **config, unsigned short RunTime_EqSystem, unsigned long Iteration, unsigned short iZone);
    
    /*!
     * \brief Restrict solution from fine grid to a coarse grid.
     * \param[in] RunTime_EqSystem - System of equations which is going to be solved.
     * \param[in] sol_fine - Pointer to the solution on the fine grid.
     * \param[out] sol_coarse - Pointer to the solution on the coarse grid.
     * \param[in] geo_fine - Geometrical definition of the fine grid.
     * \param[in] geo_coarse - Geometrical definition of the coarse grid.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     * \param[in] InclSharedDomain - Include the shared domain in the interpolation.
     */
    void SetRestricted_Solution(unsigned short RunTime_EqSystem, CSolver *sol_fine, CSolver *sol_coarse, CGeometry *geo_fine, CGeometry *geo_coarse, CConfig *config);
    
    /*!
     * \brief Restrict solution from fine grid to a coarse grid.
     * \param[in] RunTime_EqSystem - System of equations which is going to be solved.
     * \param[in] sol_fine - Pointer to the solution on the fine grid.
     * \param[out] sol_coarse - Pointer to the solution on the coarse grid.
     * \param[in] geo_fine - Geometrical definition of the fine grid.
     * \param[in] geo_coarse - Geometrical definition of the coarse grid.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iMesh - Index of the mesh in multigrid computations.
     * \param[in] InclSharedDomain - Include the shared domain in the interpolation.
     */
    void SetRestricted_EddyVisc(unsigned short RunTime_EqSystem, CSolver *sol_fine, CSolver *sol_coarse, CGeometry *geo_fine, CGeometry *geo_coarse, CConfig *config);
    
};



/* output_structure.hpp------------------------------------------------------------
 *
 *
 *
 */

class COutput {
    
    
    
protected:
    
public:
    
    
    /*!
     * \brief Constructor of the class.
     */
    COutput(void);
    
    /*!
     * \brief Destructor of the class.
     */
    ~COutput(void);
    
    /*!
     * \brief Writes and organizes the all the output files, except the history one, for serial computations.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iExtIter - Current external (time) iteration.
     * \param[in] val_iZone - Total number of domains in the grid file.
     * \param[in] val_nZone - Total number of domains in the grid file.
     */
    void SetResult_Files(CSolver ****solver_container, CGeometry ***geometry, CConfig **config,
                         unsigned long iExtIter, unsigned short val_nZone);
    
    /*!
     * \brief Writes and organizes the all the output files, except the history one, for serial computations.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iExtIter - Current external (time) iteration.
     * \param[in] val_iZone - Total number of domains in the grid file.
     * \param[in] val_nZone - Total number of domains in the grid file.
     */
    void SetBaselineResult_Files(CSolver **solver, CGeometry **geometry, CConfig **config,
                                 unsigned long iExtIter, unsigned short val_nZone);
    
    /*!
     * \brief Writes and organizes the all the output files, except the history one, for serial computations.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     * \param[in] val_nZone - Total number of domains in the grid file.
     */
    void SetMesh_Files(CGeometry **geometry, CConfig **config, unsigned short val_nZone, bool new_file);
    
    /*!
     * \brief Writes equivalent area.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iExtIter - Current external (time) iteration.
     */
    void SetEquivalentArea(CSolver *solver_container, CGeometry *geometry, CConfig *config,
                           unsigned long iExtIter);
    
    /*!
     * \brief Writes inverse design.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iExtIter - Current external (time) iteration.
     */
    void SetCp_InverseDesign(CSolver *solver_container, CGeometry *geometry, CConfig *config,
                             unsigned long iExtIter);
    
    /*!
     * \brief Writes inverse design.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iExtIter - Current external (time) iteration.
     */
    void SetHeat_InverseDesign(CSolver *solver_container, CGeometry *geometry, CConfig *config,
                               unsigned long iExtIter);
    
    /*!
     * \brief Writes forces at different sections.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iExtIter - Current external (time) iteration.
     */
    void SetForceSections(CSolver *solver_container, CGeometry *geometry, CConfig *config,
                          unsigned long iExtIter);
    
    /*!
     * \brief Writes one dimensional output.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iExtIter - Current external (time) iteration.
     */
    void OneDimensionalOutput(CSolver *solver_container, CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Writes mass flow rate output at monitored marker.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] config - Definition of the particular problem.
     * \param[in] iExtIter - Current external (time) iteration.
     */
    void SetMassFlowRate(CSolver *solver_container, CGeometry *geometry, CConfig *config);
    
    /*!
     * \brief Create and write the file with the flow coefficient on the surface.
     * \param[in] config - Definition of the particular problem.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] FlowSolution - Flow solution.
     * \param[in] iExtIter - Current external (time) iteration.
     * \param[in] val_iZone - Current zone number in the grid file.
     */
    void SetSurfaceCSV_Flow(CConfig *config, CGeometry *geometry, CSolver *FlowSolver, unsigned long iExtIter, unsigned short val_iZone);
    
    /*!
     * \brief Create and write the file with the adjoint coefficients on the surface for serial computations.
     * \param[in] config - Definition of the particular problem.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] AdjSolution - Adjoint solution.
     * \param[in] FlowSolution - Flow solution.
     * \param[in] iExtIter - Current external (time) iteration.
     * \param[in] val_iZone - Current zone number in the grid file.
     */
    void SetSurfaceCSV_Adjoint(CConfig *config, CGeometry *geometry, CSolver *AdjSolver, CSolver *FlowSolution, unsigned long iExtIter, unsigned short val_iZone);
    
    /*!
     * \brief Create and write the file with linearized coefficient on the surface for serial computations
     * \param[in] config - Definition of the particular problem.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] LinSolution - Linearized solution.
     * \param[in] val_filename - Name of the output file.
     * \param[in] iExtIter - Current external (time) iteration.
     */
    void SetSurfaceCSV_Linearized(CConfig *config, CGeometry *geometry, CSolver *LinSolution, string val_filename, unsigned long iExtIter);
    
    /*!
     * \brief Merge the geometry into a data structure used for output file writing.
     * \param[in] config - Definition of the particular problem.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] val_nZone - iZone index.
     */
    void MergeConnectivity(CConfig *config, CGeometry *geometry, unsigned short val_iZone);
    
    /*!
     * \brief Merge the node coordinates from all processors.
     * \param[in] config - Definition of the particular problem.
     * \param[in] geometry - Geometrical definition of the problem.
     */
    void MergeCoordinates(CConfig *config, CGeometry *geometry);
    
    /*!
     * \brief Merge the connectivity for a single element type from all processors.
     * \param[in] config - Definition of the particular problem.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] Elem_Type - VTK index of the element type being merged.
     */
    void MergeVolumetricConnectivity(CConfig *config, CGeometry *geometry, unsigned short Elem_Type);
    
    /*!
     * \brief Merge the connectivity for a single element type from all processors.
     * \param[in] config - Definition of the particular problem.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] Elem_Type - VTK index of the element type being merged.
     */
    void MergeSurfaceConnectivity(CConfig *config, CGeometry *geometry, unsigned short Elem_Type);
    
    /*!
     * \brief Merge the solution into a data structure used for output file writing.
     * \param[in] config - Definition of the particular problem.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solution - Flow, adjoint or linearized solution.
     * \param[in] val_nZone - iZone index.
     */
    void MergeSolution(CConfig *config, CGeometry *geometry, CSolver **solver, unsigned short val_iZone);
    
    /*!
     * \brief Merge the solution into a data structure used for output file writing.
     * \param[in] config - Definition of the particular problem.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solution - Flow, adjoint or linearized solution.
     * \param[in] val_nZone - iZone index.
     */
    void MergeBaselineSolution(CConfig *config, CGeometry *geometry, CSolver *solver, unsigned short val_iZone);
    
    /*!
     * \brief Write a native SU2 restart file.
     * \param[in] config - Definition of the particular problem.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] val_iZone - iZone index.
     */
    void SetRestart(CConfig *config, CGeometry *geometry, CSolver **solver,unsigned short val_iZone);
    
    /*!
     * \brief Write the x, y, & z coordinates to a CGNS output file.
     * \param[in] config - Definition of the particular problem.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] val_iZone - iZone index.
     */
    void SetCGNS_Coordinates(CConfig *config, CGeometry *geometry, unsigned short val_iZone);
    
    /*!
     * \brief Write the element connectivity to a CGNS output file.
     * \param[in] config - Definition of the particular problem.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] val_iZone - iZone index.
     */
    void SetCGNS_Connectivity(CConfig *config, CGeometry *geometry, unsigned short val_iZone);
    
    /*!
     * \brief Write solution data to a CGNS output file.
     * \param[in] config - Definition of the particular problem.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] val_iZone - iZone index.
     */
    void SetCGNS_Solution(CConfig *config, CGeometry *geometry, unsigned short val_iZone);
    
    /*!
     * \brief Write a Paraview ASCII solution file.
     * \param[in] config - Definition of the particular problem.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] val_iZone - Current zone.
     * \param[in] val_nZone - Total number of zones.
     */
    void SetParaview_ASCII(CConfig *config, CGeometry *geometry, unsigned short val_iZone, unsigned short val_nZone, bool surf_sol);
    
    /*!
     * \brief Write a Paraview ASCII solution file.
     * \param[in] config - Definition of the particular problem.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] val_iZone - Current zone.
     * \param[in] val_nZone - Total number of zones.
     */
    void SetParaview_MeshASCII(CConfig *config, CGeometry *geometry, unsigned short val_iZone, unsigned short val_nZone, bool surf_sol);
    
    /*!
     * \brief Write a Tecplot ASCII solution file.
     * \param[in] config - Definition of the particular problem.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] val_iZone - Current zone.
     * \param[in] val_nZone - Total number of zones.
     */
    void SetTecplot_ASCII(CConfig *config, CGeometry *geometry,CSolver **solver, unsigned short val_iZone, unsigned short val_nZone, bool surf_sol);
    
    /*!
     * \brief Write the nodal coordinates and connectivity to a Tecplot binary mesh file.
     * \param[in] config - Definition of the particular problem.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] val_iZone - iZone index.
     */
    void SetTecplot_MeshASCII(CConfig *config, CGeometry *geometry, bool surf_sol, bool new_file);
    
    /*!
     * \brief Write the nodal coordinates and connectivity to a Tecplot binary mesh file.
     * \param[in] config - Definition of the particular problem.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] val_iZone - iZone index.
     */
    void SetTecplot_MeshBinary(CConfig *config, CGeometry *geometry, unsigned short val_iZone);
    
    /*!
     * \brief Write the coordinates and connectivity to a Tecplot binary surface mesh file.
     * \param[in] config - Definition of the particular problem.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] val_iZone - iZone index.
     */
    void SetTecplot_SurfaceMesh(CConfig *config, CGeometry *geometry, unsigned short val_iZone);
    
    /*!
     * \brief Write solution data to a Tecplot binary volume solution file.
     * \param[in] config - Definition of the particular problem.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] val_iZone - iZone index.
     */
    void SetTecplot_Solution(CConfig *config, CGeometry *geometry, unsigned short val_iZone);
    
    /*!
     * \brief Write solution data to a Tecplot binary surface solution file.
     * \param[in] config - Definition of the particular problem.
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] val_iZone - iZone index.
     */
    void SetTecplot_SurfaceSolution(CConfig *config, CGeometry *geometry, unsigned short val_iZone);
    
    /*!
     * \brief Deallocate temporary memory needed for merging and writing coordinates.
     * \param[in] config - Definition of the particular problem.
     * \param[in] geometry - Geometrical definition of the problem.
     */
    void DeallocateCoordinates(CConfig *config, CGeometry *geometry);
    
    /*!
     * \brief Deallocate temporary memory needed for merging and writing connectivity.
     * \param[in] config - Definition of the particular problem.
     * \param[in] geometry - Geometrical definition of the problem.
     */
    void DeallocateConnectivity(CConfig *config, CGeometry *geometry, bool surf_sol);
    
    /*!
     * \brief Deallocate temporary memory needed for merging and writing solution variables.
     * \param[in] config - Definition of the particular problem.
     * \param[in] geometry - Geometrical definition of the problem.
     */
    void DeallocateSolution(CConfig *config, CGeometry *geometry);
    
    /*!
     * \brief Write the header of the history file.
     * \param[in] ConvHist_file - Pointer to the convergence history file (which is defined in the main subroutine).
     * \param[in] config - Definition of the particular problem.
     */
    void SetHistory_Header(ofstream *ConvHist_file, CConfig *config);
    
    /*!
     * \brief Write the history file and the convergence on the screen for serial computations.
     * \param[in] ConvHist_file - Pointer to the convergence history file (which is defined in the main subroutine).
     * \param[in] geometry - Geometrical definition of the problem.
     * \param[in] solver_container - Container vector with all the solutions.
     * \param[in] config - Definition of the particular problem.
     * \param[in] integration - Generic subroutines for space integration, time integration, and monitoring.
     * \param[in] iExtIter - Current external (time) iteration.
     * \param[in] timeused - Current number of clock tick in the computation (related with total time).
     * \param[in] val_nZone - iZone index.
     */
    void SetConvergence_History(ofstream *ConvHist_file, CGeometry ***geometry, CSolver ****solver_container, CConfig **config,
                                CIntegration ***integration, bool DualTime, double timeused, unsigned short val_iZone);
    
};


/* iteration_structure.hpp------------------------------------------------------------
 *
 *
 *
 */

/*!
 * \brief ________________________.
 * \param[in] output - Pointer to the COutput class.
 * \param[in] integration_container - Container vector with all the integration methods.
 * \param[in] geometry_container - Geometrical definition of the problem.
 * \param[in] solver_container - Container vector with all the solutions.
 * \param[in] numerics_container - Description of the numerical method (the way in which the equations are solved).
 * \param[in] config_container - Definition of the particular problem.
 * \param[in] surface_movement - Surface movement classes of the problem.
 * \param[in] grid_movement - Volume grid movement classes of the problem.
 * \param[in] FFDBox - FFD FFDBoxes of the problem.
 * \param[in] ExtIter - Current physical time iteration number.
 */
void MeanFlowIteration(COutput *output, CIntegration ***integration_container, CGeometry ***geometry_container,
                       CSolver ****solver_container, CNumerics *****numerics_container, CConfig **config_container,
                       CSurfaceMovement **surface_movement, CVolumetricMovement **grid_movement, CFreeFormDefBox*** FFDBox);

/*!
 * \brief ________________________.
 * \param[in] output - Pointer to the COutput class.
 * \param[in] integration_container - Container vector with all the integration methods.
 * \param[in] geometry_container - Geometrical definition of the problem.
 * \param[in] solver_container - Container vector with all the solutions.
 * \param[in] numerics_container - Description of the numerical method (the way in which the equations are solved).
 * \param[in] config_container - Definition of the particular problem.
 * \param[in] surface_movement - Surface movement classes of the problem.
 * \param[in] grid_movement - Volume grid movement classes of the problem.
 * \param[in] FFDBox - FFD FFDBoxes of the problem.
 * \param[in] ExtIter - Current physical time iteration number.
 */
void TNE2Iteration(COutput *output, CIntegration ***integration_container, CGeometry ***geometry_container,
                   CSolver ****solver_container, CNumerics *****numerics_container, CConfig **config_container,
                   CSurfaceMovement **surface_movement, CVolumetricMovement **grid_movement, CFreeFormDefBox*** FFDBox);

/*!
 * \brief ________________________.
 * \param[in] output - Pointer to the COutput class.
 * \param[in] integration_container - Container vector with all the integration methods.
 * \param[in] geometry_container - Geometrical definition of the problem.
 * \param[in] solver_container - Container vector with all the solutions.
 * \param[in] numerics_container - Description of the numerical method (the way in which the equations are solved).
 * \param[in] config_container - Definition of the particular problem.
 * \param[in] surface_movement - Surface movement classes of the problem.
 * \param[in] grid_movement - Volume grid movement classes of the problem.
 * \param[in] FFDBox - FFD FFDBoxes of the problem.
 * \param[in] ExtIter - Current physical time iteration number.
 */
void FluidStructureIteration(COutput *output, CIntegration ***integration_container, CGeometry ***geometry_container,
                             CSolver ****solver_container, CNumerics *****numerics_container, CConfig **config_container,
                             CSurfaceMovement **surface_movement, CVolumetricMovement **grid_movement, CFreeFormDefBox*** FFDBox);

/*!
 * \brief ________________________.
 * \param[in] output - Pointer to the COutput class.
 * \param[in] integration_container - Container vector with all the integration methods.
 * \param[in] geometry_container - Geometrical definition of the problem.
 * \param[in] solver_container - Container vector with all the solutions.
 * \param[in] numerics_container - Description of the numerical method (the way in which the equations are solved).
 * \param[in] config_container - Definition of the particular problem.
 * \param[in] surface_movement - Surface movement classes of the problem.
 * \param[in] grid_movement - Volume grid movement classes of the problem.
 * \param[in] FFDBox - FFD FFDBoxes of the problem.
 * \param[in] ExtIter - Current physical time iteration number.
 */
void WaveIteration(COutput *output, CIntegration ***integration_container, CGeometry ***geometry_container,
                   CSolver ****solver_container, CNumerics *****numerics_container, CConfig **config_container,
                   CSurfaceMovement **surface_movement, CVolumetricMovement **grid_movement, CFreeFormDefBox*** FFDBox);

/*!
 * \brief ________________________.
 * \param[in] output - Pointer to the COutput class.
 * \param[in] integration_container - Container vector with all the integration methods.
 * \param[in] geometry_container - Geometrical definition of the problem.
 * \param[in] solver_container - Container vector with all the solutions.
 * \param[in] numerics_container - Description of the numerical method (the way in which the equations are solved).
 * \param[in] config_container - Definition of the particular problem.
 * \param[in] surface_movement - Surface movement classes of the problem.
 * \param[in] grid_movement - Volume grid movement classes of the problem.
 * \param[in] FFDBox - FFD FFDBoxes of the problem.
 * \param[in] ExtIter - Current physical time iteration number.
 */
void HeatIteration(COutput *output, CIntegration ***integration_container, CGeometry ***geometry_container,
                   CSolver ****solver_container, CNumerics *****numerics_container, CConfig **config_container,
                   CSurfaceMovement **surface_movement, CVolumetricMovement **grid_movement, CFreeFormDefBox*** FFDBox);

/*!
 * \brief ________________________.
 * \param[in] output - Pointer to the COutput class.
 * \param[in] integration_container - Container vector with all the integration methods.
 * \param[in] geometry_container - Geometrical definition of the problem.
 * \param[in] solver_container - Container vector with all the solutions.
 * \param[in] numerics_container - Description of the numerical method (the way in which the equations are solved).
 * \param[in] config_container - Definition of the particular problem.
 * \param[in] surface_movement - Surface movement classes of the problem.
 * \param[in] grid_movement - Volume grid movement classes of the problem.
 * \param[in] FFDBox - FFD FFDBoxes of the problem.
 * \param[in] ExtIter - Current physical time iteration number.
 */
void PoissonIteration(COutput *output, CIntegration ***integration_container, CGeometry ***geometry_container,
                      CSolver ****solver_container, CNumerics *****numerics_container, CConfig **config_container,
                      CSurfaceMovement **surface_movement, CVolumetricMovement **grid_movement, CFreeFormDefBox*** FFDBox);

/*!
 * \brief ________________________.
 * \param[in] output - Pointer to the COutput class.
 * \param[in] integration_container - Container vector with all the integration methods.
 * \param[in] geometry_container - Geometrical definition of the problem.
 * \param[in] solver_container - Container vector with all the solutions.
 * \param[in] numerics_container - Description of the numerical method (the way in which the equations are solved).
 * \param[in] config_container - Definition of the particular problem.
 * \param[in] surface_movement - Surface movement classes of the problem.
 * \param[in] grid_movement - Volume grid movement classes of the problem.
 * \param[in] FFDBox - FFD FFDBoxes of the problem.
 * \param[in] ExtIter - Current physical time iteration number.
 */
void FEAIteration(COutput *output, CIntegration ***integration_container, CGeometry ***geometry_container,
                  CSolver ****solver_container, CNumerics *****numerics_container, CConfig **config_container,
                  CSurfaceMovement **surface_movement, CVolumetricMovement **grid_movement, CFreeFormDefBox*** FFDBox);

/*!
 * \brief ________________________.
 * \param[in] output - Pointer to the COutput class.
 * \param[in] integration_container - Container vector with all the integration methods.
 * \param[in] geometry_container - Geometrical definition of the problem.
 * \param[in] solver_container - Container vector with all the solutions.
 * \param[in] numerics_container - Description of the numerical method (the way in which the equations are solved).
 * \param[in] config_container - Definition of the particular problem.
 * \param[in] surface_movement - Surface movement classes of the problem.
 * \param[in] grid_movement - Volume grid movement classes of the problem.
 * \param[in] FFDBox - FFD FFDBoxes of the problem.
 * \param[in] ExtIter - Current physical time iteration number.
 */
void AdjMeanFlowIteration(COutput *output, CIntegration ***integration_container, CGeometry ***geometry_container,
                          CSolver ****solver_container, CNumerics *****numerics_container, CConfig **config_container,
                          CSurfaceMovement **surface_movement, CVolumetricMovement **grid_movement, CFreeFormDefBox*** FFDBox);

/*!
 * \brief ________________________.
 * \param[in] output - Pointer to the COutput class.
 * \param[in] integration_container - Container vector with all the integration methods.
 * \param[in] geometry_container - Geometrical definition of the problem.
 * \param[in] solver_container - Container vector with all the solutions.
 * \param[in] numerics_container - Description of the numerical method (the way in which the equations are solved).
 * \param[in] config_container - Definition of the particular problem.
 * \param[in] surface_movement - Surface movement classes of the problem.
 * \param[in] grid_movement - Volume grid movement classes of the problem.
 * \param[in] FFDBox - FFD FFDBoxes of the problem.
 * \param[in] ExtIter - Current physical time iteration number.
 */
void AdjTNE2Iteration(COutput *output, CIntegration ***integration_container,
                      CGeometry ***geometry_container,
                      CSolver ****solver_container,
                      CNumerics *****numerics_container,
                      CConfig **config_container,
                      CSurfaceMovement **surface_movement,
                      CVolumetricMovement **grid_movement,
                      CFreeFormDefBox*** FFDBox);

/*!
 * \brief Imposes a gust via the grid velocities.
 * \author S. Padron
 * \param[in] config_container - Definition of the particular problem.
 * \param[in] geometry_container - Geometrical definition of the problem.
 * \param[in] solver_container - Container vector with all the solutions.
 */
void SetWind_GustField(CConfig *config_container, CGeometry **geometry_container, CSolver ***solver_container);

/*!
 * \brief Reads and initializes the vortex positions, strengths and gradient.
 * \author S. Padron
 * \param[in] nVortex - number of vortices.
 * \param[in] x0 - Vector of x-loc of the vortices.
 * \param[in] y0 - Vector of y-loc of the vortices.
 * \param[in] vort_strength - Vector of vortex strengths.
 * \param[in] r_core - Vector of vortex core size.
 */
void InitializeVortexDistribution(unsigned long &nVortex, vector<double>& x0,vector<double>& y0,vector<double>& vort_strength,vector<double>& r_core);

/*!
 * \brief Updates the positions and grid velocities for dynamic meshes between physical time steps.
 * \author T. Economon
 * \param[in] geometry - Geometrical definition of the problem.
 * \param[in] surface_movement - Surface movement classes of the problem.
 * \param[in] grid_movement - Volume grid movement classes of the problem.
 * \param[in] FFDBox - FFD FFDBoxes of the problem.
 * \param[in] solver_container - Container vector with all the solutions.
 * \param[in] config - Definition of the particular problem.
 * \param[in] iZone - Index of the zone.
 * \param[in] IntIter - Current sudo time iteration number.
 * \param[in] ExtIter - Current physical time iteration number.
 */
void SetGrid_Movement(CGeometry **geometry_container, CSurfaceMovement *surface_movement,
                      CVolumetricMovement *grid_movement, CFreeFormDefBox **FFDBox,
                      CSolver ***solver_container, CConfig *config_container, unsigned short iZone, unsigned long IntIter, unsigned long ExtIter);

/*!
 * \brief Computation and storage of the time spectral source terms.
 * \author T. Economon, K. Naik
 * \param[in] geometry - Geometrical definition of the problem.
 * \param[in] solver_container - Container vector with all the solutions.
 * \param[in] config - Definition of the particular problem.
 * \param[in] nZone - Total number of zones (periodic instances).
 * \param[in] iZone - Current zone number.
 */
void SetTimeSpectral(CGeometry ***geometry_container, CSolver ****solver_container,
                     CConfig **config_container, unsigned short nZone, unsigned short iZone);

/*!
 * \brief Computation of the Time-Spectral operator matrix.
 * \author K. Naik
 * \param[in] D - double pointer to the operator matrix.
 * \param[in] nZone - Total number of zones (periodic instances).
 */
void ComputeTimeSpectral_Operator(double **D, double period, unsigned short nZone);

/*!
 * \brief Computation and storage of the time-spectral mesh velocities.
 * \author K. Naik, T. Economon
 * \param[in] geometry - Geometrical definition of the problem.
 * \param[in] config - Definition of the particular problem.
 * \param[in] nZone - Total number of zones (periodic instances).
 */
void SetTimeSpectral_Velocities(CGeometry ***geometry_container,
                                CConfig **config_container, unsigned short nZone);




/* definition_structure.hpp------------------------------------------------------------
 *
 *
 *
 */

/*!
 * \brief ________________________.
 * \param[in] output - Pointer to the COutput class.
 * \param[in] integration_container - Container vector with all the integration methods.
 * \param[in] geometry_container - Geometrical definition of the problem.
 * \param[in] solver_container - Container vector with all the solutions.
 * \param[in] numerics_container - Description of the numerical method (the way in which the equations are solved).
 * \param[in] config_container - Definition of the particular problem.
 * \param[in] surface_movement - Surface movement classes of the problem.
 * \param[in] grid_movement - Volume grid movement classes of the problem.
 * \param[in] FFDBox - FFD FFDBoxes of the problem.
 * \param[in] ExtIter - Current physical time iteration number.
 */
void MeanFlowIteration(COutput *output, CIntegration ***integration_container, CGeometry ***geometry_container,
                       CSolver ****solver_container, CNumerics *****numerics_container, CConfig **config_container,
                       CSurfaceMovement **surface_movement, CVolumetricMovement **grid_movement, CFreeFormDefBox*** FFDBox);

/*!
 * \brief ________________________.
 * \param[in] output - Pointer to the COutput class.
 * \param[in] integration_container - Container vector with all the integration methods.
 * \param[in] geometry_container - Geometrical definition of the problem.
 * \param[in] solver_container - Container vector with all the solutions.
 * \param[in] numerics_container - Description of the numerical method (the way in which the equations are solved).
 * \param[in] config_container - Definition of the particular problem.
 * \param[in] surface_movement - Surface movement classes of the problem.
 * \param[in] grid_movement - Volume grid movement classes of the problem.
 * \param[in] FFDBox - FFD FFDBoxes of the problem.
 * \param[in] ExtIter - Current physical time iteration number.
 */
void TNE2Iteration(COutput *output, CIntegration ***integration_container, CGeometry ***geometry_container,
                   CSolver ****solver_container, CNumerics *****numerics_container, CConfig **config_container,
                   CSurfaceMovement **surface_movement, CVolumetricMovement **grid_movement, CFreeFormDefBox*** FFDBox);

/*!
 * \brief ________________________.
 * \param[in] output - Pointer to the COutput class.
 * \param[in] integration_container - Container vector with all the integration methods.
 * \param[in] geometry_container - Geometrical definition of the problem.
 * \param[in] solver_container - Container vector with all the solutions.
 * \param[in] numerics_container - Description of the numerical method (the way in which the equations are solved).
 * \param[in] config_container - Definition of the particular problem.
 * \param[in] surface_movement - Surface movement classes of the problem.
 * \param[in] grid_movement - Volume grid movement classes of the problem.
 * \param[in] FFDBox - FFD FFDBoxes of the problem.
 * \param[in] ExtIter - Current physical time iteration number.
 */
void FluidStructureIteration(COutput *output, CIntegration ***integration_container, CGeometry ***geometry_container,
                             CSolver ****solver_container, CNumerics *****numerics_container, CConfig **config_container,
                             CSurfaceMovement **surface_movement, CVolumetricMovement **grid_movement, CFreeFormDefBox*** FFDBox);

/*!
 * \brief ________________________.
 * \param[in] output - Pointer to the COutput class.
 * \param[in] integration_container - Container vector with all the integration methods.
 * \param[in] geometry_container - Geometrical definition of the problem.
 * \param[in] solver_container - Container vector with all the solutions.
 * \param[in] numerics_container - Description of the numerical method (the way in which the equations are solved).
 * \param[in] config_container - Definition of the particular problem.
 * \param[in] surface_movement - Surface movement classes of the problem.
 * \param[in] grid_movement - Volume grid movement classes of the problem.
 * \param[in] FFDBox - FFD FFDBoxes of the problem.
 * \param[in] ExtIter - Current physical time iteration number.
 */
void WaveIteration(COutput *output, CIntegration ***integration_container, CGeometry ***geometry_container,
                   CSolver ****solver_container, CNumerics *****numerics_container, CConfig **config_container,
                   CSurfaceMovement **surface_movement, CVolumetricMovement **grid_movement, CFreeFormDefBox*** FFDBox);

/*!
 * \brief ________________________.
 * \param[in] output - Pointer to the COutput class.
 * \param[in] integration_container - Container vector with all the integration methods.
 * \param[in] geometry_container - Geometrical definition of the problem.
 * \param[in] solver_container - Container vector with all the solutions.
 * \param[in] numerics_container - Description of the numerical method (the way in which the equations are solved).
 * \param[in] config_container - Definition of the particular problem.
 * \param[in] surface_movement - Surface movement classes of the problem.
 * \param[in] grid_movement - Volume grid movement classes of the problem.
 * \param[in] FFDBox - FFD FFDBoxes of the problem.
 * \param[in] ExtIter - Current physical time iteration number.
 */
void HeatIteration(COutput *output, CIntegration ***integration_container, CGeometry ***geometry_container,
                   CSolver ****solver_container, CNumerics *****numerics_container, CConfig **config_container,
                   CSurfaceMovement **surface_movement, CVolumetricMovement **grid_movement, CFreeFormDefBox*** FFDBox);

/*!
 * \brief ________________________.
 * \param[in] output - Pointer to the COutput class.
 * \param[in] integration_container - Container vector with all the integration methods.
 * \param[in] geometry_container - Geometrical definition of the problem.
 * \param[in] solver_container - Container vector with all the solutions.
 * \param[in] numerics_container - Description of the numerical method (the way in which the equations are solved).
 * \param[in] config_container - Definition of the particular problem.
 * \param[in] surface_movement - Surface movement classes of the problem.
 * \param[in] grid_movement - Volume grid movement classes of the problem.
 * \param[in] FFDBox - FFD FFDBoxes of the problem.
 * \param[in] ExtIter - Current physical time iteration number.
 */
void PoissonIteration(COutput *output, CIntegration ***integration_container, CGeometry ***geometry_container,
                      CSolver ****solver_container, CNumerics *****numerics_container, CConfig **config_container,
                      CSurfaceMovement **surface_movement, CVolumetricMovement **grid_movement, CFreeFormDefBox*** FFDBox);

/*!
 * \brief ________________________.
 * \param[in] output - Pointer to the COutput class.
 * \param[in] integration_container - Container vector with all the integration methods.
 * \param[in] geometry_container - Geometrical definition of the problem.
 * \param[in] solver_container - Container vector with all the solutions.
 * \param[in] numerics_container - Description of the numerical method (the way in which the equations are solved).
 * \param[in] config_container - Definition of the particular problem.
 * \param[in] surface_movement - Surface movement classes of the problem.
 * \param[in] grid_movement - Volume grid movement classes of the problem.
 * \param[in] FFDBox - FFD FFDBoxes of the problem.
 * \param[in] ExtIter - Current physical time iteration number.
 */
void FEAIteration(COutput *output, CIntegration ***integration_container, CGeometry ***geometry_container,
                  CSolver ****solver_container, CNumerics *****numerics_container, CConfig **config_container,
                  CSurfaceMovement **surface_movement, CVolumetricMovement **grid_movement, CFreeFormDefBox*** FFDBox);

/*!
 * \brief ________________________.
 * \param[in] output - Pointer to the COutput class.
 * \param[in] integration_container - Container vector with all the integration methods.
 * \param[in] geometry_container - Geometrical definition of the problem.
 * \param[in] solver_container - Container vector with all the solutions.
 * \param[in] numerics_container - Description of the numerical method (the way in which the equations are solved).
 * \param[in] config_container - Definition of the particular problem.
 * \param[in] surface_movement - Surface movement classes of the problem.
 * \param[in] grid_movement - Volume grid movement classes of the problem.
 * \param[in] FFDBox - FFD FFDBoxes of the problem.
 * \param[in] ExtIter - Current physical time iteration number.
 */
void AdjMeanFlowIteration(COutput *output, CIntegration ***integration_container, CGeometry ***geometry_container,
                          CSolver ****solver_container, CNumerics *****numerics_container, CConfig **config_container,
                          CSurfaceMovement **surface_movement, CVolumetricMovement **grid_movement, CFreeFormDefBox*** FFDBox);

/*!
 * \brief ________________________.
 * \param[in] output - Pointer to the COutput class.
 * \param[in] integration_container - Container vector with all the integration methods.
 * \param[in] geometry_container - Geometrical definition of the problem.
 * \param[in] solver_container - Container vector with all the solutions.
 * \param[in] numerics_container - Description of the numerical method (the way in which the equations are solved).
 * \param[in] config_container - Definition of the particular problem.
 * \param[in] surface_movement - Surface movement classes of the problem.
 * \param[in] grid_movement - Volume grid movement classes of the problem.
 * \param[in] FFDBox - FFD FFDBoxes of the problem.
 * \param[in] ExtIter - Current physical time iteration number.
 */
void AdjTNE2Iteration(COutput *output, CIntegration ***integration_container,
                      CGeometry ***geometry_container,
                      CSolver ****solver_container,
                      CNumerics *****numerics_container,
                      CConfig **config_container,
                      CSurfaceMovement **surface_movement,
                      CVolumetricMovement **grid_movement,
                      CFreeFormDefBox*** FFDBox);

/*!
 * \brief Imposes a gust via the grid velocities.
 * \author S. Padron
 * \param[in] config_container - Definition of the particular problem.
 * \param[in] geometry_container - Geometrical definition of the problem.
 * \param[in] solver_container - Container vector with all the solutions.
 */
void SetWind_GustField(CConfig *config_container, CGeometry **geometry_container, CSolver ***solver_container);

/*!
 * \brief Reads and initializes the vortex positions, strengths and gradient.
 * \author S. Padron
 * \param[in] nVortex - number of vortices.
 * \param[in] x0 - Vector of x-loc of the vortices.
 * \param[in] y0 - Vector of y-loc of the vortices.
 * \param[in] vort_strength - Vector of vortex strengths.
 * \param[in] r_core - Vector of vortex core size.
 */
void InitializeVortexDistribution(unsigned long &nVortex, vector<double>& x0, vector<double>& y0, vector<double>& vort_strength, vector<double>& r_core);

/*!
 * \brief Updates the positions and grid velocities for dynamic meshes between physical time steps.
 * \author T. Economon
 * \param[in] geometry - Geometrical definition of the problem.
 * \param[in] surface_movement - Surface movement classes of the problem.
 * \param[in] grid_movement - Volume grid movement classes of the problem.
 * \param[in] FFDBox - FFD FFDBoxes of the problem.
 * \param[in] solver_container - Container vector with all the solutions.
 * \param[in] config - Definition of the particular problem.
 * \param[in] iZone - Index of the zone.
 * \param[in] IntIter - Current sudo time iteration number.
 * \param[in] ExtIter - Current physical time iteration number.
 */
void SetGrid_Movement(CGeometry **geometry_container, CSurfaceMovement *surface_movement,
                      CVolumetricMovement *grid_movement, CFreeFormDefBox **FFDBox,
                      CSolver ***solver_container, CConfig *config_container, unsigned short iZone, unsigned long IntIter, unsigned long ExtIter);

/*!
 * \brief Computation and storage of the time spectral source terms.
 * \author T. Economon, K. Naik
 * \param[in] geometry - Geometrical definition of the problem.
 * \param[in] solver_container - Container vector with all the solutions.
 * \param[in] config - Definition of the particular problem.
 * \param[in] nZone - Total number of zones (periodic instances).
 * \param[in] iZone - Current zone number.
 */
void SetTimeSpectral(CGeometry ***geometry_container, CSolver ****solver_container,
                     CConfig **config_container, unsigned short nZone, unsigned short iZone);

/*!
 * \brief Computation of the Time-Spectral operator matrix.
 * \author K. Naik
 * \param[in] D - double pointer to the operator matrix.
 * \param[in] nZone - Total number of zones (periodic instances).
 */
void ComputeTimeSpectral_Operator(double **D, double period, unsigned short nZone);

/*!
 * \brief Computation and storage of the time-spectral mesh velocities.
 * \author K. Naik, T. Economon
 * \param[in] geometry - Geometrical definition of the problem.
 * \param[in] config - Definition of the particular problem.
 * \param[in] nZone - Total number of zones (periodic instances).
 */
void SetTimeSpectral_Velocities(CGeometry ***geometry_container,
                                CConfig **config_container, unsigned short nZone);





/* SU2_interface.hpp------------------------------------------------------------
 *
 *
 *
 */


/*!
 * \class SU2_interface
 * \brief Main class for defining the PDE solution, it requires
 * a child class for each particular solver (Euler, Navier-Stokes, etc.)
 * \author F. Palacios.
 * \version 3.2.0 "eagle"
 */



class SU2_interface {
    
    unsigned long ExtIter,ExtIter_f;
    unsigned short iMesh, iZone, iSol, nZone, nDim;
    ofstream ConvHist_file;
    bool StopCalc;
    double StartTime, StopTime, UsedTime;
    int rank,size;
    char runtime_file_name[MAX_STRING_SIZE];
    
    //MPI_Comm SU2_comm_local;
    
public:
    
    //data members
    COutput *output;
    CIntegration ***integration_container;
    CGeometry ***geometry_container;
    CSolver ****solver_container;
    CNumerics *****numerics_container;
    CConfig **config_container;
    CSurfaceMovement **surface_movement;
    CVolumetricMovement **grid_movement;
    CFreeFormDefBox*** FFDBox;
    
    CGeometry *geometry_aux;
    
    
    //char config_file_name[200];
    
    CConfig *config;
    
    
    // Functions
    
    
    //SU2_interface(char case_filename[200],MPI_Comm SU2_comm_interface);
    SU2_interface(char case_filename[200]);
    
    void Run_Steady_Cfd(void);
    
    void Write_Output(void);
    
    void Run_Steady_Iteration(unsigned long no_of_iterations);
    
    void Deform_Mesh(void);
    
    void Write_Surface_Mesh(unsigned long iterations);
    
    void Write_Final_Output(void);
    
    //void Partition_Mesh(void);
    
};





